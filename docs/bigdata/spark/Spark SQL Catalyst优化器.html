<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spark SQL Catalyst优化器 | 大数据技术文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="./favicon.ico">
    <meta name="description" content="从入门到入土">
    
    <link rel="preload" href="./assets/css/0.styles.2c6e287f.css" as="style"><link rel="preload" href="./assets/js/app.9ce0d262.js" as="script"><link rel="preload" href="./assets/js/2.fa5f1a4a.js" as="script"><link rel="preload" href="./assets/js/59.4d5f847f.js" as="script"><link rel="prefetch" href="./assets/js/10.6940d239.js"><link rel="prefetch" href="./assets/js/100.22cf6913.js"><link rel="prefetch" href="./assets/js/101.8a31dcdc.js"><link rel="prefetch" href="./assets/js/102.147ef11e.js"><link rel="prefetch" href="./assets/js/103.cc281f62.js"><link rel="prefetch" href="./assets/js/104.2e0465e5.js"><link rel="prefetch" href="./assets/js/105.910aa23c.js"><link rel="prefetch" href="./assets/js/106.5466141f.js"><link rel="prefetch" href="./assets/js/107.a92bd18e.js"><link rel="prefetch" href="./assets/js/108.51fca30a.js"><link rel="prefetch" href="./assets/js/109.6119ffd0.js"><link rel="prefetch" href="./assets/js/11.bd53d768.js"><link rel="prefetch" href="./assets/js/110.eda784ab.js"><link rel="prefetch" href="./assets/js/111.12c174e7.js"><link rel="prefetch" href="./assets/js/112.8f45d1d2.js"><link rel="prefetch" href="./assets/js/113.e0bb8777.js"><link rel="prefetch" href="./assets/js/114.2ffc5abc.js"><link rel="prefetch" href="./assets/js/115.264d88bb.js"><link rel="prefetch" href="./assets/js/116.43a8b13e.js"><link rel="prefetch" href="./assets/js/117.03317ae7.js"><link rel="prefetch" href="./assets/js/118.dee53adb.js"><link rel="prefetch" href="./assets/js/119.662a11fb.js"><link rel="prefetch" href="./assets/js/12.b25bd03a.js"><link rel="prefetch" href="./assets/js/120.8d1c0658.js"><link rel="prefetch" href="./assets/js/121.c866d980.js"><link rel="prefetch" href="./assets/js/122.141777da.js"><link rel="prefetch" href="./assets/js/123.64bf1df0.js"><link rel="prefetch" href="./assets/js/124.0f402852.js"><link rel="prefetch" href="./assets/js/125.adf420b6.js"><link rel="prefetch" href="./assets/js/126.5ac52ff6.js"><link rel="prefetch" href="./assets/js/127.31a2c0b9.js"><link rel="prefetch" href="./assets/js/128.ee1158fc.js"><link rel="prefetch" href="./assets/js/129.ea47f41d.js"><link rel="prefetch" href="./assets/js/13.127a8756.js"><link rel="prefetch" href="./assets/js/130.169a1c91.js"><link rel="prefetch" href="./assets/js/131.25141855.js"><link rel="prefetch" href="./assets/js/132.1961433f.js"><link rel="prefetch" href="./assets/js/133.4a4b3148.js"><link rel="prefetch" href="./assets/js/134.3cf3137b.js"><link rel="prefetch" href="./assets/js/135.25c96955.js"><link rel="prefetch" href="./assets/js/136.34bc078a.js"><link rel="prefetch" href="./assets/js/137.0d68c97e.js"><link rel="prefetch" href="./assets/js/138.06820a54.js"><link rel="prefetch" href="./assets/js/139.25951593.js"><link rel="prefetch" href="./assets/js/14.ee4f6d75.js"><link rel="prefetch" href="./assets/js/140.9631a9a0.js"><link rel="prefetch" href="./assets/js/141.7e3c7d7b.js"><link rel="prefetch" href="./assets/js/142.fc0ba6d0.js"><link rel="prefetch" href="./assets/js/143.a87cd9f4.js"><link rel="prefetch" href="./assets/js/144.b8153695.js"><link rel="prefetch" href="./assets/js/145.5bb910bf.js"><link rel="prefetch" href="./assets/js/146.48346688.js"><link rel="prefetch" href="./assets/js/147.14fdd265.js"><link rel="prefetch" href="./assets/js/148.910c7bb0.js"><link rel="prefetch" href="./assets/js/149.17e89273.js"><link rel="prefetch" href="./assets/js/15.4c07895d.js"><link rel="prefetch" href="./assets/js/150.c09b3d84.js"><link rel="prefetch" href="./assets/js/151.1c6f270e.js"><link rel="prefetch" href="./assets/js/152.14fbeaa5.js"><link rel="prefetch" href="./assets/js/153.2452da0e.js"><link rel="prefetch" href="./assets/js/154.b4df1979.js"><link rel="prefetch" href="./assets/js/155.22d7abd8.js"><link rel="prefetch" href="./assets/js/156.2f9a9ccc.js"><link rel="prefetch" href="./assets/js/157.969faec2.js"><link rel="prefetch" href="./assets/js/158.3500ec52.js"><link rel="prefetch" href="./assets/js/159.e527d9a4.js"><link rel="prefetch" href="./assets/js/16.c4323435.js"><link rel="prefetch" href="./assets/js/160.e9019d68.js"><link rel="prefetch" href="./assets/js/161.85c34333.js"><link rel="prefetch" href="./assets/js/162.a46ae7b7.js"><link rel="prefetch" href="./assets/js/163.7be9bd8c.js"><link rel="prefetch" href="./assets/js/164.0c6811d8.js"><link rel="prefetch" href="./assets/js/165.57bd5bac.js"><link rel="prefetch" href="./assets/js/166.afa88f4a.js"><link rel="prefetch" href="./assets/js/167.29d4d5ce.js"><link rel="prefetch" href="./assets/js/168.e653cd83.js"><link rel="prefetch" href="./assets/js/169.e6f17762.js"><link rel="prefetch" href="./assets/js/17.505c5524.js"><link rel="prefetch" href="./assets/js/170.ef23a402.js"><link rel="prefetch" href="./assets/js/171.cad09bfd.js"><link rel="prefetch" href="./assets/js/172.70b28875.js"><link rel="prefetch" href="./assets/js/173.bd26a56b.js"><link rel="prefetch" href="./assets/js/174.eb342099.js"><link rel="prefetch" href="./assets/js/175.e65fe97d.js"><link rel="prefetch" href="./assets/js/176.991a568d.js"><link rel="prefetch" href="./assets/js/177.14728a0e.js"><link rel="prefetch" href="./assets/js/178.dd08b87f.js"><link rel="prefetch" href="./assets/js/179.35f52dd6.js"><link rel="prefetch" href="./assets/js/18.a3c1984e.js"><link rel="prefetch" href="./assets/js/180.fce6e839.js"><link rel="prefetch" href="./assets/js/181.344642d1.js"><link rel="prefetch" href="./assets/js/182.cb6d50af.js"><link rel="prefetch" href="./assets/js/183.18ccb5d5.js"><link rel="prefetch" href="./assets/js/184.7a48514f.js"><link rel="prefetch" href="./assets/js/19.e0fa9e47.js"><link rel="prefetch" href="./assets/js/20.da04fed8.js"><link rel="prefetch" href="./assets/js/21.039b78b5.js"><link rel="prefetch" href="./assets/js/22.91b1dd94.js"><link rel="prefetch" href="./assets/js/23.f70b01e1.js"><link rel="prefetch" href="./assets/js/24.bf935b15.js"><link rel="prefetch" href="./assets/js/25.740be3c8.js"><link rel="prefetch" href="./assets/js/26.f310e9df.js"><link rel="prefetch" href="./assets/js/27.0650d6da.js"><link rel="prefetch" href="./assets/js/28.30bd72ee.js"><link rel="prefetch" href="./assets/js/29.765dccf5.js"><link rel="prefetch" href="./assets/js/3.aa27e9f3.js"><link rel="prefetch" href="./assets/js/30.0484ae09.js"><link rel="prefetch" href="./assets/js/31.e09e1f25.js"><link rel="prefetch" href="./assets/js/32.9048892a.js"><link rel="prefetch" href="./assets/js/33.47a85736.js"><link rel="prefetch" href="./assets/js/34.162be571.js"><link rel="prefetch" href="./assets/js/35.27a56cfa.js"><link rel="prefetch" href="./assets/js/36.e2b24ea4.js"><link rel="prefetch" href="./assets/js/37.660e2ae2.js"><link rel="prefetch" href="./assets/js/38.e115bc82.js"><link rel="prefetch" href="./assets/js/39.786d0e1f.js"><link rel="prefetch" href="./assets/js/4.dac57b37.js"><link rel="prefetch" href="./assets/js/40.1034d892.js"><link rel="prefetch" href="./assets/js/41.2952b19a.js"><link rel="prefetch" href="./assets/js/42.75753f7b.js"><link rel="prefetch" href="./assets/js/43.af07ba27.js"><link rel="prefetch" href="./assets/js/44.c64a1c19.js"><link rel="prefetch" href="./assets/js/45.a3f07fbe.js"><link rel="prefetch" href="./assets/js/46.cde01b57.js"><link rel="prefetch" href="./assets/js/47.ca2de71c.js"><link rel="prefetch" href="./assets/js/48.264c1471.js"><link rel="prefetch" href="./assets/js/49.733bd546.js"><link rel="prefetch" href="./assets/js/5.6ca2ea8d.js"><link rel="prefetch" href="./assets/js/50.7b9d16c8.js"><link rel="prefetch" href="./assets/js/51.f427baa6.js"><link rel="prefetch" href="./assets/js/52.112ba3d3.js"><link rel="prefetch" href="./assets/js/53.bc7a9bfd.js"><link rel="prefetch" href="./assets/js/54.258fa5ae.js"><link rel="prefetch" href="./assets/js/55.00d67ca6.js"><link rel="prefetch" href="./assets/js/56.ea8c85f2.js"><link rel="prefetch" href="./assets/js/57.8263a106.js"><link rel="prefetch" href="./assets/js/58.e0b33df6.js"><link rel="prefetch" href="./assets/js/6.a67b19a4.js"><link rel="prefetch" href="./assets/js/60.d3638a19.js"><link rel="prefetch" href="./assets/js/61.33bd82a8.js"><link rel="prefetch" href="./assets/js/62.6287fa56.js"><link rel="prefetch" href="./assets/js/63.f043aec3.js"><link rel="prefetch" href="./assets/js/64.fd61b3bb.js"><link rel="prefetch" href="./assets/js/65.088db422.js"><link rel="prefetch" href="./assets/js/66.fa850071.js"><link rel="prefetch" href="./assets/js/67.6f9263db.js"><link rel="prefetch" href="./assets/js/68.a40fea6a.js"><link rel="prefetch" href="./assets/js/69.82a38b9c.js"><link rel="prefetch" href="./assets/js/7.130b2290.js"><link rel="prefetch" href="./assets/js/70.78387c60.js"><link rel="prefetch" href="./assets/js/71.c8bafdac.js"><link rel="prefetch" href="./assets/js/72.f6af738e.js"><link rel="prefetch" href="./assets/js/73.483631aa.js"><link rel="prefetch" href="./assets/js/74.7a295ce2.js"><link rel="prefetch" href="./assets/js/75.4ee52419.js"><link rel="prefetch" href="./assets/js/76.bfa2477e.js"><link rel="prefetch" href="./assets/js/77.36dbbf31.js"><link rel="prefetch" href="./assets/js/78.99a9055a.js"><link rel="prefetch" href="./assets/js/79.cf91068c.js"><link rel="prefetch" href="./assets/js/8.e81bc496.js"><link rel="prefetch" href="./assets/js/80.5091cf53.js"><link rel="prefetch" href="./assets/js/81.1ab1ac83.js"><link rel="prefetch" href="./assets/js/82.075a98b9.js"><link rel="prefetch" href="./assets/js/83.f6479725.js"><link rel="prefetch" href="./assets/js/84.36b72a58.js"><link rel="prefetch" href="./assets/js/85.5a115a90.js"><link rel="prefetch" href="./assets/js/86.e2e2bc5e.js"><link rel="prefetch" href="./assets/js/87.7498c4d7.js"><link rel="prefetch" href="./assets/js/88.424c69e2.js"><link rel="prefetch" href="./assets/js/89.5997766e.js"><link rel="prefetch" href="./assets/js/9.7d490254.js"><link rel="prefetch" href="./assets/js/90.ba4d2a78.js"><link rel="prefetch" href="./assets/js/91.920a9ee1.js"><link rel="prefetch" href="./assets/js/92.7903dbd3.js"><link rel="prefetch" href="./assets/js/93.e120bbac.js"><link rel="prefetch" href="./assets/js/94.cddc34d7.js"><link rel="prefetch" href="./assets/js/95.0a7a80fe.js"><link rel="prefetch" href="./assets/js/96.26590fe7.js"><link rel="prefetch" href="./assets/js/97.91bdc308.js"><link rel="prefetch" href="./assets/js/98.9a1146d2.js"><link rel="prefetch" href="./assets/js/99.d5e87370.js">
    <link rel="stylesheet" href="./assets/css/0.styles.2c6e287f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">大数据技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link router-link-active">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/sqoop/Sqoop入门.html" class="nav-link">
  Sqoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/presto/Presto入门.html" class="nav-link">
  Presto
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kylin/" class="nav-link">
  Kylin
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/Druid/Druid入门.html" class="nav-link">
  Druid
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/elasticsearch/ElasticSearch入门.html" class="nav-link">
  ElasticSearch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link router-link-active">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/sqoop/Sqoop入门.html" class="nav-link">
  Sqoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/presto/Presto入门.html" class="nav-link">
  Presto
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kylin/" class="nav-link">
  Kylin
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/Druid/Druid入门.html" class="nav-link">
  Druid
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/elasticsearch/ElasticSearch入门.html" class="nav-link">
  ElasticSearch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Spark</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./bigdata/spark/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html" class="active sidebar-link">Spark SQL Catalyst优化器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_1-catalyst介绍" class="sidebar-link">1. Catalyst介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#规则" class="sidebar-link">规则</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#例子" class="sidebar-link">例子</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_2-treenode" class="sidebar-link">2. TreeNode</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#transform" class="sidebar-link">transform</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#transformdown-transformup" class="sidebar-link">transformDown &amp; transformUp</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#transformchildrendown-transformchildrenup" class="sidebar-link">transformChildrenDown &amp; transformChildrenUp</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#makecopy" class="sidebar-link">makeCopy</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#其他函数" class="sidebar-link">其他函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_3-rule" class="sidebar-link">3. Rule</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#strategy" class="sidebar-link">Strategy</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#once" class="sidebar-link">Once</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#fixedpoint" class="sidebar-link">FixedPoint</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#batch" class="sidebar-link">Batch</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#ruleexecutor" class="sidebar-link">RuleExecutor</a></li></ul></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_4-analyser" class="sidebar-link">4. Analyser</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#catalog" class="sidebar-link">Catalog</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#functionregistry" class="sidebar-link">FunctionRegistry</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#analyzer" class="sidebar-link">Analyzer</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#rules介绍" class="sidebar-link">Rules介绍</a></li></ul></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_5-optimizer" class="sidebar-link">5. Optimizer</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#rules介绍-2" class="sidebar-link">Rules介绍</a></li></ul></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_6-总结" class="sidebar-link">6. 总结</a></li><li class="sidebar-sub-header"><a href="/./bigdata/spark/Spark SQL Catalyst优化器.html#_99-spark-sql的性能" class="sidebar-link">99. Spark SQL的性能</a></li></ul></li><li><a href="/./bigdata/spark/SparkSQL开窗函数.html" class="sidebar-link">SparkSQL开窗函数</a></li><li><a href="/./bigdata/spark/SparkSQL组件解析.html" class="sidebar-link">SparkSQL组件解析</a></li><li><a href="/./bigdata/spark/SparkSQL调优.html" class="sidebar-link">SparkSQL调优</a></li><li><a href="/./bigdata/spark/Spark运行过程.html" class="sidebar-link">Spark运行过程</a></li><li><a href="/./bigdata/spark/Spark面试题.html" class="sidebar-link">Spark面试题</a></li><li><a href="/./bigdata/spark/思维导图：Spark生态圈.html" class="sidebar-link">Spark生态圈</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="spark-sql-catalyst优化器"><a href="#spark-sql-catalyst优化器" class="header-anchor">#</a> Spark SQL Catalyst优化器</h1> <h2 id="_1-catalyst介绍"><a href="#_1-catalyst介绍" class="header-anchor">#</a> 1. Catalyst介绍</h2> <p>Catalyst是一款基于规则的优化器，Analyzer和Optimizer定义了一系列优化规则，Catalyst根据这些规则对执Logical Plan进行优化。</p> <p>对于下面这个sql查询</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> name <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> id<span class="token punctuation">,</span> name <span class="token keyword">from</span> people
<span class="token punctuation">)</span> p
<span class="token keyword">where</span> p<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><p>最简单就是不做优化，直接一对一将Logical Plan映射为Physical Plan。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/naive-planning.png" alt="img"></p> <p>而最直接的方法就是就按照下图的方式进行优化，这种方法的难点在于：很难写一个通用的框架支持不同情况的优化方法。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/hand-write-planning.png" alt="img"></p> <p>Catalyst的做法是，<strong>每一条优化规则只做最简单的修改，不同的规则互相协作，依次循环地对Logical Plan进行优化，最后形成一个稳定的Optimized Logical Plan</strong>。如下图所示，对于最原始的的Logical Plan</p> <ol><li>先使用Filter Push Down规则，将Filter和Project进行交换</li> <li>然后使用Combine Projection规则，将两个Project合并</li> <li>最后生成物理计划</li></ol> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/catalyst-planning.png" alt="img"></p> <h3 id="规则"><a href="#规则" class="header-anchor">#</a> 规则</h3> <p>一个规则一般包括三个部分：</p> <ol><li>匹配</li> <li>过滤</li> <li>修改</li></ol> <p>让我们以Filter Push Down规则为例，看看Catalyst是如果执行规则的。 <img src="http://marsishandsome.github.io/SparkSQL-Internal/images/planning-in-detail.png" alt="img"></p> <ol><li>首先在Logical Plan上寻找Filter Push Down的匹配条件，即Filter下面是Project</li> <li>然后判断过滤条件，即Filter是否可以不需要通过Project就可以计算</li> <li>最后做修改，即交换Filter和Project</li></ol> <p>利用Scala的<code>Case Class</code> 和 <code>match</code>语法来实现Catalyst的优化规则是非常简单的，例如Filter Push Down规则可以用下面几句代码实现：</p> <div class="language-java extra-class"><pre class="language-java"><code>val newPlan <span class="token operator">=</span> queryPlan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> f @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> p @ <span class="token class-name">Project</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>references subsetOf grandChild<span class="token punctuation">.</span>output<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
    p<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>child <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>child <span class="token operator">=</span> grandChild<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li><code>queryPlan</code> 是原始的未经优化的Logical Plan，是一个Tree</li> <li><code>case f @ Filter(_, p @ Project(_, grandChild))</code> 用来寻找Filter下面是Project的模式</li> <li><code>if(f.references subsetOf grandChild.output)</code> 用来判断Filter是否可以不需要通过Project就可以计算</li> <li><code>p.copy(child = f.copy(child = grandChild)</code> 用来交换Filter和Project</li></ol> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <p>让我们以下面这个sql查询为例子，看看SparkSQL是怎么从Logical Plan进行优化，最后生成Physical Plan的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">println</span><span class="token punctuation">(</span>
      <span class="token function">sql</span><span class="token punctuation">(</span> s<span class="token triple-quoted-string string">&quot;&quot;&quot;
            |SELECT name
            |FROM (SELECT name, age FROM rddTable) p
            |WHERE p.age &gt;= 13 AND p.age &lt;= 19
            |&quot;&quot;&quot;</span><span class="token punctuation">.</span>stripMargin<span class="token punctuation">)</span><span class="token punctuation">.</span>queryExecution
    <span class="token punctuation">)</span>
</code></pre></div><h4 id="parsed-logical-plan"><a href="#parsed-logical-plan" class="header-anchor">#</a> Parsed Logical Plan</h4> <p>首先SqlParser会对输入的sql语句进行parser，生成Parsed Logical Plan。该Parsed Logcial Plan没有经过任何优化，是sql语句的直接翻译。</p> <div class="language- extra-class"><pre class="language-text"><code>== Parsed Logical Plan ==
'Project ['name]
 'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))
  'Subquery p
   'Project ['name,'age]
    'UnresolvedRelation None, rddTable, None
</code></pre></div><p>我们依次从下往上看</p> <ol><li>UnresolvedRelation表示一个表格，目前只有表名rddTable，对应于sql中的 <code>FROM rddTable</code></li> <li>Project表示投影，对应于sql中的 <code>SELECT name, age</code></li> <li>Subquery是子查询，对应于sql中的 <code>(SELECT name, age FROM rddTable) p</code></li> <li>Filter是过滤条件，对应于sql中的 <code>WHERE p.age &gt;= 13 AND p.age &lt;= 19</code></li> <li>Project表示投影，对应于sql中的 <code>SELECT name</code></li></ol> <p>值得注意的是，Project、Filter、Subquery和UnresolvedRelation上面的单引号表示该Logical Plan是Unresolved。</p> <h4 id="analyzed-logical-plan"><a href="#analyzed-logical-plan" class="header-anchor">#</a> Analyzed Logical Plan</h4> <p>接下来的任务正式交接给Catalyst，首先Catalyst会根据内部定义的规则，将Parsed Logical Plan变成Analyzed Logical Plan。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">==</span> <span class="token class-name">Analyzed</span> <span class="token class-name">Logical</span> <span class="token class-name">Plan</span> <span class="token operator">==</span>
<span class="token class-name">Project</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">]</span>
 <span class="token class-name">Filter</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token class-name">Project</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">,</span>age#<span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token class-name">LogicalRDD</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">,</span>age#<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">MapPartitionsRDD</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> at mapPartitions at <span class="token class-name">ExistingRDD</span><span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">36</span>
</code></pre></div><p>其中</p> <ol><li>UnresolvedRelation被映射成了具体的LogicalRDD，而table name到Logical Plan的映射被保持在Catalog</li> <li>UnresolvedAttribute被映射成AttributeReference</li></ol> <h4 id="optimized-logical-plan"><a href="#optimized-logical-plan" class="header-anchor">#</a> Optimized Logical Plan</h4> <p>然后Catalyst会继续对Analyzed Logical Plan进行优化，生成Optimized Logical Plan。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">==</span> <span class="token class-name">Optimized</span> <span class="token class-name">Logical</span> <span class="token class-name">Plan</span> <span class="token operator">==</span>
<span class="token class-name">Project</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">]</span>
 <span class="token class-name">Filter</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token class-name">LogicalRDD</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">,</span>age#<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">MapPartitionsRDD</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> at mapPartitions at <span class="token class-name">ExistingRDD</span><span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">36</span>
</code></pre></div><p>其中进行了两次规则应用：</p> <ol><li>Filter Push Down将Filter和Project进行交换</li> <li>Combine Projection将两个Project合并</li></ol> <h4 id="physical-plan"><a href="#physical-plan" class="header-anchor">#</a> Physical Plan</h4> <p>最后把Optimized Logical一对一的映射为Physical Plan。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token operator">==</span> <span class="token class-name">Physical</span> <span class="token class-name">Plan</span> <span class="token operator">==</span>
<span class="token class-name">Project</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">]</span>
 <span class="token class-name">Filter</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&gt;=</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>age#<span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token class-name">PhysicalRDD</span> <span class="token punctuation">[</span>name#<span class="token number">0</span><span class="token punctuation">,</span>age#<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">MapPartitionsRDD</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> at mapPartitions at <span class="token class-name">ExistingRDD</span><span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">36</span>
</code></pre></div><h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>Catalyst的输入是Unresolved Logical Plan，在优化的过程当中，Catalyst会根据Analyzer和Optimizer中定义的规则，检测输入的执行计划中有没有符合规则条件的子树，如果有的话就会触发某个特定的优化规则，这些规则将依次循环地运行，直到达到最大迭代次数或者达到稳定的输出。</p> <p>在传统关系型数据库当中，一个简单的sql语句将会依次经过Parser生成Logical Pla，Optimizer生成Optimized Logical Plan，最后生成Physical Plan，交给执行器去执行。SparkSQL也采用了类似的方式进行处理，下面介绍一下SparkSQL的优化器：<strong>Catalyst</strong>。</p> <p>先来看一下Catalyst在整个sql执行流程中所处的位置：</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/catalyst.png" alt="img"></p> <p>图中虚线部分是以后版本要实现的功能，实线部分是已经实现的功能。从上图看，整个SQL的执行框架主要的实现组件有：</p> <ol><li>SqlParse：sql语句的语法解析功能</li> <li>Analyzer：将Unresolved Logical Plan和Schema Catalog进行绑定，生成Resolved Logical Plan</li> <li>Optimizer：对Resolved Logical Plan进行优化，生成Optimized Logical Plan</li> <li>Planner：将Logical Plan转换成Physical Plan</li> <li>CostModel：根据过去的性能统计数据，选择最佳的物理执行计划</li></ol> <p>Catalyst在整个流程中处于中段位置，它主要有两个任务</p> <ol><li>将Unresolved Logical Plan和Schema Catalog进行绑定，生成Resolved Logical Plan</li> <li>对Resolved Logical Plan进行优化，生成Optimized Logical Plan</li></ol> <p>这两个任务正好说明了Catalyst名字的由来，即Catalog + Analyst。</p> <h2 id="_2-treenode"><a href="#_2-treenode" class="header-anchor">#</a> 2. TreeNode</h2> <p>Catalyst中规则的匹配和Logical Plan的转换操作，其实都是基于树的操作，LogicalPlan继承自QueryPlan，而QueryPlan继承自TreeNode。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LogicalPlan</span> <span class="token keyword">extends</span> <span class="token class-name">QueryPlan</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token class-name">Logging</span>

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">QueryPlan</span><span class="token punctuation">[</span><span class="token class-name">PlanType</span> <span class="token operator">&lt;</span><span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span><span class="token class-name">PlanType</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span><span class="token class-name">PlanType</span><span class="token punctuation">]</span>

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span> <span class="token operator">&lt;</span><span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p>TreeNode Library是Catalyst的核心类库，语法树的构建都是由一个个TreeNode组成。在Catalyst里，这些Node都是继承自Logical Plan，可以说每一个TreeNode节点就是一个Logical Plan。主要继承关系类图如下：</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/tree-node.png" alt="img"></p> <p>下面介绍一下TreeNode上的一些主要操作。</p> <h3 id="transform"><a href="#transform" class="header-anchor">#</a> transform</h3> <p>该方法接受一个PartialFunction，例如Analyzer的Batch里面的Rule。将Rule迭代应用到该节点的所有子节点，最后返回这个节点的副本。如果rule没有对一个节点进行PartialFunction的操作，就返回这个节点本身。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Returns a copy of this node where `rule` has been recursively applied to the tree.
   * When `rule` does not apply to a given node it is left unchanged.
   * Users should not expect a specific directionality. If a specific directionality is needed,
   * transformDown or transformUp should be used.
   * @param rule the function use to transform this nodes children
   */</span>
  def <span class="token function">transform</span><span class="token punctuation">(</span>rule<span class="token operator">:</span> <span class="token class-name">PartialFunction</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">,</span> <span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">BaseType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">transformDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="transformdown-transformup"><a href="#transformdown-transformup" class="header-anchor">#</a> transformDown &amp; transformUp</h3> <p>transform方法真正的调用是transformDown，这里用到了用先序遍历来对子节点进行递归的Rule应用。如果在对当前节点应用rule成功，修改后的节点afterRule，来对其children节点进行rule的应用。</p> <p>transfromUp用的是后序遍历。</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">/**
   * Returns a copy of this node where `rule` has been recursively applied to it and all of its
   * children (pre-order). When `rule` does not apply to a given node it is left unchanged.
   * @param rule the function used to transform this nodes children
   */</span>
  def <span class="token function">transformDown</span><span class="token punctuation">(</span>rule<span class="token operator">:</span> <span class="token class-name">PartialFunction</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">,</span> <span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">BaseType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val afterRule <span class="token operator">=</span> rule<span class="token punctuation">.</span><span class="token function">applyOrElse</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> identity<span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// Check if unchanged and then possibly return old copy to avoid gc churn.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> fastEquals afterRule<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">transformChildrenDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      afterRule<span class="token punctuation">.</span><span class="token function">transformChildrenDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="transformchildrendown-transformchildrenup"><a href="#transformchildrendown-transformchildrenup" class="header-anchor">#</a> transformChildrenDown &amp; transformChildrenUp</h3> <p>transformChildrenDown是最重要的方法，对children节点进行递归的调用PartialFunction，利用最终返回的newArgs来生成一个新的节点，这里调用了makeCopy()来生成节点。</p> <p>transformChildrenUp类似，只是最后调用transformUp。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token comment">/**
   * Returns a copy of this node where `rule` has been recursively applied to all the children of
   * this node.  When `rule` does not apply to a given node it is left unchanged.
   * @param rule the function used to transform this nodes children
   */</span>
  def <span class="token function">transformChildrenDown</span><span class="token punctuation">(</span>rule<span class="token operator">:</span> <span class="token class-name">PartialFunction</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">,</span> <span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> changed <span class="token operator">=</span> <span class="token boolean">false</span>
    val newArgs <span class="token operator">=</span> productIterator<span class="token punctuation">.</span>map <span class="token punctuation">{</span>
      <span class="token keyword">case</span> arg<span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token keyword">if</span> children contains arg <span class="token operator">=</span><span class="token operator">&gt;</span>
        val newChild <span class="token operator">=</span> arg<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">transformDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>newChild fastEquals arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          changed <span class="token operator">=</span> <span class="token boolean">true</span>
          newChild
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          arg
        <span class="token punctuation">}</span>
      <span class="token keyword">case</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> children contains arg <span class="token operator">=</span><span class="token operator">&gt;</span>
        val newChild <span class="token operator">=</span> arg<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">transformDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>newChild fastEquals arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          changed <span class="token operator">=</span> <span class="token boolean">true</span>
          <span class="token class-name">Some</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token class-name">Some</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token keyword">case</span> m<span class="token operator">:</span> <span class="token class-name">Map</span><span class="token punctuation">[</span>_<span class="token punctuation">,</span>_<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> m
      <span class="token keyword">case</span> args<span class="token operator">:</span> <span class="token class-name">Traversable</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> args<span class="token punctuation">.</span>map <span class="token punctuation">{</span>
        <span class="token keyword">case</span> arg<span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token keyword">if</span> children contains arg <span class="token operator">=</span><span class="token operator">&gt;</span>
          val newChild <span class="token operator">=</span> arg<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">transformDown</span><span class="token punctuation">(</span>rule<span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>newChild fastEquals arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            changed <span class="token operator">=</span> <span class="token boolean">true</span>
            newChild
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            arg
          <span class="token punctuation">}</span>
        <span class="token keyword">case</span> other <span class="token operator">=</span><span class="token operator">&gt;</span> other
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> nonChild<span class="token operator">:</span> <span class="token class-name">AnyRef</span> <span class="token operator">=</span><span class="token operator">&gt;</span> nonChild
      <span class="token keyword">case</span> <span class="token keyword">null</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span>toArray
    <span class="token keyword">if</span> <span class="token punctuation">(</span>changed<span class="token punctuation">)</span> <span class="token function">makeCopy</span><span class="token punctuation">(</span>newArgs<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="makecopy"><a href="#makecopy" class="header-anchor">#</a> makeCopy</h3> <p>通过反射生成节点副本。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Creates a copy of this type of tree node after a transformation.
   * Must be overridden by child classes that have constructor arguments
   * that are not present in the productIterator.
   * @param newArgs the new product arguments.
   */</span>
  def <span class="token function">makeCopy</span><span class="token punctuation">(</span>newArgs<span class="token operator">:</span> <span class="token class-name">Array</span><span class="token punctuation">[</span><span class="token class-name">AnyRef</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token function">attachTree</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;makeCopy&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// Skip no-arg constructors that are just there for kryo.</span>
      val defaultCtor <span class="token operator">=</span> getClass<span class="token punctuation">.</span>getConstructors<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>getParameterTypes<span class="token punctuation">.</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>head
      <span class="token keyword">if</span> <span class="token punctuation">(</span>otherCopyArgs<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        defaultCtor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>newArgs<span class="token operator">:</span> _<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        defaultCtor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">(</span>newArgs <span class="token operator">++</span> otherCopyArgs<span class="token punctuation">)</span><span class="token punctuation">.</span>toArray<span class="token operator">:</span> _<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>IllegalArgumentException</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeException</span><span class="token punctuation">(</span>
          <span class="token keyword">this</span><span class="token punctuation">,</span> s<span class="token string">&quot;Failed to copy node.  Is otherCopyArgs specified correctly for $nodeName? &quot;</span>
            <span class="token operator">+</span> s<span class="token string">&quot;Exception message: ${e.getMessage}.&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="其他函数"><a href="#其他函数" class="header-anchor">#</a> 其他函数</h3> <p>除此以外，TreeNode还支持一些集合操作函数</p> <p><strong>map</strong> 将函数作用到每一个结点，返回转换后的树</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Returns a Seq containing the result of applying the given function to each
   * node in this tree in a preorder traversal.
   * @param f the function to be applied.
   */</span>
  def map<span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token operator">:</span> <span class="token class-name">BaseType</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">A</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span></span>ArrayBuffer</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">foreach</span><span class="token punctuation">(</span>ret <span class="token operator">+=</span> <span class="token function">f</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span>
    ret
  <span class="token punctuation">}</span>
</code></pre></div><p><strong>flatMap</strong> 将函数作用到每个结点，返回一个Seq</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Returns a Seq by applying a function to all nodes in this tree and using the elements of the
   * resulting collections.
   */</span>
  def flatMap<span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token operator">:</span> <span class="token class-name">BaseType</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">TraversableOnce</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span></span>ArrayBuffer</span><span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">foreach</span><span class="token punctuation">(</span>ret <span class="token operator">++</span><span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span>
    ret
  <span class="token punctuation">}</span>
</code></pre></div><p><strong>collect</strong> 将函数作用到每个结点，去除没有该函数定义的结点，返回剩下的结果Seq</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Returns a Seq containing the result of applying a partial function to all elements in this
   * tree on which the function is defined.
   */</span>
  def collect<span class="token punctuation">[</span><span class="token class-name">B</span><span class="token punctuation">]</span><span class="token punctuation">(</span>pf<span class="token operator">:</span> <span class="token class-name">PartialFunction</span><span class="token punctuation">[</span><span class="token class-name">BaseType</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">B</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">collection<span class="token punctuation">.</span>mutable<span class="token punctuation">.</span></span>ArrayBuffer</span><span class="token punctuation">[</span><span class="token class-name">B</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    val lifted <span class="token operator">=</span> pf<span class="token punctuation">.</span>lift
    <span class="token function">foreach</span><span class="token punctuation">(</span>node <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">lifted</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span>+<span class="token operator">=</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    ret
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-rule"><a href="#_3-rule" class="header-anchor">#</a> 3. Rule</h2> <p>Rule类是抽象类，理解为一种规则，这种规则会应用到Logical Plan 从而将UnResolved 转变为Resolved。调用apply方法可以进行Tree的transformation。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">TreeType</span> <span class="token operator">&lt;</span><span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Logging</span> <span class="token punctuation">{</span>

  <span class="token comment">/** Name for this rule, automatically inferred based on class name. */</span>
  val ruleName<span class="token operator">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val className <span class="token operator">=</span> getClass<span class="token punctuation">.</span>getName
    <span class="token keyword">if</span> <span class="token punctuation">(</span>className endsWith <span class="token string">&quot;$&quot;</span><span class="token punctuation">)</span> className<span class="token punctuation">.</span><span class="token function">dropRight</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">else</span> className
  <span class="token punctuation">}</span>

  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">TreeType</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">TreeType</span>
<span class="token punctuation">}</span>
</code></pre></div><p>SparkSQL中为Catalyst定义了各种各样的Rule，如下图（不全），随着SparkSQL的不断优化，里面的Rule会越来越多。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/rules.png" alt="img"></p> <h3 id="strategy"><a href="#strategy" class="header-anchor">#</a> Strategy</h3> <p>最大的执行次数，如果执行次数在最大迭代次数之前就达到了fix point，策略就会停止，不再应用了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * An execution strategy for rules that indicates the maximum number of executions. If the
   * execution reaches fix point (i.e. converge) before maxIterations, it will stop.
   */</span>
  <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span> def maxIterations<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token punctuation">}</span>
</code></pre></div><h3 id="once"><a href="#once" class="header-anchor">#</a> Once</h3> <p>执行且仅执行一次</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">/** A strategy that only runs once. */</span>
  <span class="token keyword">case</span> object <span class="token class-name">Once</span> <span class="token keyword">extends</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span> val maxIterations <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre></div><h3 id="fixedpoint"><a href="#fixedpoint" class="header-anchor">#</a> FixedPoint</h3> <p>相当于迭代次数的上限。</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">/** A strategy that runs until fix point or maxIterations times, whichever comes first. */</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span>maxIterations<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token class-name">Strategy</span>
</code></pre></div><h3 id="batch"><a href="#batch" class="header-anchor">#</a> Batch</h3> <p>批次，这个对象是由一系列Rule组成的，采用一个策略，目前有两种策略Once和FixedPoint</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** A batch of rules. */</span>
  <span class="token keyword">protected</span> <span class="token keyword">case</span> <span class="token keyword">class</span> <span class="token class-name">Batch</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> strategy<span class="token operator">:</span> <span class="token class-name">Strategy</span><span class="token punctuation">,</span> rules<span class="token operator">:</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">TreeType</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="ruleexecutor"><a href="#ruleexecutor" class="header-anchor">#</a> RuleExecutor</h3> <p>Rule具体的实现在RuleExecutor中。</p> <p>通过定义batchs，可以模块化地对Tree进行transform操作。Once和FixedPoint分别可以对Tree进行一次操作或多次操作，例如对某些Tree进行多次迭代操作的时候，达到FixedPoint次数迭代或达到前后两次的树结构没变化才停止操作。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RuleExecutor</span><span class="token punctuation">[</span><span class="token class-name">TreeType</span> <span class="token operator">&lt;</span><span class="token operator">:</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span>_<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Logging</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * An execution strategy for rules that indicates the maximum number of executions. If the
   * execution reaches fix point (i.e. converge) before maxIterations, it will stop.
   */</span>
  <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span> def maxIterations<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token punctuation">}</span>

  <span class="token comment">/** A strategy that only runs once. */</span>
  <span class="token keyword">case</span> object <span class="token class-name">Once</span> <span class="token keyword">extends</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span> val maxIterations <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span>

  <span class="token comment">/** A strategy that runs until fix point or maxIterations times, whichever comes first. */</span>
  <span class="token keyword">case</span> <span class="token keyword">class</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span>maxIterations<span class="token operator">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token class-name">Strategy</span>

  <span class="token comment">/** A batch of rules. */</span>
  <span class="token keyword">protected</span> <span class="token keyword">case</span> <span class="token keyword">class</span> <span class="token class-name">Batch</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> strategy<span class="token operator">:</span> <span class="token class-name">Strategy</span><span class="token punctuation">,</span> rules<span class="token operator">:</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">TreeType</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">)</span>

  <span class="token comment">/** Defines a sequence of rule batches, to be overridden by the implementation. */</span>
  <span class="token keyword">protected</span> val batches<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Batch</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>触发RuleExecutor启动的是apply函数：</p> <ol><li>首先遍历batches数组</li> <li>依次运行单个batch里面的所有规则</li> <li>直到达到Strtegy里面定义的次数，或者优化前后Logical Plan不再变化</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Executes the batches of rules defined by the subclass. The batches are executed serially
   * using the defined execution strategy. Within each batch, rules are also executed serially.
   */</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">TreeType</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">TreeType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> curPlan <span class="token operator">=</span> plan

    batches<span class="token punctuation">.</span>foreach <span class="token punctuation">{</span> batch <span class="token operator">=</span><span class="token operator">&gt;</span>
      val batchStartPlan <span class="token operator">=</span> curPlan
      <span class="token keyword">var</span> iteration <span class="token operator">=</span> <span class="token number">1</span>
      <span class="token keyword">var</span> lastPlan <span class="token operator">=</span> curPlan
      <span class="token keyword">var</span> <span class="token keyword">continue</span> <span class="token operator">=</span> <span class="token boolean">true</span>

      <span class="token comment">// Run until fix point (or the max number of iterations as specified in the strategy.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">continue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        curPlan <span class="token operator">=</span> batch<span class="token punctuation">.</span>rules<span class="token punctuation">.</span><span class="token function">foldLeft</span><span class="token punctuation">(</span>curPlan<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span>plan<span class="token punctuation">,</span> rule<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
            val result <span class="token operator">=</span> <span class="token function">rule</span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">fastEquals</span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">logTrace</span><span class="token punctuation">(</span>
                s<span class="token triple-quoted-string string">&quot;&quot;&quot;
                  |=== Applying Rule ${rule.ruleName} ===
                  |${sideBySide(plan.treeString, result.treeString).mkString(&quot;\n&quot;)}
                &quot;&quot;&quot;</span><span class="token punctuation">.</span>stripMargin<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            result
        <span class="token punctuation">}</span>
        iteration <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iteration <span class="token operator">&gt;</span> batch<span class="token punctuation">.</span>strategy<span class="token punctuation">.</span>maxIterations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Only log if this is a rule that is supposed to run more than once.</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>iteration <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">logInfo</span><span class="token punctuation">(</span>s<span class="token string">&quot;Max iterations (${iteration - 1}) reached for batch ${batch.name}&quot;</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">continue</span> <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>curPlan<span class="token punctuation">.</span><span class="token function">fastEquals</span><span class="token punctuation">(</span>lastPlan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">logTrace</span><span class="token punctuation">(</span>
            s<span class="token string">&quot;Fixed point reached for batch ${batch.name} after ${iteration - 1} iterations.&quot;</span><span class="token punctuation">)</span>
          <span class="token keyword">continue</span> <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        lastPlan <span class="token operator">=</span> curPlan
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchStartPlan<span class="token punctuation">.</span><span class="token function">fastEquals</span><span class="token punctuation">(</span>curPlan<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">logDebug</span><span class="token punctuation">(</span>
          s<span class="token triple-quoted-string string">&quot;&quot;&quot;
          |=== Result of Batch ${batch.name} ===
          |${sideBySide(plan.treeString, curPlan.treeString).mkString(&quot;\n&quot;)}
        &quot;&quot;&quot;</span><span class="token punctuation">.</span>stripMargin<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">logTrace</span><span class="token punctuation">(</span>s<span class="token string">&quot;Batch ${batch.name} has no effect.&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    curPlan
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="_4-analyser"><a href="#_4-analyser" class="header-anchor">#</a> 4. Analyser</h2> <p>Analyzer的主要职责是将Sql Parser生成的Unresolved Logical Plan转化成Resolved Logical Plan。Analyzer会利用Catalog和FunctionRegistry里面注册的表格和用户定义的函数，将UnresolvedAttribute和UnresolvedRelation转换为Catalyst里全类型的对象。</p> <p>在介绍Analyzer之前先介绍一下Catalog和FunctionRegistry这两个模块。</p> <h3 id="catalog"><a href="#catalog" class="header-anchor">#</a> Catalog</h3> <p>Catalog里面记录了Table Name到Logical Plan的映射，提供了注册表格，查找表格等接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * An interface for looking up relations by name.  Used by an [[Analyzer]].
 */</span>
trait <span class="token class-name">Catalog</span> <span class="token punctuation">{</span>

  def caseSensitive<span class="token operator">:</span> <span class="token class-name">Boolean</span>

  def <span class="token function">tableExists</span><span class="token punctuation">(</span>db<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span>

  def <span class="token function">lookupRelation</span><span class="token punctuation">(</span>
    databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    alias<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span>

  def <span class="token function">registerTable</span><span class="token punctuation">(</span>databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span>

  def <span class="token function">unregisterTable</span><span class="token punctuation">(</span>databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span>

  def <span class="token function">unregisterAllTables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Catalog具体的实现是SimpleCatalog，里面是用HashMap来记录Table Name到Logical Plan的映射。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimpleCatalog</span><span class="token punctuation">(</span>val caseSensitive<span class="token operator">:</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token class-name">Catalog</span> <span class="token punctuation">{</span>
  val tables <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">mutable<span class="token punctuation">.</span></span>HashMap</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  override def <span class="token function">registerTable</span><span class="token punctuation">(</span>
      databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
      plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val <span class="token punctuation">(</span>dbName<span class="token punctuation">,</span> tblName<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">processDatabaseAndTableName</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> tableName<span class="token punctuation">)</span>
    tables <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tblName<span class="token punctuation">,</span> plan<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  override def <span class="token function">unregisterTable</span><span class="token punctuation">(</span>
      databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val <span class="token punctuation">(</span>dbName<span class="token punctuation">,</span> tblName<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">processDatabaseAndTableName</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> tableName<span class="token punctuation">)</span>
    tables <span class="token operator">-=</span> tblName
  <span class="token punctuation">}</span>

  override def <span class="token function">unregisterAllTables</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    tables<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  override def <span class="token function">tableExists</span><span class="token punctuation">(</span>db<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val <span class="token punctuation">(</span>dbName<span class="token punctuation">,</span> tblName<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">processDatabaseAndTableName</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span> tableName<span class="token punctuation">)</span>
    tables<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tblName<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
      <span class="token keyword">case</span> <span class="token class-name">None</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  override def <span class="token function">lookupRelation</span><span class="token punctuation">(</span>
      databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
      alias<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val <span class="token punctuation">(</span>dbName<span class="token punctuation">,</span> tblName<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">processDatabaseAndTableName</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> tableName<span class="token punctuation">)</span>
    val table <span class="token operator">=</span> tables<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>tblName<span class="token punctuation">,</span> sys<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>s<span class="token string">&quot;Table Not Found: $tableName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    val tableWithQualifiers <span class="token operator">=</span> <span class="token class-name">Subquery</span><span class="token punctuation">(</span>tblName<span class="token punctuation">,</span> table<span class="token punctuation">)</span>

    <span class="token comment">// If an alias was specified by the lookup, wrap the plan in a subquery so that attributes are</span>
    <span class="token comment">// properly qualified with this alias.</span>
    alias<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>a <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Subquery</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> tableWithQualifiers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>tableWithQualifiers<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="functionregistry"><a href="#functionregistry" class="header-anchor">#</a> FunctionRegistry</h3> <p>FunctionRegistry记录了用户定义的函数名到该函数的表达式的映射，并提供注册函数，查找函数等接口。 FunctionBuilder被定义成为 <code>Seq[Expression] =&gt; Expression</code>，可以理解为输入多个Expression作为参数，输出一个Expression作为结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** A catalog for looking up user defined functions, used by an [[Analyzer]]. */</span>
trait <span class="token class-name">FunctionRegistry</span> <span class="token punctuation">{</span>
  type <span class="token class-name">FunctionBuilder</span> <span class="token operator">=</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Expression</span>

  def <span class="token function">registerFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> builder<span class="token operator">:</span> <span class="token class-name">FunctionBuilder</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Unit</span>

  def <span class="token function">lookupFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Expression</span>
<span class="token punctuation">}</span>
</code></pre></div><p>FunctionRegistry具体的实现是SimpleFunctionRegistry，里面用HashMap来记录用户定义的函数名到该函数的表达式的映射。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">SimpleFunctionRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">FunctionRegistry</span> <span class="token punctuation">{</span>
  val functionBuilders <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">mutable<span class="token punctuation">.</span></span>HashMap</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">FunctionBuilder</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  def <span class="token function">registerFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> builder<span class="token operator">:</span> <span class="token class-name">FunctionBuilder</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    functionBuilders<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> builder<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  override def <span class="token function">lookupFunction</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Expression</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">functionBuilders</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="analyzer"><a href="#analyzer" class="header-anchor">#</a> Analyzer</h3> <p>Analyzer里面有一个fixedPoint对象，一个Seq[Batch]对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Provides a logical query plan analyzer, which translates [[UnresolvedAttribute]]s and
 * [[UnresolvedRelation]]s into fully typed objects using information in a schema [[Catalog]] and
 * a [[FunctionRegistry]].
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Analyzer</span><span class="token punctuation">(</span>catalog<span class="token operator">:</span> <span class="token class-name">Catalog</span><span class="token punctuation">,</span> registry<span class="token operator">:</span> <span class="token class-name">FunctionRegistry</span><span class="token punctuation">,</span> caseSensitive<span class="token operator">:</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span>
  <span class="token keyword">extends</span> <span class="token class-name">RuleExecutor</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token class-name">HiveTypeCoercion</span> <span class="token punctuation">{</span>

  val resolver <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>caseSensitive<span class="token punctuation">)</span> caseSensitiveResolution <span class="token keyword">else</span> caseInsensitiveResolution

  <span class="token comment">// TODO: pass this in as a parameter.</span>
  val fixedPoint <span class="token operator">=</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>

  <span class="token comment">/**
   * Override to provide additional rules for the &quot;Resolution&quot; batch.
   */</span>
  val extendedRules<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Nil</span>

  lazy val batches<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Batch</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Seq</span><span class="token punctuation">(</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;MultiInstanceRelations&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Once</span><span class="token punctuation">,</span>
      <span class="token class-name">NewRelationInstances</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;Resolution&quot;</span><span class="token punctuation">,</span> fixedPoint<span class="token punctuation">,</span>
      <span class="token class-name">ResolveReferences</span> <span class="token operator">::</span>
      <span class="token class-name">ResolveRelations</span> <span class="token operator">::</span>
      <span class="token class-name">ResolveSortReferences</span> <span class="token operator">::</span>
      <span class="token class-name">NewRelationInstances</span> <span class="token operator">::</span>
      <span class="token class-name">ImplicitGenerate</span> <span class="token operator">::</span>
      <span class="token class-name">StarExpansion</span> <span class="token operator">::</span>
      <span class="token class-name">ResolveFunctions</span> <span class="token operator">::</span>
      <span class="token class-name">GlobalAggregates</span> <span class="token operator">::</span>
      <span class="token class-name">UnresolvedHavingClauseAttributes</span> <span class="token operator">::</span>
      <span class="token class-name">TrimGroupingAliases</span> <span class="token operator">::</span>
      <span class="token function">typeCoercionRules</span> <span class="token operator">++</span>
      extendedRules <span class="token operator">:</span> _<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;Check Analysis&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Once</span><span class="token punctuation">,</span>
      <span class="token class-name">CheckResolution</span><span class="token punctuation">,</span>
      <span class="token class-name">CheckAggregation</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;AnalysisOperators&quot;</span><span class="token punctuation">,</span> fixedPoint<span class="token punctuation">,</span>
      <span class="token class-name">EliminateAnalysisOperators</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Analyzer解析主要是根据这个batches里面的各种Rule来对Unresolved Logical Plan进行解析的。这里Analyzer类本身并没有定义执行的方法，而实现在它的父类RuleExecutor[LogicalPlan]中。</p> <h3 id="rules介绍"><a href="#rules介绍" class="header-anchor">#</a> Rules介绍</h3> <p>在batches里面定义了4个Batch:</p> <ol><li>MultiInstanceRelations (Once)</li> <li>Resolution (fixedPoint)</li> <li>Check Analysis (Once)</li> <li>AnalysisOperators (fixedPoint)</li></ol> <p>不同的batch是顺序执行的，也就是说MultiInstanceRelations执行完了，才会执行Resolution。</p> <p>Once表示MultiInstanceRelations的Rule只会执行一次，fixedPoint表示Resolution里面的Rule会反复执行多次，具体几次定义在FixedPoint里面（当然如果运行Rule前后的LogicalPlan没有变化，也会提前停止执行）。</p> <p>Resolution这个Batch里面定义了十几个Rules，例如ResolveReferences，ResolveRelations，ResolveSortReferences,etc。这些不同的Rule会循环执行fixedPoint次，执行的顺序是依次执行，也就是说，ResolveReferences -&gt; ResolveRelations -&gt; ResolveSortReferences -&gt; ResolveReferences -&gt; ResolveRelations -&gt; ResolveSortReferences -&gt; ...，类似这个顺序。</p> <p>下面介绍一下每一个Rule具体做什么事情。</p> <h5 id="multiinstancerelation"><a href="#multiinstancerelation" class="header-anchor">#</a> MultiInstanceRelation</h5> <p>如果一个实例在Logical Plan里出现了多次，则会应用NewRelationInstances这条Rule。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * If any MultiInstanceRelation appears more than once in the query plan then the plan is updated so
 * that each instance has unique expression ids for the attributes produced.
 */</span>
object <span class="token class-name">NewRelationInstances</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">//将logical plan应用partial function得到所有MultiInstanceRelation的plan的集合</span>
    val localRelations <span class="token operator">=</span> plan collect <span class="token punctuation">{</span> <span class="token keyword">case</span> l<span class="token operator">:</span> <span class="token class-name">MultiInstanceRelation</span> <span class="token operator">=</span><span class="token operator">&gt;</span> l<span class="token punctuation">}</span>

    val multiAppearance <span class="token operator">=</span> localRelations
      <span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>identity<span class="token punctuation">[</span><span class="token class-name">MultiInstanceRelation</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//group by操作</span>
      <span class="token punctuation">.</span>filter <span class="token punctuation">{</span> <span class="token keyword">case</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> ls<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ls<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token comment">//如果只取size大于1的进行后续操作</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span>
      <span class="token punctuation">.</span>toSet

    <span class="token comment">//更新plan，使得每个实例的expId是唯一的。</span>
    plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> l<span class="token operator">:</span> <span class="token class-name">MultiInstanceRelation</span> <span class="token keyword">if</span> multiAppearance contains l <span class="token operator">=</span><span class="token operator">&gt;</span> l<span class="token punctuation">.</span>newInstance
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="resolvereferences"><a href="#resolvereferences" class="header-anchor">#</a> ResolveReferences</h5> <p>将Sql parser解析出来的UnresolvedAttribute全部都转为对应的实际的catalyst.expressions.AttributeReference。这里调用了Logical Plan的resolveChildren方法，将属性转为NamedExepression。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Replaces [[UnresolvedAttribute]]s with concrete
   * [[catalyst.expressions.AttributeReference AttributeReferences]] from a logical plan node's
   * children.
   */</span>
  object <span class="token class-name">ResolveReferences</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token keyword">if</span> q<span class="token punctuation">.</span>childrenResolved <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token function">logTrace</span><span class="token punctuation">(</span>s<span class="token string">&quot;Attempting to resolve ${q.simpleString}&quot;</span><span class="token punctuation">)</span>
        q transformExpressions <span class="token punctuation">{</span>
          <span class="token keyword">case</span> u @ <span class="token class-name">UnresolvedAttribute</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
            <span class="token comment">// Leave unchanged if resolution fails.  Hopefully will be resolved next round.</span>
            val result <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">resolveChildren</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>
            <span class="token function">logDebug</span><span class="token punctuation">(</span>s<span class="token string">&quot;Resolving $u to $result&quot;</span><span class="token punctuation">)</span>
            result
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="resolverelations"><a href="#resolverelations" class="header-anchor">#</a> ResolveRelations</h5> <p>在<code>select * from src</code>中，src表parse后就是一个UnresolvedRelation节点。ResolveRelations就是把src替换成具体的LogicalPlan。而这个table name到LogicalPlan的映射可以从Catalog里获得。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Replaces [[UnresolvedRelation]]s with concrete relations from the catalog.
   */</span>
  object <span class="token class-name">ResolveRelations</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> i @ <span class="token class-name">InsertIntoTable</span><span class="token punctuation">(</span><span class="token class-name">UnresolvedRelation</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> name<span class="token punctuation">,</span> alias<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        i<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>
          table <span class="token operator">=</span> <span class="token class-name">EliminateAnalysisOperators</span><span class="token punctuation">(</span>catalog<span class="token punctuation">.</span><span class="token function">lookupRelation</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> name<span class="token punctuation">,</span> alias<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token class-name">UnresolvedRelation</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> name<span class="token punctuation">,</span> alias<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        catalog<span class="token punctuation">.</span><span class="token function">lookupRelation</span><span class="token punctuation">(</span>databaseName<span class="token punctuation">,</span> name<span class="token punctuation">,</span> alias<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
def <span class="token function">lookupRelation</span><span class="token punctuation">(</span>
    databaseName<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    tableName<span class="token operator">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
    alias<span class="token operator">:</span> <span class="token class-name">Option</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">None</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span>
</code></pre></div><h5 id="resolvesortreferences"><a href="#resolvesortreferences" class="header-anchor">#</a> ResolveSortReferences</h5> <p>在某些SQL的定义里面，可以允许按照没有出现在select里面的attribute进行sort。这个规则是用来检测这些语法，并且自动把sort的attribute加入到select里面，并且在上次加入去到这个attribute的projection。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * In many dialects of SQL is it valid to sort by attributes that are not present in the SELECT
   * clause.  This rule detects such queries and adds the required attributes to the original
   * projection, so that they will be available during sorting. Another projection is added to
   * remove these attributes after sorting.
   */</span>
  object <span class="token class-name">ResolveSortReferences</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> s @ <span class="token class-name">Sort</span><span class="token punctuation">(</span>ordering<span class="token punctuation">,</span> p @ <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>s<span class="token punctuation">.</span>resolved <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>resolved <span class="token operator">=</span><span class="token operator">&gt;</span>
        val unresolved <span class="token operator">=</span> ordering<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> <span class="token class-name">UnresolvedAttribute</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span>
        val resolved <span class="token operator">=</span> unresolved<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span><span class="token punctuation">)</span>
        val requiredAttributes <span class="token operator">=</span> <span class="token class-name">AttributeSet</span><span class="token punctuation">(</span>resolved<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> a<span class="token operator">:</span> <span class="token class-name">Attribute</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a <span class="token punctuation">}</span><span class="token punctuation">)</span>

        val missingInProject <span class="token operator">=</span> requiredAttributes <span class="token operator">--</span> p<span class="token punctuation">.</span>output
        <span class="token keyword">if</span> <span class="token punctuation">(</span>missingInProject<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Add missing attributes and then project them away after the sort.</span>
          <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toAttribute<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">Sort</span><span class="token punctuation">(</span>ordering<span class="token punctuation">,</span>
              <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList <span class="token operator">++</span> missingInProject<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token function">logDebug</span><span class="token punctuation">(</span>s<span class="token string">&quot;Failed to find $missingInProject in ${p.output.mkString(&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;)}&quot;</span><span class="token punctuation">)</span>
          s <span class="token comment">// Nothing we can do here. Return original plan.</span>
        <span class="token punctuation">}</span>
      <span class="token keyword">case</span> s @ <span class="token class-name">Sort</span><span class="token punctuation">(</span>ordering<span class="token punctuation">,</span> a @ <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>grouping<span class="token punctuation">,</span> aggs<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>s<span class="token punctuation">.</span>resolved <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>resolved <span class="token operator">=</span><span class="token operator">&gt;</span>
        val unresolved <span class="token operator">=</span> ordering<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> <span class="token class-name">UnresolvedAttribute</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// A small hack to create an object that will allow us to resolve any references that</span>
        <span class="token comment">// refer to named expressions that are present in the grouping expressions.</span>
        val groupingRelation <span class="token operator">=</span> <span class="token class-name">LocalRelation</span><span class="token punctuation">(</span>
          grouping<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> ne<span class="token operator">:</span> <span class="token class-name">NamedExpression</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ne<span class="token punctuation">.</span>toAttribute <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>

        <span class="token function">logDebug</span><span class="token punctuation">(</span>s<span class="token string">&quot;Grouping expressions: $groupingRelation&quot;</span><span class="token punctuation">)</span>
        val resolved <span class="token operator">=</span> unresolved<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>groupingRelation<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span><span class="token punctuation">)</span>
        val missingInAggs <span class="token operator">=</span> resolved<span class="token punctuation">.</span><span class="token function">filterNot</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>outputSet<span class="token punctuation">.</span>contains<span class="token punctuation">)</span>
        <span class="token function">logDebug</span><span class="token punctuation">(</span>s<span class="token string">&quot;Resolved: $resolved Missing in aggs: $missingInAggs&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>missingInAggs<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Add missing grouping exprs and then project them away after the sort.</span>
          <span class="token class-name">Project</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>output<span class="token punctuation">,</span>
            <span class="token class-name">Sort</span><span class="token punctuation">(</span>ordering<span class="token punctuation">,</span>
              <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>grouping<span class="token punctuation">,</span> aggs <span class="token operator">++</span> missingInAggs<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          s <span class="token comment">// Nothing we can do here. Return original plan.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="implicitgenerate"><a href="#implicitgenerate" class="header-anchor">#</a> ImplicitGenerate</h5> <p>如果在select语句里只有一个表达式，而且这个表达式是一个Generator（Generator是一个1条记录生成到N条记录的映射）。当在解析逻辑计划时，遇到Project节点的时候，就可以将它转换为Generate类（Generate类是将输入流应用一个函数，从而生成一个新的流）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * When a SELECT clause has only a single expression and that expression is a
   * [[catalyst.expressions.Generator Generator]] we convert the
   * [[catalyst.plans.logical.Project Project]] to a [[catalyst.plans.logical.Generate Generate]].
   */</span>
  object <span class="token class-name">ImplicitGenerate</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span><span class="token class-name">Seq</span><span class="token punctuation">(</span><span class="token class-name">Alias</span><span class="token punctuation">(</span>g<span class="token operator">:</span> <span class="token class-name">Generator</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token class-name">Generate</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> join <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> outer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">None</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="starexpansion"><a href="#starexpansion" class="header-anchor">#</a> StarExpansion</h5> <p>在Project操作符里，如果是*符号，可以将所有的references都展开成实际的字段。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Expands any references to [[Star]] (*) in project operators.
   */</span>
  object <span class="token class-name">StarExpansion</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token comment">// Wait until children are resolved</span>
      <span class="token keyword">case</span> p<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>childrenResolved <span class="token operator">=</span><span class="token operator">&gt;</span> p
      <span class="token comment">// If the projection list contains Stars, expand it.</span>
      <span class="token keyword">case</span> p @ <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token function">containsStar</span><span class="token punctuation">(</span>projectList<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token class-name">Project</span><span class="token punctuation">(</span>
          projectList<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>
            <span class="token keyword">case</span> s<span class="token operator">:</span> <span class="token class-name">Star</span> <span class="token operator">=</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span><span class="token function">expand</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>output<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span>
            <span class="token keyword">case</span> o <span class="token operator">=</span><span class="token operator">&gt;</span> o <span class="token operator">::</span> <span class="token class-name">Nil</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          child<span class="token punctuation">)</span>
      <span class="token keyword">case</span> t<span class="token operator">:</span> <span class="token class-name">ScriptTransformation</span> <span class="token keyword">if</span> <span class="token function">containsStar</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>input<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        t<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>
          input <span class="token operator">=</span> t<span class="token punctuation">.</span>input<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>
            <span class="token keyword">case</span> s<span class="token operator">:</span> <span class="token class-name">Star</span> <span class="token operator">=</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span><span class="token function">expand</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>child<span class="token punctuation">.</span>output<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span>
            <span class="token keyword">case</span> o <span class="token operator">=</span><span class="token operator">&gt;</span> o <span class="token operator">::</span> <span class="token class-name">Nil</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
      <span class="token comment">// If the aggregate function argument contains Stars, expand it.</span>
      <span class="token keyword">case</span> a<span class="token operator">:</span> <span class="token class-name">Aggregate</span> <span class="token keyword">if</span> <span class="token function">containsStar</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>aggregateExpressions<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        a<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>
          aggregateExpressions <span class="token operator">=</span> a<span class="token punctuation">.</span>aggregateExpressions<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span>
            <span class="token keyword">case</span> s<span class="token operator">:</span> <span class="token class-name">Star</span> <span class="token operator">=</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span><span class="token function">expand</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>child<span class="token punctuation">.</span>output<span class="token punctuation">,</span> resolver<span class="token punctuation">)</span>
            <span class="token keyword">case</span> o <span class="token operator">=</span><span class="token operator">&gt;</span> o <span class="token operator">::</span> <span class="token class-name">Nil</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * Returns true if `exprs` contains a [[Star]].
     */</span>
    <span class="token keyword">protected</span> def <span class="token function">containsStar</span><span class="token punctuation">(</span>exprs<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span>
      exprs<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> _<span class="token operator">:</span> <span class="token class-name">Star</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">.</span>nonEmpty
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="resolvefunctions"><a href="#resolvefunctions" class="header-anchor">#</a> ResolveFunctions</h5> <p>这里主要是对UDF进行resolve，将这些UDF可以从FunctionRegistry里找到。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Replaces [[UnresolvedFunction]]s with concrete [[catalyst.expressions.Expression Expressions]].
   */</span>
  object <span class="token class-name">ResolveFunctions</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        q transformExpressions <span class="token punctuation">{</span>
          <span class="token keyword">case</span> u @ <span class="token class-name">UnresolvedFunction</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> children<span class="token punctuation">)</span> <span class="token keyword">if</span> u<span class="token punctuation">.</span>childrenResolved <span class="token operator">=</span><span class="token operator">&gt;</span>
            registry<span class="token punctuation">.</span><span class="token function">lookupFunction</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="globalaggregates"><a href="#globalaggregates" class="header-anchor">#</a> GlobalAggregates</h5> <p>如果遇到包含Aggregate的Project，就返回一个Aggregate。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Turns projections that contain aggregate expressions into aggregations.
   */</span>
  object <span class="token class-name">GlobalAggregates</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token function">containsAggregates</span><span class="token punctuation">(</span>projectList<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token class-name">Aggregate</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">,</span> projectList<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    def <span class="token function">containsAggregates</span><span class="token punctuation">(</span>exprs<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      exprs<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>foreach <span class="token punctuation">{</span>
        <span class="token keyword">case</span> agg<span class="token operator">:</span> <span class="token class-name">AggregateExpression</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="unresolvedhavingclauseattributes"><a href="#unresolvedhavingclauseattributes" class="header-anchor">#</a> UnresolvedHavingClauseAttributes</h5> <p>这条规则会寻找Having子句中Unresolved Attributes，将这些Attributes下降到下面的Aggregates里面，最后在最上面添加Project。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * This rule finds expressions in HAVING clause filters that depend on
   * unresolved attributes.  It pushes these expressions down to the underlying
   * aggregates and then projects them away above the filter.
   */</span>
  object <span class="token class-name">UnresolvedHavingClauseAttributes</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> filter @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>havingCondition<span class="token punctuation">,</span> aggregate @ <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> originalAggExprs<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> aggregate<span class="token punctuation">.</span>resolved <span class="token operator">&amp;&amp;</span> <span class="token function">containsAggregate</span><span class="token punctuation">(</span>havingCondition<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        val evaluatedCondition <span class="token operator">=</span> <span class="token class-name">Alias</span><span class="token punctuation">(</span>havingCondition<span class="token punctuation">,</span>  <span class="token string">&quot;havingCondition&quot;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        val aggExprsWithHaving <span class="token operator">=</span> evaluatedCondition <span class="token operator">+</span><span class="token operator">:</span> originalAggExprs

        <span class="token class-name">Project</span><span class="token punctuation">(</span>aggregate<span class="token punctuation">.</span>output<span class="token punctuation">,</span>
          <span class="token class-name">Filter</span><span class="token punctuation">(</span>evaluatedCondition<span class="token punctuation">.</span>toAttribute<span class="token punctuation">,</span>
            aggregate<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>aggregateExpressions <span class="token operator">=</span> aggExprsWithHaving<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> def <span class="token function">containsAggregate</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token class-name">Expression</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span>
      condition
        <span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> ae<span class="token operator">:</span> <span class="token class-name">AggregateExpression</span> <span class="token operator">=</span><span class="token operator">&gt;</span> ae <span class="token punctuation">}</span>
        <span class="token punctuation">.</span>nonEmpty
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="trimgroupingaliases"><a href="#trimgroupingaliases" class="header-anchor">#</a> TrimGroupingAliases</h5> <p>去除Aggreate中没有操作的alias。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Removes no-op Alias expressions from the plan.
   */</span>
  object <span class="token class-name">TrimGroupingAliases</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>groups<span class="token punctuation">,</span> aggs<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>groups<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>transform <span class="token punctuation">{</span> <span class="token keyword">case</span> <span class="token class-name">Alias</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> c <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> aggs<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="checkresolution"><a href="#checkresolution" class="header-anchor">#</a> CheckResolution</h5> <p>在上述主要的优化规则都运行完后，CheckResolution会运行一次，用来检查是不是所有的节点都已经resolved了，如果不是就抛异常。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Makes sure all attributes and logical plans have been resolved.
   */</span>
  object <span class="token class-name">CheckResolution</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      plan<span class="token punctuation">.</span>transform <span class="token punctuation">{</span>
        <span class="token keyword">case</span> p <span class="token keyword">if</span> p<span class="token punctuation">.</span>expressions<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span>resolved<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeException</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>
            s<span class="token string">&quot;Unresolved attributes: ${p.expressions.filterNot(_.resolved).mkString(&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;)}&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> p <span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>resolved <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>childrenResolved <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeException</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">&quot;Unresolved plan found&quot;</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> match <span class="token punctuation">{</span>
        <span class="token comment">// As a backstop, use the root node to check that the entire plan tree is resolved.</span>
        <span class="token keyword">case</span> p <span class="token keyword">if</span> <span class="token operator">!</span>p<span class="token punctuation">.</span>resolved <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeException</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">&quot;Unresolved plan in tree&quot;</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> p <span class="token operator">=</span><span class="token operator">&gt;</span> p
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="checkaggregation"><a href="#checkaggregation" class="header-anchor">#</a> CheckAggregation</h5> <p>在上述主要的优化规则都运行完后，CheckAggregation也会运行一次，用于检查是否存在non-aggregated attributes，如果不是就抛异常。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
   * Checks for non-aggregated attributes with aggregation
   */</span>
  object <span class="token class-name">CheckAggregation</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      plan<span class="token punctuation">.</span>transform <span class="token punctuation">{</span>
        <span class="token keyword">case</span> aggregatePlan @ <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>groupingExprs<span class="token punctuation">,</span> aggregateExprs<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          def <span class="token function">isValidAggregateExpression</span><span class="token punctuation">(</span>expr<span class="token operator">:</span> <span class="token class-name">Expression</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span> expr match <span class="token punctuation">{</span>
            <span class="token keyword">case</span> _<span class="token operator">:</span> <span class="token class-name">AggregateExpression</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
            <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name">Attribute</span> <span class="token operator">=</span><span class="token operator">&gt;</span> groupingExprs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
            <span class="token keyword">case</span> e <span class="token keyword">if</span> groupingExprs<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
            <span class="token keyword">case</span> e <span class="token keyword">if</span> e<span class="token punctuation">.</span>references<span class="token punctuation">.</span>isEmpty <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
            <span class="token keyword">case</span> e <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forall</span><span class="token punctuation">(</span>isValidAggregateExpression<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>

          aggregateExprs<span class="token punctuation">.</span>find <span class="token punctuation">{</span> e <span class="token operator">=</span><span class="token operator">&gt;</span>
            <span class="token operator">!</span><span class="token function">isValidAggregateExpression</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>transform <span class="token punctuation">{</span>
              <span class="token comment">// Should trim aliases around `GetField`s. These aliases are introduced while</span>
              <span class="token comment">// resolving struct field accesses, because `GetField` is not a `NamedExpression`.</span>
              <span class="token comment">// (Should we just turn `GetField` into a `NamedExpression`?)</span>
              <span class="token keyword">case</span> <span class="token class-name">Alias</span><span class="token punctuation">(</span>g<span class="token operator">:</span> <span class="token class-name">GetField</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> g
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">.</span>foreach <span class="token punctuation">{</span> e <span class="token operator">=</span><span class="token operator">&gt;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeException</span><span class="token punctuation">(</span>plan<span class="token punctuation">,</span> s<span class="token string">&quot;Expression not in GROUP BY: $e&quot;</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>

          aggregatePlan
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="eliminateanalysisoperators"><a href="#eliminateanalysisoperators" class="header-anchor">#</a> EliminateAnalysisOperators</h5> <p>将Subquery移除。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Removes [[catalyst.plans.logical.Subquery Subquery]] operators from the plan.  Subqueries are
 * only required to provide scoping information for attributes and can be removed once analysis is
 * complete.
 */</span>
object <span class="token class-name">EliminateAnalysisOperators</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Subquery</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> child
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_5-optimizer"><a href="#_5-optimizer" class="header-anchor">#</a> 5. Optimizer</h2> <p>Optimizer的主要职责是将Analyzer输出的Resolved Logical Plan根据不同的优化策略Batch，来对语法树进行优化。Optimizer的工作方式其实类似Analyzer，因为它们都继承自RuleExecutor[LogicalPlan]，都是执行一系列的Batch操作。</p> <h3 id="rules介绍-2"><a href="#rules介绍-2" class="header-anchor">#</a> Rules介绍</h3> <p>Optimizer里的batches包含了4大类优化策略：</p> <ol><li>Combine Limits： 合并Limits</li> <li>ConstantFolding： 常量合并</li> <li>Decimal Optimizations： Decimal类型数据计算优化</li> <li>Filter Pushdown： 过滤器下推</li></ol> <div class="language-java extra-class"><pre class="language-java"><code>object <span class="token class-name">DefaultOptimizer</span> <span class="token keyword">extends</span> <span class="token class-name">Optimizer</span> <span class="token punctuation">{</span>
  val batches <span class="token operator">=</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;Combine Limits&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token class-name">CombineLimits</span><span class="token punctuation">)</span> <span class="token operator">::</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;ConstantFolding&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token class-name">NullPropagation</span><span class="token punctuation">,</span>
      <span class="token class-name">ConstantFolding</span><span class="token punctuation">,</span>
      <span class="token class-name">LikeSimplification</span><span class="token punctuation">,</span>
      <span class="token class-name">BooleanSimplification</span><span class="token punctuation">,</span>
      <span class="token class-name">SimplifyFilters</span><span class="token punctuation">,</span>
      <span class="token class-name">SimplifyCasts</span><span class="token punctuation">,</span>
      <span class="token class-name">SimplifyCaseConversionExpressions</span><span class="token punctuation">,</span>
      <span class="token class-name">OptimizeIn</span><span class="token punctuation">)</span> <span class="token operator">::</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;Decimal Optimizations&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token class-name">DecimalAggregates</span><span class="token punctuation">)</span> <span class="token operator">::</span>
    <span class="token class-name">Batch</span><span class="token punctuation">(</span><span class="token string">&quot;Filter Pushdown&quot;</span><span class="token punctuation">,</span> <span class="token class-name">FixedPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token class-name">UnionPushdown</span><span class="token punctuation">,</span>
      <span class="token class-name">CombineFilters</span><span class="token punctuation">,</span>
      <span class="token class-name">PushPredicateThroughProject</span><span class="token punctuation">,</span>
      <span class="token class-name">PushPredicateThroughJoin</span><span class="token punctuation">,</span>
      <span class="token class-name">ColumnPruning</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token class-name">Nil</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="combinelimits"><a href="#combinelimits" class="header-anchor">#</a> CombineLimits</h5> <p>目前该规则无法优化<code>val query = sql(&quot;select * from (select * from table limit 100) limit 10 &quot;)</code>这样的语句，因为CombineLimits在第一个batch里面，而且是唯一一个，也就是说它不能在其他规则的基础上再运行自己，而只能优化连续出现的两个Limit。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Combines two adjacent [[Limit]] operators into one, merging the
 * expressions into one single expression.
 */</span>
object <span class="token class-name">CombineLimits</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ll @ <span class="token class-name">Limit</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> nl @ <span class="token class-name">Limit</span><span class="token punctuation">(</span>ne<span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">Limit</span><span class="token punctuation">(</span><span class="token class-name">If</span><span class="token punctuation">(</span><span class="token class-name">LessThan</span><span class="token punctuation">(</span>ne<span class="token punctuation">,</span> le<span class="token punctuation">)</span><span class="token punctuation">,</span> ne<span class="token punctuation">,</span> le<span class="token punctuation">)</span><span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="nullpropagation"><a href="#nullpropagation" class="header-anchor">#</a> NullPropagation</h5> <p>Literal字面量是一个能匹配任意基本类型的类。</p> <div class="language-java extra-class"><pre class="language-java"><code>object <span class="token class-name">Literal</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token class-name">Any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Literal</span> <span class="token operator">=</span> v match <span class="token punctuation">{</span>
    <span class="token keyword">case</span> i<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">IntegerType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> l<span class="token operator">:</span> <span class="token class-name">Long</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">LongType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> d<span class="token operator">:</span> <span class="token class-name">Double</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token class-name">DoubleType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> f<span class="token operator">:</span> <span class="token class-name">Float</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token class-name">FloatType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> b<span class="token operator">:</span> <span class="token class-name">Byte</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token class-name">ByteType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> s<span class="token operator">:</span> <span class="token class-name">Short</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">ShortType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> s<span class="token operator">:</span> <span class="token class-name">String</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token class-name">StringType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> b<span class="token operator">:</span> <span class="token class-name">Boolean</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> d<span class="token operator">:</span> <span class="token class-name">BigDecimal</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token class-name">Decimal</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">DecimalType<span class="token punctuation">.</span>Unlimited</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> d<span class="token operator">:</span> <span class="token class-name">Decimal</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token class-name">DecimalType<span class="token punctuation">.</span>Unlimited</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> t<span class="token operator">:</span> <span class="token class-name">Timestamp</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token class-name">TimestampType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> d<span class="token operator">:</span> <span class="token class-name">Date</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token class-name">DateType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> a<span class="token operator">:</span> <span class="token class-name">Array</span><span class="token punctuation">[</span><span class="token class-name">Byte</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token class-name">BinaryType</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token keyword">null</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">NullType</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意Literal是一个LeafExpression，核心方法是eval，给定Row，计算表达式返回值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">case</span> <span class="token keyword">class</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token class-name">Any</span><span class="token punctuation">,</span> dataType<span class="token operator">:</span> <span class="token class-name">DataType</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token class-name">LeafExpression</span> <span class="token punctuation">{</span>

  override def foldable <span class="token operator">=</span> <span class="token boolean">true</span>
  def nullable <span class="token operator">=</span> value <span class="token operator">==</span> <span class="token keyword">null</span>


  override def toString <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> value<span class="token punctuation">.</span>toString <span class="token keyword">else</span> <span class="token string">&quot;null&quot;</span>

  type <span class="token class-name">EvaluatedType</span> <span class="token operator">=</span> <span class="token class-name">Any</span>
  override def <span class="token function">eval</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token class-name">Row</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Any</span> <span class="token operator">=</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>NullPropagation是一个能将Expression Expressions替换为等价的Literal值的优化，并且能够避免NULL值在SQL语法树的传播。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Replaces [[Expression Expressions]] that can be statically evaluated with
 * equivalent [[Literal]] values. This rule is more specific with
 * Null value propagation from bottom to top of the expression tree.
 */</span>
object <span class="token class-name">NullPropagation</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span> q transformExpressionsUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Count</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Cast</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Sum</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Cast</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Average</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">IsNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>nullable <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">IsNotNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>c<span class="token punctuation">.</span>nullable <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">GetItem</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">GetItem</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">GetField</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">EqualNullSafe</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">IsNull</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">EqualNullSafe</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">IsNull</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>

      <span class="token comment">// For Coalesce, remove null literals.</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Coalesce</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        val newChildren <span class="token operator">=</span> children<span class="token punctuation">.</span>filter <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
          <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newChildren<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newChildren<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">newChildren</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token class-name">Coalesce</span><span class="token punctuation">(</span>newChildren<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

      <span class="token keyword">case</span> e @ <span class="token class-name">Substring</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Substring</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">Substring</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>

      <span class="token comment">// Put exceptional cases above if any</span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name">BinaryArithmetic</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>children match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token function">right</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> left <span class="token operator">::</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> e
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name">BinaryComparison</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>children match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token function">right</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> left <span class="token operator">::</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> e
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name">StringRegexExpression</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>children match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token function">right</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> left <span class="token operator">::</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> e
      <span class="token punctuation">}</span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> <span class="token class-name">StringComparison</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>children match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token function">right</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> left <span class="token operator">::</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token class-name">Nil</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> e
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="constantfolding"><a href="#constantfolding" class="header-anchor">#</a> ConstantFolding</h5> <p>常量合并是属于Expression优化的一种，对于可以直接计算的常量，不用放到物理执行里去生成对象来计算了，直接可以在计划里就计算出来。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Replaces [[Expression Expressions]] that can be statically evaluated with
 * equivalent [[Literal]] values.
 */</span>
object <span class="token class-name">ConstantFolding</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span> q transformExpressionsDown <span class="token punctuation">{</span>
      <span class="token comment">// Skip redundant folding of literals. This rule is technically not necessary. Placing this</span>
      <span class="token comment">// here avoids running the next rule for Literal values, which would create a new Literal</span>
      <span class="token comment">// object and running eval unnecessarily.</span>
      <span class="token keyword">case</span> l<span class="token operator">:</span> <span class="token class-name">Literal</span> <span class="token operator">=</span><span class="token operator">&gt;</span> l

      <span class="token comment">// Fold expressions that are foldable.</span>
      <span class="token keyword">case</span> e <span class="token keyword">if</span> e<span class="token punctuation">.</span>foldable <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>dataType<span class="token punctuation">)</span>

      <span class="token comment">// Fold &quot;literal in (item1, item2, ..., literal, ...)&quot; into true directly.</span>
      <span class="token keyword">case</span> <span class="token class-name">In</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token keyword">if</span> list<span class="token punctuation">.</span>exists <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>candidate<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token keyword">if</span> candidate <span class="token operator">==</span> v <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">true</span>
          <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="likesimplification"><a href="#likesimplification" class="header-anchor">#</a> LikeSimplification</h5> <p>简化Like字句，如果符合下面四种情况之一：</p> <ol><li>startsWith</li> <li>endsWith</li> <li>contains</li> <li>equalTo</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Simplifies LIKE expressions that do not need full regular expressions to evaluate the condition.
 * For example, when the expression is just checking to see if a string starts with a given
 * pattern.
 */</span>
object <span class="token class-name">LikeSimplification</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token comment">// if guards below protect from escapes on trailing %.</span>
  <span class="token comment">// Cases like &quot;something\%&quot; are not optimized, but this does not affect correctness.</span>
  val startsWith <span class="token operator">=</span> <span class="token string">&quot;([^_%]+)%&quot;</span><span class="token punctuation">.</span>r
  val endsWith <span class="token operator">=</span> <span class="token string">&quot;%([^_%]+)&quot;</span><span class="token punctuation">.</span>r
  val contains <span class="token operator">=</span> <span class="token string">&quot;%([^_%]+)%&quot;</span><span class="token punctuation">.</span>r
  val equalTo <span class="token operator">=</span> <span class="token string">&quot;([^_%]*)&quot;</span><span class="token punctuation">.</span>r

  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformAllExpressions <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Like</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token function">startsWith</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StringType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>pattern<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;\\&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">StartsWith</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token class-name">Like</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token function">endsWith</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StringType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">EndsWith</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token class-name">Like</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token function">contains</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StringType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>pattern<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;\\&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">Contains</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token class-name">Like</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token function">equalTo</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StringType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">EqualTo</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="booleansimplification"><a href="#booleansimplification" class="header-anchor">#</a> BooleanSimplification</h5> <p>这个是对布尔表达式的优化，有点像java布尔表达式中的短路判断。看看布尔表达式2边能不能通过只计算1边，而省去计算另一边而提高效率，称为简化布尔表达式。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Simplifies boolean expressions where the answer can be determined without evaluating both sides.
 * Note that this rule can eliminate expressions that might otherwise have been evaluated and thus
 * is only safe when evaluations of expressions does not result in side effects.
 */</span>
object <span class="token class-name">BooleanSimplification</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span> q transformExpressionsUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> and @ <span class="token class-name">And</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r
          <span class="token keyword">case</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> l
          <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> and
        <span class="token punctuation">}</span>

      <span class="token keyword">case</span> or @ <span class="token class-name">Or</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> match <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> r
          <span class="token keyword">case</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> l
          <span class="token keyword">case</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> or
        <span class="token punctuation">}</span>

      <span class="token keyword">case</span> not @ <span class="token class-name">Not</span><span class="token punctuation">(</span>exp<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        exp match <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">GreaterThan</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">LessThanOrEqual</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">GreaterThanOrEqual</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">LessThan</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">LessThan</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">GreaterThanOrEqual</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">LessThanOrEqual</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">GreaterThan</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
          <span class="token keyword">case</span> <span class="token class-name">Not</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> e
          <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">&gt;</span> not
        <span class="token punctuation">}</span>

      <span class="token comment">// Turn &quot;if (true) a else b&quot; into &quot;a&quot;, and if (false) a else b&quot; into &quot;b&quot;.</span>
      <span class="token keyword">case</span> e @ <span class="token class-name">If</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> trueValue<span class="token punctuation">,</span> falseValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> trueValue <span class="token keyword">else</span> falseValue
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="simplifyfilters"><a href="#simplifyfilters" class="header-anchor">#</a> SimplifyFilters</h5> <p>如果filter总是返回true，则删除filter返回child，如果filter总是返回false，则返回empty的relation。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Removes filters that can be evaluated trivially.  This is done either by eliding the filter for
 * cases where it will always evaluate to `true`, or substituting a dummy empty relation when the
 * filter will always evaluate to `false`.
 */</span>
object <span class="token class-name">SimplifyFilters</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token comment">// If the filter condition always evaluate to true, remove the filter.</span>
    <span class="token keyword">case</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> child
    <span class="token comment">// If the filter condition always evaluate to null or false,</span>
    <span class="token comment">// replace the input with an empty relation.</span>
    <span class="token keyword">case</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">LocalRelation</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>output<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token class-name">Seq</span><span class="token punctuation">.</span>empty<span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token class-name">BooleanType</span><span class="token punctuation">)</span><span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">LocalRelation</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>output<span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token class-name">Seq</span><span class="token punctuation">.</span>empty<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="simplifycasts"><a href="#simplifycasts" class="header-anchor">#</a> SimplifyCasts</h5> <p>如果Cast的类型和实际类型一致，则去除没必要的cast。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Removes [[Cast Casts]] that are unnecessary because the input is already the correct type.
 */</span>
object <span class="token class-name">SimplifyCasts</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformAllExpressions <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Cast</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> dataType<span class="token punctuation">)</span> <span class="token keyword">if</span> e<span class="token punctuation">.</span>dataType <span class="token operator">==</span> dataType <span class="token operator">=</span><span class="token operator">&gt;</span> e
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="simplifycaseconversionexpressions"><a href="#simplifycaseconversionexpressions" class="header-anchor">#</a> SimplifyCaseConversionExpressions</h5> <p>去除内层没必要的大小写转换，直接返回外层的转换。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Removes the inner [[CaseConversionExpression]] that are unnecessary because
 * the inner conversion is overwritten by the outer one.
 */</span>
object <span class="token class-name">SimplifyCaseConversionExpressions</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span> q transformExpressionsUp <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">Upper</span><span class="token punctuation">(</span><span class="token class-name">Upper</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Upper</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token class-name">Upper</span><span class="token punctuation">(</span><span class="token class-name">Lower</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Upper</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token class-name">Lower</span><span class="token punctuation">(</span><span class="token class-name">Upper</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Lower</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token keyword">case</span> <span class="token class-name">Lower</span><span class="token punctuation">(</span><span class="token class-name">Lower</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Lower</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="optimizein"><a href="#optimizein" class="header-anchor">#</a> OptimizeIn</h5> <p>将In(value, Seq[Literal])的节点转换为等价的InSet(value, HashSet[Literal])，会快很多。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Replaces [[In (value, seq[Literal])]] with optimized version[[InSet (value, HashSet[Literal])]]
 * which is much faster
 */</span>
object <span class="token class-name">OptimizeIn</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> q<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span><span class="token operator">&gt;</span> q transformExpressionsDown <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token class-name">In</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span>isInstanceOf<span class="token punctuation">[</span><span class="token class-name">Literal</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          val hSet <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token class-name">InSet</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">++</span> hSet<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="decimalaggregates"><a href="#decimalaggregates" class="header-anchor">#</a> DecimalAggregates</h5> <p>计算fixed-precision Decimal类型的sum和avg的时候，先把它转换为Long类型，做计算，最后在转化为Decimal，会比较快。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Speeds up aggregates on fixed-precision decimals by executing them on unscaled Long values.
 *
 * This uses the same rules for increasing the precision and scale of the output as
 * [[org.apache.spark.sql.catalyst.analysis.HiveTypeCoercion.DecimalPrecision]].
 */</span>
object <span class="token class-name">DecimalAggregates</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span> <span class="token class-name">Decimal</span><span class="token punctuation">.</span>MAX_LONG_DIGITS

  <span class="token comment">/** Maximum number of decimal digits representable precisely in a Double */</span>
  val MAX_DOUBLE_DIGITS <span class="token operator">=</span> <span class="token number">15</span>

  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transformAllExpressions <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Sum</span><span class="token punctuation">(</span>e @ <span class="token class-name">DecimalType<span class="token punctuation">.</span>Expression</span><span class="token punctuation">(</span>prec<span class="token punctuation">,</span> scale<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> prec <span class="token operator">+</span> <span class="token number">10</span> <span class="token operator">&lt;=</span> MAX_LONG_DIGITS <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">MakeDecimal</span><span class="token punctuation">(</span><span class="token class-name">Sum</span><span class="token punctuation">(</span><span class="token class-name">UnscaledValue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prec <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> scale<span class="token punctuation">)</span>

    <span class="token keyword">case</span> <span class="token class-name">Average</span><span class="token punctuation">(</span>e @ <span class="token class-name">DecimalType<span class="token punctuation">.</span>Expression</span><span class="token punctuation">(</span>prec<span class="token punctuation">,</span> scale<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> prec <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">&lt;=</span> MAX_DOUBLE_DIGITS <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token class-name">Cast</span><span class="token punctuation">(</span>
        <span class="token class-name">Divide</span><span class="token punctuation">(</span><span class="token class-name">Average</span><span class="token punctuation">(</span><span class="token class-name">UnscaledValue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10.0</span><span class="token punctuation">,</span> scale<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">DoubleType</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">DecimalType</span><span class="token punctuation">(</span>prec <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> scale <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="unionpushdown"><a href="#unionpushdown" class="header-anchor">#</a> UnionPushdown</h5> <p>把filter和project pushdown到union下面。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
  *  Pushes operations to either side of a Union.
  */</span>
object <span class="token class-name">UnionPushdown</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>

  <span class="token comment">/**
    *  Maps Attributes from the left side to the corresponding Attribute on the right side.
    */</span>
  def <span class="token function">buildRewrites</span><span class="token punctuation">(</span>union<span class="token operator">:</span> <span class="token class-name">Union</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">AttributeMap</span><span class="token punctuation">[</span><span class="token class-name">Attribute</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span>union<span class="token punctuation">.</span>left<span class="token punctuation">.</span>output<span class="token punctuation">.</span>size <span class="token operator">==</span> union<span class="token punctuation">.</span>right<span class="token punctuation">.</span>output<span class="token punctuation">.</span>size<span class="token punctuation">)</span>

    <span class="token class-name">AttributeMap</span><span class="token punctuation">(</span>union<span class="token punctuation">.</span>left<span class="token punctuation">.</span>output<span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>union<span class="token punctuation">.</span>right<span class="token punctuation">.</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
    *  Rewrites an expression so that it can be pushed to the right side of a Union operator.
    *  This method relies on the fact that the output attributes of a union are always equal
    *  to the left child's output.
    */</span>
  def pushToRight<span class="token punctuation">[</span><span class="token class-name">A</span> <span class="token operator">&lt;</span><span class="token operator">:</span> <span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token class-name">A</span><span class="token punctuation">,</span> rewrites<span class="token operator">:</span> <span class="token class-name">AttributeMap</span><span class="token punctuation">[</span><span class="token class-name">Attribute</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val result <span class="token operator">=</span> e transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> a<span class="token operator">:</span> <span class="token class-name">Attribute</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">rewrites</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// We must promise the compiler that we did not discard the names in the case of project</span>
    <span class="token comment">// expressions.  This is safe since the only transformation is from Attribute =&gt; Attribute.</span>
    result<span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token class-name">A</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token comment">// Push down filter into union</span>
    <span class="token keyword">case</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> u @ <span class="token class-name">Union</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      val rewrites <span class="token operator">=</span> <span class="token function">buildRewrites</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>
      <span class="token class-name">Union</span><span class="token punctuation">(</span>
        <span class="token class-name">Filter</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token function">pushToRight</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> rewrites<span class="token punctuation">)</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// Push down projection into union</span>
    <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> u @ <span class="token class-name">Union</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      val rewrites <span class="token operator">=</span> <span class="token function">buildRewrites</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>
      <span class="token class-name">Union</span><span class="token punctuation">(</span>
        <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">pushToRight</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> rewrites<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="combinefilters"><a href="#combinefilters" class="header-anchor">#</a> CombineFilters</h5> <p>合并两个相邻的Filter,这个和上述Combine Limit差不多。合并2个节点，就可以减少树的深度从而减少重复执行过滤的代价。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Combines two adjacent [[Filter]] operators into one, merging the
 * conditions into one conjunctive predicate.
 */</span>
object <span class="token class-name">CombineFilters</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> ff @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>fc<span class="token punctuation">,</span> nf @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>nc<span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">Filter</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">(</span>nc<span class="token punctuation">,</span> fc<span class="token punctuation">)</span><span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="pushpredicatethroughproject"><a href="#pushpredicatethroughproject" class="header-anchor">#</a> PushPredicateThroughProject</h5> <p>Predict push到project下面，如果predict不依赖于project。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Pushes [[Filter]] operators through [[Project]] operators, in-lining any [[Alias Aliases]]
 * that were defined in the projection.
 *
 * This heuristic is valid assuming the expression evaluation cost is minimal.
 */</span>
object <span class="token class-name">PushPredicateThroughProject</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token keyword">case</span> filter @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> project @ <span class="token class-name">Project</span><span class="token punctuation">(</span>fields<span class="token punctuation">,</span> grandChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      val sourceAliases <span class="token operator">=</span> fields<span class="token punctuation">.</span>collect <span class="token punctuation">{</span> <span class="token keyword">case</span> a @ <span class="token class-name">Alias</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
        <span class="token punctuation">(</span>a<span class="token punctuation">.</span>toAttribute<span class="token operator">:</span> <span class="token class-name">Attribute</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> c
      <span class="token punctuation">}</span><span class="token punctuation">.</span>toMap
      project<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>child <span class="token operator">=</span> filter<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>
        <span class="token function">replaceAlias</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> sourceAliases<span class="token punctuation">)</span><span class="token punctuation">,</span>
        grandChild<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  def <span class="token function">replaceAlias</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token class-name">Expression</span><span class="token punctuation">,</span> sourceAliases<span class="token operator">:</span> <span class="token class-name">Map</span><span class="token punctuation">[</span><span class="token class-name">Attribute</span><span class="token punctuation">,</span> <span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Expression</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    condition transform <span class="token punctuation">{</span>
      <span class="token keyword">case</span> a<span class="token operator">:</span> <span class="token class-name">AttributeReference</span> <span class="token operator">=</span><span class="token operator">&gt;</span> sourceAliases<span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="pushpredicatethroughjoin"><a href="#pushpredicatethroughjoin" class="header-anchor">#</a> PushPredicateThroughJoin</h5> <p>Predict push到project下面，如果predict不依赖于join。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Pushes down [[Filter]] operators where the `condition` can be
 * evaluated using only the attributes of the left or right side of a join.  Other
 * [[Filter]] conditions are moved into the `condition` of the [[Join]].
 *
 * And also Pushes down the join filter, where the `condition` can be evaluated using only the
 * attributes of the left or right side of sub query when applicable.
 *
 * Check https://cwiki.apache.org/confluence/display/Hive/OuterJoinBehavior for more details
 */</span>
object <span class="token class-name">PushPredicateThroughJoin</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token class-name">PredicateHelper</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * Splits join condition expressions into three categories based on the attributes required
   * to evaluate them.
   * @return (canEvaluateInLeft, canEvaluateInRight, haveToEvaluateInBoth)
   */</span>
  <span class="token keyword">private</span> def <span class="token function">split</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">Expression</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">,</span> right<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    val <span class="token punctuation">(</span>leftEvaluateCondition<span class="token punctuation">,</span> rest<span class="token punctuation">)</span> <span class="token operator">=</span>
        condition<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>references subsetOf left<span class="token punctuation">.</span>outputSet<span class="token punctuation">)</span>
    val <span class="token punctuation">(</span>rightEvaluateCondition<span class="token punctuation">,</span> commonCondition<span class="token punctuation">)</span> <span class="token operator">=</span>
        rest<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>references subsetOf right<span class="token punctuation">.</span>outputSet<span class="token punctuation">)</span>

    <span class="token punctuation">(</span>leftEvaluateCondition<span class="token punctuation">,</span> rightEvaluateCondition<span class="token punctuation">,</span> commonCondition<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token comment">// push the where condition down into join filter</span>
    <span class="token keyword">case</span> f @ <span class="token class-name">Filter</span><span class="token punctuation">(</span>filterCondition<span class="token punctuation">,</span> <span class="token class-name">Join</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> joinCondition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      val <span class="token punctuation">(</span>leftFilterConditions<span class="token punctuation">,</span> rightFilterConditions<span class="token punctuation">,</span> commonFilterCondition<span class="token punctuation">)</span> <span class="token operator">=</span>
        <span class="token function">split</span><span class="token punctuation">(</span><span class="token function">splitConjunctivePredicates</span><span class="token punctuation">(</span>filterCondition<span class="token punctuation">)</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>

      joinType match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Inner</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the single side `where` condition into respective sides</span>
          val newLeft <span class="token operator">=</span> leftFilterConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
          val newRight <span class="token operator">=</span> rightFilterConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
          val newJoinCond <span class="token operator">=</span> <span class="token punctuation">(</span>commonFilterCondition <span class="token operator">++</span> joinCondition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span>

          <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> <span class="token class-name">Inner</span><span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token class-name">RightOuter</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the right side only `where` condition</span>
          val newLeft <span class="token operator">=</span> left
          val newRight <span class="token operator">=</span> rightFilterConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
          val newJoinCond <span class="token operator">=</span> joinCondition
          val newJoin <span class="token operator">=</span> <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> <span class="token class-name">RightOuter</span><span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>

          <span class="token punctuation">(</span>leftFilterConditions <span class="token operator">++</span> commonFilterCondition<span class="token punctuation">)</span><span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> newJoin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>newJoin<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ @ <span class="token punctuation">(</span><span class="token class-name">LeftOuter</span> <span class="token operator">|</span> <span class="token class-name">LeftSemi</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the left side only `where` condition</span>
          val newLeft <span class="token operator">=</span> leftFilterConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
          val newRight <span class="token operator">=</span> right
          val newJoinCond <span class="token operator">=</span> joinCondition
          val newJoin <span class="token operator">=</span> <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>

          <span class="token punctuation">(</span>rightFilterConditions <span class="token operator">++</span> commonFilterCondition<span class="token punctuation">)</span><span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> newJoin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>newJoin<span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token class-name">FullOuter</span> <span class="token operator">=</span><span class="token operator">&gt;</span> f <span class="token comment">// DO Nothing for Full Outer Join</span>
      <span class="token punctuation">}</span>

    <span class="token comment">// push down the join filter into sub query scanning if applicable</span>
    <span class="token keyword">case</span> f @ <span class="token class-name">Join</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> joinCondition<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      val <span class="token punctuation">(</span>leftJoinConditions<span class="token punctuation">,</span> rightJoinConditions<span class="token punctuation">,</span> commonJoinCondition<span class="token punctuation">)</span> <span class="token operator">=</span>
        <span class="token function">split</span><span class="token punctuation">(</span>joinCondition<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>splitConjunctivePredicates<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>

      joinType match <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Inner</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the single side only join filter for both sides sub queries</span>
          val newLeft <span class="token operator">=</span> leftJoinConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
          val newRight <span class="token operator">=</span> rightJoinConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
          val newJoinCond <span class="token operator">=</span> commonJoinCondition<span class="token punctuation">.</span><span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span>

          <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> <span class="token class-name">Inner</span><span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token class-name">RightOuter</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the left side only join filter for left side sub query</span>
          val newLeft <span class="token operator">=</span> leftJoinConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
          val newRight <span class="token operator">=</span> right
          val newJoinCond <span class="token operator">=</span> <span class="token punctuation">(</span>rightJoinConditions <span class="token operator">++</span> commonJoinCondition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span>

          <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> <span class="token class-name">RightOuter</span><span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>
        <span class="token keyword">case</span> _ @ <span class="token punctuation">(</span><span class="token class-name">LeftOuter</span> <span class="token operator">|</span> <span class="token class-name">LeftSemi</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
          <span class="token comment">// push down the right side only join filter for right sub query</span>
          val newLeft <span class="token operator">=</span> left
          val newRight <span class="token operator">=</span> rightJoinConditions<span class="token punctuation">.</span>
            <span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Filter</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
          val newJoinCond <span class="token operator">=</span> <span class="token punctuation">(</span>leftJoinConditions <span class="token operator">++</span> commonJoinCondition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduceLeftOption</span><span class="token punctuation">(</span><span class="token class-name">And</span><span class="token punctuation">)</span>

          <span class="token class-name">Join</span><span class="token punctuation">(</span>newLeft<span class="token punctuation">,</span> newRight<span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> newJoinCond<span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token class-name">FullOuter</span> <span class="token operator">=</span><span class="token operator">&gt;</span> f
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="columnpruning"><a href="#columnpruning" class="header-anchor">#</a> ColumnPruning</h5> <p>列裁剪用的比较多，就是减少不必要select的某些列。列裁剪在3种地方可以用：</p> <ol><li>在聚合操作中，可以做列裁剪</li> <li>在join操作中，左右孩子可以做列裁剪</li> <li>合并相邻的Project的列</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * Attempts to eliminate the reading of unneeded columns from the query plan using the following
 * transformations:
 *
 *  - Inserting Projections beneath the following operators:
 *   - Aggregate
 *   - Project &lt;- Join
 *   - LeftSemiJoin
 *  - Collapse adjacent projections, performing alias substitution.
 */</span>
object <span class="token class-name">ColumnPruning</span> <span class="token keyword">extends</span> <span class="token class-name">Rule</span><span class="token punctuation">[</span><span class="token class-name">LogicalPlan</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  def <span class="token function">apply</span><span class="token punctuation">(</span>plan<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">LogicalPlan</span> <span class="token operator">=</span> plan transform <span class="token punctuation">{</span>
    <span class="token comment">// Eliminate attributes that are not needed to calculate the specified aggregates.</span>
    <span class="token keyword">case</span> a @ <span class="token class-name">Aggregate</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>outputSet <span class="token operator">--</span> a<span class="token punctuation">.</span>references<span class="token punctuation">)</span><span class="token punctuation">.</span>nonEmpty <span class="token operator">=</span><span class="token operator">&gt;</span>
      a<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>child <span class="token operator">=</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>references<span class="token punctuation">.</span>toSeq<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// Eliminate unneeded attributes from either side of a Join.</span>
    <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> <span class="token class-name">Join</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token comment">// Collect the list of all references required either above or to evaluate the condition.</span>
      val allReferences<span class="token operator">:</span> <span class="token class-name">AttributeSet</span> <span class="token operator">=</span>
        <span class="token class-name">AttributeSet</span><span class="token punctuation">(</span>
          projectList<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>references<span class="token punctuation">.</span>iterator<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span>
          condition<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>references<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token class-name">AttributeSet</span><span class="token punctuation">(</span><span class="token class-name">Seq</span><span class="token punctuation">.</span>empty<span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token comment">/** Applies a projection only when the child is producing unnecessary attributes */</span>
      def <span class="token function">pruneJoinChild</span><span class="token punctuation">(</span>c<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">prunedChild</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> allReferences<span class="token punctuation">)</span>

      <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> <span class="token class-name">Join</span><span class="token punctuation">(</span><span class="token function">pruneJoinChild</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pruneJoinChild</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> joinType<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment">// Eliminate unneeded attributes from right side of a LeftSemiJoin.</span>
    <span class="token keyword">case</span> <span class="token class-name">Join</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> <span class="token class-name">LeftSemi</span><span class="token punctuation">,</span> condition<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token comment">// Collect the list of all references required to evaluate the condition.</span>
      val allReferences<span class="token operator">:</span> <span class="token class-name">AttributeSet</span> <span class="token operator">=</span>
        condition<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>references<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token class-name">AttributeSet</span><span class="token punctuation">(</span><span class="token class-name">Seq</span><span class="token punctuation">.</span>empty<span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token class-name">Join</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token function">prunedChild</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> allReferences<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LeftSemi</span><span class="token punctuation">,</span> condition<span class="token punctuation">)</span>

    <span class="token comment">// Combine adjacent Projects.</span>
    <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList1<span class="token punctuation">,</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList2<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span>
      <span class="token comment">// Create a map of Aliases to their values from the child projection.</span>
      <span class="token comment">// e.g., 'SELECT ... FROM (SELECT a + b AS c, d ...)' produces Map(c -&gt; Alias(a + b, c)).</span>
      val aliasMap <span class="token operator">=</span> projectList2<span class="token punctuation">.</span>collect <span class="token punctuation">{</span>
        <span class="token keyword">case</span> a @ <span class="token class-name">Alias</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>toAttribute<span class="token operator">:</span> <span class="token class-name">Expression</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">.</span>toMap

      <span class="token comment">// Substitute any attributes that are produced by the child projection, so that we safely</span>
      <span class="token comment">// eliminate it.</span>
      <span class="token comment">// e.g., 'SELECT c + 1 FROM (SELECT a + b AS C ...' produces 'SELECT a + b + 1 ...'</span>
      <span class="token comment">// TODO: Fix TransformBase to avoid the cast below.</span>
      val substitutedProjection <span class="token operator">=</span> projectList1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>transform <span class="token punctuation">{</span>
        <span class="token keyword">case</span> a <span class="token keyword">if</span> aliasMap<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">aliasMap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asInstanceOf<span class="token punctuation">[</span><span class="token class-name">Seq</span><span class="token punctuation">[</span><span class="token class-name">NamedExpression</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

      <span class="token class-name">Project</span><span class="token punctuation">(</span>substitutedProjection<span class="token punctuation">,</span> child<span class="token punctuation">)</span>

    <span class="token comment">// Eliminate no-op Projects</span>
    <span class="token keyword">case</span> <span class="token class-name">Project</span><span class="token punctuation">(</span>projectList<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token keyword">if</span> child<span class="token punctuation">.</span>output <span class="token operator">==</span> projectList <span class="token operator">=</span><span class="token operator">&gt;</span> child
  <span class="token punctuation">}</span>

  <span class="token comment">/** Applies a projection only when the child is producing unnecessary attributes */</span>
  <span class="token keyword">private</span> def <span class="token function">prunedChild</span><span class="token punctuation">(</span>c<span class="token operator">:</span> <span class="token class-name">LogicalPlan</span><span class="token punctuation">,</span> allReferences<span class="token operator">:</span> <span class="token class-name">AttributeSet</span><span class="token punctuation">)</span> <span class="token operator">=</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>outputSet <span class="token operator">--</span> allReferences<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>outputSet<span class="token punctuation">.</span>contains<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Project</span><span class="token punctuation">(</span>allReferences<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>outputSet<span class="token punctuation">.</span>contains<span class="token punctuation">)</span><span class="token punctuation">.</span>toSeq<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      c
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_6-总结"><a href="#_6-总结" class="header-anchor">#</a> 6. 总结</h2> <p>在log4j.properies里面设置<code>log4j.rootCategory=TRACE, console</code>可以将Catalyst详细的优化过程打印到Console中。</p> <div class="language- extra-class"><pre class="language-text"><code>sql( s&quot;&quot;&quot;
        |SELECT name
        |FROM (SELECT name, age FROM rddTable) p
        |WHERE p.age &gt;= 13 AND p.age &lt;= 19
        |&quot;&quot;&quot;.stripMargin).queryExecution
</code></pre></div><p>拿上面这句sql查询为例，它会经过以下几个优化过程。</p> <p><strong>1: Analyzer阶段 (Batch Resolution)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>=== Applying Rule org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveRelations ===
 'Project ['name]                                'Project ['name]
  'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))    'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))
   'Subquery p                                     'Subquery p
    'Project ['name,'age]                           'Project ['name,'age]
!    'UnresolvedRelation None, rddTable, None        Subquery rddTable
!                                                     LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36

=== Applying Rule org.apache.spark.sql.catalyst.analysis.Analyzer$ResolveReferences ===
!'Project ['name]                                                                               Project [name#0]
! 'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))                                                   Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  'Subquery p                                                                                    Subquery p
!   'Project ['name,'age]                                                                          Project [name#0,age#1]
     Subquery rddTable                                                                              Subquery rddTable
      LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36        LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36

=== Result of Batch Resolution ===
!'Project ['name]                                Project [name#0]
! 'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))    Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  'Subquery p                                     Subquery p
!   'Project ['name,'age]                           Project [name#0,age#1]
!    'UnresolvedRelation None, rddTable, None        Subquery rddTable
!                                                     LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
</code></pre></div><p><strong>2: Analyzer阶段 (Batch AnalysisOperators)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>=== Applying Rule org.apache.spark.sql.catalyst.analysis.EliminateAnalysisOperators ===
 Project [name#0]                                                                               Project [name#0]
  Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))                                                        Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  Subquery p                                                                                     Project [name#0,age#1]
!   Project [name#0,age#1]                                                                         LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
!    Subquery rddTable
!     LogicalRDD [name#0,age#1], MapPartitionsRDD[4]at mapPartitions at ExistingRDD.scala:36

=== Result of Batch AnalysisOperators ===
!'Project ['name]                                Project [name#0]
! 'Filter (('p.age. &gt;= 13) &amp;&amp; ('p.age. &lt;= 19))    Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  'Subquery p                                     Project [name#0,age#1]
!   'Project ['name,'age]                           LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
!    'UnresolvedRelation None, rddTable, None
</code></pre></div><p><strong>3: Optimizer阶段 (Batch Filter Pushdown)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>=== Applying Rule org.apache.spark.sql.catalyst.optimizer.PushPredicateThroughProject ===
 Project [name#0]                                                                             Project [name#0]
! Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))                                                      Project [name#0,age#1]
!  Project [name#0,age#1]                                                                       Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
    LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36      LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36

=== Applying Rule org.apache.spark.sql.catalyst.optimizer.ColumnPruning ===
 Project [name#0]                                                                             Project [name#0]
! Project [name#0,age#1]                                                                       Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))                                                      LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
!   LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36

=== Result of Batch Filter Pushdown ===
 Project [name#0]                                                                             Project [name#0]
  Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))                                                      Filter ((age#1 &gt;= 13) &amp;&amp; (age#1 &lt;= 19))
!  Project [name#0,age#1]                                                                       LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
!   LogicalRDD [name#0,age#1], MapPartitionsRDD[4] at mapPartitions at ExistingRDD.scala:36
</code></pre></div><p>Catalyst优化器里面的各种规则互相配合，最后把一个Unresolved Logical Plan优化为一个Optimized Logical Plan。</p> <h2 id="_99-spark-sql的性能"><a href="#_99-spark-sql的性能" class="header-anchor">#</a> 99. Spark SQL的性能</h2> <p>摆脱了Hive限制的SparkSQL的性能在Shark的基础上又有了长足的进步。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/SparkSQL-vs-Shark.png" alt="img"></p> <p>SparkSQL主要在下面几点做了性能上的优化：</p> <h4 id="_1-内存列存储-in-memory-columnar-storage"><a href="#_1-内存列存储-in-memory-columnar-storage" class="header-anchor">#</a> 1. 内存列存储(In-Memory Columnar Storage)</h4> <p>SparkSQL继承了Shark的内存列存储，内存列存储有诸多好处：</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/column-store.png" alt="img"></p> <ol><li>GC友好：行存储的情况下每一行会产出一个java对象，而列存储每一列才会产生一个对象，在大数据的情况下，行存储会对GC产生巨大的压力。</li> <li>压缩友好：相同数据类型的数据在内存中存放在一起，有利于压缩。</li> <li>Cache友好：分析查询中频繁使用的聚合特定列，性能会得到很大的提高，原因就是这些列的数据放在一起，更容易读入内存进行计算。</li></ol> <p>SparkSQL1.2中把每个列又分成多个batch，这样就可以避免在加载large table的时候出现OOM。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/column-store2.png" alt="img"></p> <h4 id="_2-code-generation"><a href="#_2-code-generation" class="header-anchor">#</a> 2. Code Generation</h4> <p>在数据库查询中有一个昂贵的操作是查询语句中的表达式，主要是由于JVM的内存模型引起的。比如如下一个查询：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> a <span class="token operator">+</span> b <span class="token keyword">FROM</span> <span class="token keyword">table</span>
</code></pre></div><p>在这个查询里，如果采用通用的SQL语法途径去处理，会先生成一个表达式树（有两个节点的Add树，参考后面章节），在物理处理这个表达式树的时候，将会如图所示的7个步骤：</p> <ol><li>调用虚函数Add.eval()，需要确认Add两边的数据类型</li> <li>调用虚函数a.eval()，需要确认a的数据类型</li> <li>确定a的数据类型是Int，装箱</li> <li>调用虚函数b.eval()，需要确认b的数据类型</li> <li>确定b的数据类型是Int，装箱</li> <li>调用Int类型的Add</li> <li>返回装箱后的计算结果 其中多次涉及到虚函数的调用，虚函数的调用会打断CPU的正常流水线处理，减缓执行。</li></ol> <p>Spark1.1.0在catalyst模块的expressions增加了codegen模块，如果使用动态字节码生成技术（配置spark.sql.codegen参数），sparkSQL在执行物理计划的时候，对匹配的表达式采用特定的代码，动态编译，然后运行。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/code-generation.png" alt="img"></p> <p>如上图中的例子，开启CG后，SparkSQL最终实现效果类似如下伪代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>val a<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> inputRow<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
val b<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> inputRow<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
val result<span class="token operator">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> a <span class="token operator">+</span> b
resultRow<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
</code></pre></div><p>CG优化的实现主要还是依靠scala2.10的reflection和Quasiquotes。CG的性能对比如下图：</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/code-generation2.png" alt="img"></p> <h4 id="_3-外部数据源predicate-pushdown"><a href="#_3-外部数据源predicate-pushdown" class="header-anchor">#</a> 3. 外部数据源Predicate pushdown</h4> <p>SparkSQL1.2.0可以在读取外部数据以后马上进行filter操作，以减少网络传输的数据量；对于Parquet和ORC类型的数据，SparkSQL甚至可以在读取数据的时候就进行某些filter操作，以减少磁盘IO。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/predicate-pushdown1.png" alt="img"> <img src="http://marsishandsome.github.io/SparkSQL-Internal/images/predicate-pushdown2.png" alt="img"> <img src="http://marsishandsome.github.io/SparkSQL-Internal/images/predicate-pushdown3.png" alt="img"></p> <p>主要有两种过滤数据的方式，分别为Column Pruning和Predicte pushdown，分别是针对列和行的过滤。</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/column-pruning.png" alt="img"></p> <h4 id="_4-scala代码优化"><a href="#_4-scala代码优化" class="header-anchor">#</a> 4. Scala代码优化</h4> <p>SparkSQL在使用Scala编写代码的时候，尽量避免低效的、容易GC的代码；尽管增加了编写代码的难度，但对于用户来说，还是使用统一的接口，没受到使用上的困难。下图是一个scala代码优化的示意图：</p> <p><img src="http://marsishandsome.github.io/SparkSQL-Internal/images/scala-code.png" alt="img"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./bigdata/spark/" class="prev router-link-active">
        目录
      </a></span> <span class="next"><a href="/./bigdata/spark/SparkSQL开窗函数.html">
        SparkSQL开窗函数
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.9ce0d262.js" defer></script><script src="./assets/js/2.fa5f1a4a.js" defer></script><script src="./assets/js/59.4d5f847f.js" defer></script>
  </body>
</html>
