<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《ClickHouse原理解析与应用实践》阅读笔记 | 大数据技术文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="./favicon.ico">
    <meta name="description" content="从入门到入土">
    
    <link rel="preload" href="./assets/css/0.styles.f7e1aa75.css" as="style"><link rel="preload" href="./assets/js/app.21b076a1.js" as="script"><link rel="preload" href="./assets/js/2.47c06342.js" as="script"><link rel="preload" href="./assets/js/8.df68a8bb.js" as="script"><link rel="prefetch" href="./assets/js/10.2aa77bcb.js"><link rel="prefetch" href="./assets/js/11.217749e8.js"><link rel="prefetch" href="./assets/js/12.319ead69.js"><link rel="prefetch" href="./assets/js/3.38a873a8.js"><link rel="prefetch" href="./assets/js/4.003ef9d4.js"><link rel="prefetch" href="./assets/js/5.fe0d05ee.js"><link rel="prefetch" href="./assets/js/6.81b9d3e2.js"><link rel="prefetch" href="./assets/js/7.f0edcf91.js"><link rel="prefetch" href="./assets/js/9.6ce7954a.js">
    <link rel="stylesheet" href="./assets/css/0.styles.f7e1aa75.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">大数据技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./java/java-base.html" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java网络编程
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase.html" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  ClickHouse
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb.html" class="nav-link">
  TiDB
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/datahouse-base.html" class="nav-link">
  数仓基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/ad.html" class="nav-link">
  商业化基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架" class="dropdown-title"><span class="title">大数据框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架" class="mobile-dropdown-title"><span class="title">大数据框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop.html" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark.html" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink.html" class="nav-link">
  Flink
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据组件" class="dropdown-title"><span class="title">大数据组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据组件" class="mobile-dropdown-title"><span class="title">大数据组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hive.html" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper.html" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/tidb.html" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><a href="https://www.memorydrive.online" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./java/java-base.html" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/./java/" class="nav-link">
  Java网络编程
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase.html" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  ClickHouse
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb.html" class="nav-link">
  TiDB
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/datahouse-base.html" class="nav-link">
  数仓基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/ad.html" class="nav-link">
  商业化基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架" class="dropdown-title"><span class="title">大数据框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架" class="mobile-dropdown-title"><span class="title">大数据框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop.html" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark.html" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink.html" class="nav-link">
  Flink
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据组件" class="dropdown-title"><span class="title">大数据组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据组件" class="mobile-dropdown-title"><span class="title">大数据组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hive.html" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper.html" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/tidb.html" class="nav-link">
  kafka
</a></li></ul></div></div><div class="nav-item"><a href="https://www.memorydrive.online" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>《ClickHouse原理解析与应用实践》阅读笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./database/clickhouse.html#第2章-clickhouse架构概述" class="sidebar-link">第2章 ClickHouse架构概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_2-1-clickhouse的核心特性" class="sidebar-link">2.1 ClickHouse的核心特性</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_2-2-clickhouse的架构设计" class="sidebar-link">2.2 ClickHouse的架构设计</a></li></ul></li><li><a href="/./database/clickhouse.html#第3章-安装与部署-略" class="sidebar-link">第3章 安装与部署（略）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/./database/clickhouse.html#第4章-数据定义" class="sidebar-link">第4章 数据定义</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_4-1-数据类型" class="sidebar-link">4.1 数据类型</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_4-2-如何定义数据表" class="sidebar-link">4.2 如何定义数据表</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_4-5-分布式ddl执行" class="sidebar-link">4.5 分布式DDL执行</a></li></ul></li><li><a href="/./database/clickhouse.html#第5章-数据字典" class="sidebar-link">第5章 数据字典</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/./database/clickhouse.html#第6章-mergetree原理解析" class="sidebar-link">第6章 MergeTree原理解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-1-mergetree的创建方式与存储结构" class="sidebar-link">6.1 MergeTree的创建方式与存储结构</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-2-数据分区" class="sidebar-link">6.2 数据分区</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-3-一级索引" class="sidebar-link">6.3 一级索引</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-4-二级索引" class="sidebar-link">6.4 二级索引</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-5-数据存储" class="sidebar-link">6.5 数据存储</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-6-数据标记" class="sidebar-link">6.6 数据标记</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_6-7-对于分区、索引、标记和压缩数据的协同总结" class="sidebar-link">6.7 对于分区、索引、标记和压缩数据的协同总结</a></li></ul></li><li><a href="/./database/clickhouse.html#第9章-数据查询" class="sidebar-link">第9章 数据查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-3-sample语句" class="sidebar-link">9.3 SAMPLE语句</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-4-array-join子句" class="sidebar-link">9.4 ARRAY JOIN子句</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-5-join子句" class="sidebar-link">9.5 JOIN子句</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-6-where与prewhere子句" class="sidebar-link">9.6 WHERE与PREWHERE子句</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-7-group-by子句" class="sidebar-link">9.7 GROUP BY子句</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_9-10-limit-by子句" class="sidebar-link">9.10 LIMIT BY子句</a></li></ul></li><li><a href="/./database/clickhouse.html#第10章" class="sidebar-link">第10章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_10-1-概述" class="sidebar-link">10.1 概述</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_10-2-数据副本" class="sidebar-link">10.2 数据副本</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_10-3-replicatedmergetree原理解析" class="sidebar-link">10.3 ReplicatedMergeTree原理解析</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_10-4-数据分片" class="sidebar-link">10.4 数据分片</a></li><li class="sidebar-sub-header"><a href="/./database/clickhouse.html#_10-5-distributed原理解析" class="sidebar-link">10.5 Distributed原理解析</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《clickhouse原理解析与应用实践》阅读笔记"><a href="#《clickhouse原理解析与应用实践》阅读笔记" class="header-anchor">#</a> 《ClickHouse原理解析与应用实践》阅读笔记</h1> <h2 id="第2章-clickhouse架构概述"><a href="#第2章-clickhouse架构概述" class="header-anchor">#</a> 第2章 ClickHouse架构概述</h2> <h3 id="_2-1-clickhouse的核心特性"><a href="#_2-1-clickhouse的核心特性" class="header-anchor">#</a> 2.1 ClickHouse的核心特性</h3> <h4 id="_2-1-2-列式存储与数据压缩"><a href="#_2-1-2-列式存储与数据压缩" class="header-anchor">#</a> 2.1.2 列式存储与数据压缩</h4> <p>行式存储：逐行扫描</p> <p>列式存储：逐列扫描</p> <h4 id="_2-1-3-向量化执行引擎"><a href="#_2-1-3-向量化执行引擎" class="header-anchor">#</a> 2.1.3 向量化执行引擎</h4> <p>向量化执行引擎：一项消除程序循环的优化
（原理上类似增加空间复杂度减少时间复杂度）</p> <p>通过CPU的SIMD指令（Single Instruction Multiple Data,SIMD）即用单条指令操作多条数据，从而通过数据并行以提高性能，它的原理是在CPU寄存器层面实现数据的并行操作。</p> <blockquote><p>ClickHouse目前用SSE4.2指令集实现向量化执行</p></blockquote> <h4 id="_2-1-4-关系模型与sql查询"><a href="#_2-1-4-关系模型与sql查询" class="header-anchor">#</a> 2.1.4 关系模型与SQL查询</h4> <p>相比HBase和Redis这类NoSQL数据库，ClickHouse使用关系模型描述并提供了传统数据库的概念（数据库、表、视图、函数等）。此外ClickHouse完全使用SQL作为查询语言。</p> <h4 id="_2-1-5-表引擎"><a href="#_2-1-5-表引擎" class="header-anchor">#</a> 2.1.5 表引擎</h4> <p>ClickHouse共拥有合并树、内存、文件、接口和其他等6大类20多种的表引擎。</p> <h4 id="_2-1-7-多主架构"><a href="#_2-1-7-多主架构" class="header-anchor">#</a> 2.1.7 多主架构</h4> <p>不同于HDFS、Spark、ElasticSearch这类采用主从架构（Master-Slave）的分布式系统，ClickHouse采用多主架构（Multi-Master）。</p> <h4 id="_2-1-8-在线查询"><a href="#_2-1-8-在线查询" class="header-anchor">#</a> 2.1.8 在线查询</h4> <p>在线查询（好像就是即席查询，指用户临时写的查询语句并且需要立刻得到返回结果）</p> <p>ClickHouse在在线查询方面很快（相比Hive、Spark SQL），而且开源（Vertica性能很好，但是价格很高）</p> <h4 id="_2-1-9-数据分片与分布式查询"><a href="#_2-1-9-数据分片与分布式查询" class="header-anchor">#</a> 2.1.9 数据分片与分布式查询</h4> <ul><li><p>数据分片</p> <p>分片是一种大数据处理下的分治思想，ClickHouse支持数据分片。</p> <p>一个集群由1到多个分片组成，每个分片对应ClickHouse的1个服务节点（故数据分片数量取决于ClickHouse服务节点数）</p></li> <li><p>分布式查询</p> <p>ClickHouse提供本地表（Local Tabel）和分布式表（Distributed Table）。</p> <p>本地表等同于一份数据分片</p> <p>分布式表不存储数据，它是本地表的代理访问，类似分库中间件，能够代理访问多个数据分片，从而实现分布式查询。ClickHouse</p></li></ul> <h3 id="_2-2-clickhouse的架构设计"><a href="#_2-2-clickhouse的架构设计" class="header-anchor">#</a> 2.2 ClickHouse的架构设计</h3> <h4 id="_2-2-1-column和field"><a href="#_2-2-1-column和field" class="header-anchor">#</a> 2.2.1 Column和Field</h4> <p>ClickHouse按列存储数据，内存中一列数据由一个Column对象表示；Column采用泛化的设计模式。</p> <p>ClickHouse都会以整列的方式操作数据，除非需要操作具体单个的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值；Field采用聚合的设计模式，内部聚合了Null、UInt64、String、Array等13种数据类型及相应的处理逻辑。</p> <h4 id="_2-2-2-datatype"><a href="#_2-2-2-datatype" class="header-anchor">#</a> 2.2.2 DataType</h4> <p>ClickHouse数据的序列化和反序列化工作由DataType负责。IDataType采用泛华的设计模式，支持二进制、文本、json、xml、csv、protobuf等多种格式。</p> <h4 id="_2-2-3-block和block流"><a href="#_2-2-3-block和block流" class="header-anchor">#</a> 2.2.3 Block和Block流</h4> <p>Column和Filed组成了数据的基本映射单元，但对应实际操作中缺少了必要补充信息，所以ClickHouse设计了Block。</p> <p>Block对象本质是由数据对象、数据类型和列名称组成的三元组，即（Column，DataType，列名称字符串）。</p> <p>Column提供数据读取能力，DataType负责正反序列化，所以Block在这些对象的基础上实现了进一步的抽象和封装，使得仅通过Block对象就能完成一系列的数据操作（Block并没有直接聚合Column和DataType对象，而是间接引用）。</p> <p>Block流有两个顶层接口，分别是IBlockInputStream和IBlockOutputStream，每个顶层接口又有很多类方法。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h4 id="_2-2-4-table"><a href="#_2-2-4-table" class="header-anchor">#</a> 2.2.4 Table</h4> <p>数据表的底层设计中并没有所谓的Table对象，它直接使用<code>IStorage接口</code>指代数据表。</p> <p>IStorage定义了DDL（如ALTER、RENAME、OPTIMIZE、DROP等）、read、write方法，它们分别负责数据的定义、查询、写入。</p> <p>对Table发起的一次操作通常都会经历这样的过程：接收AST查询语句（抽象语法树，简称AST），根据AST返回指定列的数据，之后再将数据交由Interpreter做进一步处理。</p> <h4 id="_2-2-5-parser和interpreter"><a href="#_2-2-5-parser和interpreter" class="header-anchor">#</a> 2.2.5 Parser和Interpreter</h4> <p>Parser负责创建AST对象（将SQL以递归下降的方法发解析成AST语法树）；Interpreter负责解释AST，并进一步创建查询的执行管道（起到串联查询过程的作用，会根据解释器的雷系聚合它所需要的资源）。</p> <h4 id="_2-2-6-functions和aggregate-functions"><a href="#_2-2-6-functions和aggregate-functions" class="header-anchor">#</a> 2.2.6 Functions和Aggregate Functions</h4> <p>ClickHouse主要提供两类函数：普通函数（无状态）和聚合函数（有状态）。</p> <p>普通函数由IFunctions定义，聚合函数由IAggregateFunctions接口定义，并支持序列化和反序列化。</p> <h4 id="_2-2-7-cluster和replication"><a href="#_2-2-7-cluster和replication" class="header-anchor">#</a> 2.2.7 Cluster和Replication</h4> <p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成，其具有以下特性：</p> <ol><li>ClickHouse的1个节点只能拥有1个分片</li> <li>分片只是一个逻辑概念，其物理承载还是由副本承担。</li></ol> <h2 id="第3章-安装与部署-略"><a href="#第3章-安装与部署-略" class="header-anchor">#</a> 第3章 安装与部署（略）</h2> <h2 id="第4章-数据定义"><a href="#第4章-数据定义" class="header-anchor">#</a> 第4章 数据定义</h2> <h3 id="_4-1-数据类型"><a href="#_4-1-数据类型" class="header-anchor">#</a> 4.1 数据类型</h3> <ul><li>基础类型</li></ul> <table><thead><tr><th>基础类型</th> <th>具体类型</th></tr></thead> <tbody><tr><td>数值类型</td> <td>Int、Float、Decimal</td></tr> <tr><td>字符串类型</td> <td>String、FixedString、UUID</td></tr> <tr><td>时间类型</td> <td>DateTime、DateTime64、Date</td></tr></tbody></table> <ul><li><p>复合类型</p> <ol><li>Array</li> <li>Tuple</li> <li>Enum</li> <li>Nested</li></ol></li> <li><p>特殊类型</p> <ol><li>Nullable</li> <li>Domain</li></ol></li></ul> <h3 id="_4-2-如何定义数据表"><a href="#_4-2-如何定义数据表" class="header-anchor">#</a> 4.2 如何定义数据表</h3> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> db_name <span class="token punctuation">[</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> Oridinary<span class="token punctuation">]</span>
</code></pre></div><p>ENGINE处的参数表示数据库所使用的引擎，一共有五种：</p> <ul><li>Oridinary：默认引擎，大部分情况都用这个</li> <li>Dictionary：字典引擎</li> <li>Memory：内存引擎</li> <li>Lazy：日志引擎</li> <li>MySQL：MySQL引擎</li></ul> <h3 id="_4-5-分布式ddl执行"><a href="#_4-5-分布式ddl执行" class="header-anchor">#</a> 4.5 分布式DDL执行</h3> <p>普通DDL语句转化为分布式DDL语句，只需加上<code>ON CLUSTER cluster_name</code>声明即可，如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t1 <span class="token keyword">ON</span> CLUSTER ch_cluster <span class="token punctuation">(</span>
	id String<span class="token punctuation">,</span>
    url String<span class="token punctuation">,</span>
    EventTime <span class="token keyword">Date</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> toYYYYMM<span class="token punctuation">(</span>EventTime<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id
</code></pre></div><p>该语句会对ch_cluster集群内所有节点广播这条DDL语句</p> <h2 id="第5章-数据字典"><a href="#第5章-数据字典" class="header-anchor">#</a> 第5章 数据字典</h2> <p>数据字典是ClickHouse提供的一种存储介质，它以（键值，属性映射）的形式定义数据。</p> <p>数据字典被<strong>加载到内存</strong>，支持动态更新，因而数据字典非常适合保存常量或者经常使用的维度表数据，以避免不必要的JOIN查询。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>字典中的数据只能通过<strong>字典函数</strong>访问（有一种例外情况，就是使用特殊的字典表引擎）</p> <ul><li>7种类型字典的特点总结</li></ul> <table><thead><tr><th>名称</th> <th>存储结构</th> <th>字典键类型</th> <th>支持的数据来源</th></tr></thead> <tbody><tr><td>flat</td> <td>数组</td> <td>UInt64</td> <td>Local file、 Executable file、 HTTP、DBMS</td></tr> <tr><td>hashed</td> <td>散列</td> <td>UInt64</td> <td>Local file、 Executable file、 HTTP、DBMS</td></tr> <tr><td>range_hashed</td> <td>散列并按时间排序</td> <td>UInt64和时间</td> <td>Local file、 Executable file、 HTTP、DBMS</td></tr> <tr><td>complex_key_hashed</td> <td>散列</td> <td>复合型Key</td> <td>Local file、 Executable file、 HTTP、DBMS</td></tr> <tr><td>ip_trie</td> <td>层次结构</td> <td>复合型Key（单个String）</td> <td>Local file、 Executable file、 HTTP、DBMS</td></tr> <tr><td>cache</td> <td>固定大小数组</td> <td>UInt64</td> <td>Executable file、HTTP、 ClickHouse、MySQL</td></tr> <tr><td>complex_key_cache</td> <td>固定大小数组</td> <td>复合型Key</td> <td>Executable file、HTTP、 ClickHouse、MySQL</td></tr></tbody></table> <h2 id="第6章-mergetree原理解析"><a href="#第6章-mergetree原理解析" class="header-anchor">#</a> 第6章 MergeTree原理解析</h2> <p>表引擎是ClickHouse的一大特色，表引擎决定了一张表的特性，比如数据以何种形式被存储以及如何被加载。</p> <p>合并树（MergeTree）是ClickHouse中最常用的表引擎，因为只有MergeTree系列（MergeTree的变种表引擎有很多）的表引擎才支持<strong>主键索引</strong>、<strong>数据分区</strong>、<strong>数据副本</strong>、<strong>数据采样</strong>这些特性，同时也只有此系列表引擎支持ALTER相关操作。</p> <h3 id="_6-1-mergetree的创建方式与存储结构"><a href="#_6-1-mergetree的创建方式与存储结构" class="header-anchor">#</a> 6.1 MergeTree的创建方式与存储结构</h3> <ul><li><p>MergeTree创建方式</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name <span class="token punctuation">(</span>
	name1 <span class="token punctuation">[</span><span class="token keyword">type</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token operator">|</span>MATERIALIZED<span class="token operator">|</span>ALIAS expr<span class="token punctuation">]</span><span class="token punctuation">,</span>
    name2 <span class="token punctuation">[</span><span class="token keyword">type</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token operator">|</span>MATERIALIZED<span class="token operator">|</span>ALIAS expr<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">--省略 ...</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span>	  <span class="token comment">--选择合并树表引擎</span>
<span class="token punctuation">[</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> expr<span class="token punctuation">]</span>		<span class="token comment">--选填，分区键	</span>
<span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> expr<span class="token punctuation">]</span>			<span class="token comment">--必填，排序键</span>
<span class="token punctuation">[</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> expr<span class="token punctuation">]</span>		<span class="token comment">--选题，主键</span>
<span class="token punctuation">[</span>SAMPLE <span class="token keyword">BY</span> expr<span class="token punctuation">]</span>		<span class="token comment">--选题，抽样表达式</span>
<span class="token punctuation">[</span>SETTINGS name <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">,</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>	<span class="token comment">--index_granularity[选填]，索引粒度，默认8192（每隔8192行生成一条索引）;index_granularity[选填]，每一批写书数据的体量大小，默认10M；enable_mixed_granularity_parts[选填]，设置是否开启自适应索引间隔，默认开启；merge_mixed_with_ttl_timeout[选填]；storage_policy[选填]</span>
</code></pre></div></li> <li><p>MergeTree存储结构</p> <blockquote><div class="language-sql extra-class"><pre class="language-sql"><code>table_name
│
├─partition_1	<span class="token comment">-- 分区目录</span>
│    ├─ checksums<span class="token punctuation">.</span>txt	<span class="token comment">-- 检验文件，二进制格式存储</span>
│    ├─ colums<span class="token punctuation">.</span>txt		<span class="token comment">-- 列文件，明文格式存储，保存该分区下的字段信息</span>
│    ├─ count<span class="token punctuation">.</span>txt		<span class="token comment">-- 计数文件，明文格式存储，记录该分区下数据的总行数</span>
│    ├─ <span class="token keyword">primary</span><span class="token punctuation">.</span>idx		<span class="token comment">-- 一级索引文件，二进制格式存储，用于存放稀疏索引</span>
│    ├─ <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>bin	<span class="token comment">-- 数据文件，压缩格式存储（默认LZ4压缩格式）</span>
│    ├─ <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mrk	<span class="token comment">-- 列字段标记文件，二进制格式存储，保存了.bin文件的数据偏移量</span>
│    ├─ <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mrk2	<span class="token comment">-- 如果使用了适应性大小的间隔索引，作用和原理与.mrk文件相同</span>
│    ├─ <span class="token keyword">partition</span><span class="token punctuation">.</span>dat	<span class="token comment">-- 使用了分区才会生成，保存当前分区表达式最终生成的值</span>
│    ├─ minmax_<span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>idx	<span class="token comment">-- 使用了分区才会生成，记录当前分区原始字段最大值和最小值</span>
│    ├─ skp_idx _<span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>idx	<span class="token comment">-- 使用了二级索引才会生成</span>
│    ├─ skp_idx _<span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mrk	<span class="token comment">-- 使用了二级索引才会生成</span>
│    
└─ partition_2
│ 
└─ partition_n
</code></pre></div></blockquote></li></ul> <h3 id="_6-2-数据分区"><a href="#_6-2-数据分区" class="header-anchor">#</a> 6.2 数据分区</h3> <h4 id="_6-2-1-数据的分区规则"><a href="#_6-2-1-数据的分区规则" class="header-anchor">#</a> 6.2.1 数据的分区规则</h4> <ul><li>ID在不同分区类型下的示例</li></ul> <table><thead><tr><th>类型</th> <th>样例数据</th> <th>分区表达式</th> <th>分区ID</th></tr></thead> <tbody><tr><td>整型</td> <td>18，19，20</td> <td>PARTITION BY Age</td> <td>分区1：18；分区2：19；分区3：20</td></tr> <tr><td>日期</td> <td>2021-05-01，2021-05-2</td> <td>PARTITION BY EventTime</td> <td>分区1：20210501；分区2：20210502</td></tr> <tr><td>其他</td> <td>‘www.nauu.com’</td> <td>PARTITION BY URL</td> <td>分区1：15b31467</td></tr></tbody></table> <h4 id="_6-2-2-分区目录的命名规则"><a href="#_6-2-2-分区目录的命名规则" class="header-anchor">#</a> 6.2.2 分区目录的命名规则</h4> <p>分区目录 = 分区ID（PartitionID）+MaxBlockNum+MinBlockNum+Level</p> <p>例如分区目录是202105_1_1_0</p> <blockquote><p>MaxBlockNum和MinBlockNum是最大数据块编号和最小数据块编号（跟数据压缩的数据压缩块无关）</p></blockquote> <h4 id="_6-2-3-分区目录的合并过程"><a href="#_6-2-3-分区目录的合并过程" class="header-anchor">#</a> 6.2.3 分区目录的合并过程</h4> <p>MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值</p> <p>MaxBlockNum：取同一分区内所有目录中最小的MaxBlockNum值</p> <p>Level：取同一分区内最大Level值并加1</p> <h3 id="_6-3-一级索引"><a href="#_6-3-一级索引" class="header-anchor">#</a> 6.3 一级索引</h3> <h4 id="_6-3-1-稀疏索引"><a href="#_6-3-1-稀疏索引" class="header-anchor">#</a> 6.3.1 稀疏索引</h4> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png" width="50%"></p> <h4 id="_6-3-2-索引粒度"><a href="#_6-3-2-索引粒度" class="header-anchor">#</a> 6.3.2 索引粒度</h4> <p>ClickHouse中索引粒度默认为8192，数据以index_granularity的粒度（默认8192）被标记成多个小的区间，其中每个区间最多8192行数据。</p> <h4 id="_6-3-3-索引数据的生成规则"><a href="#_6-3-3-索引数据的生成规则" class="header-anchor">#</a> 6.3.3 索引数据的生成规则</h4> <p>由于是稀疏索引，所以MergeTree需要间隔 index_granularity 行数据才会生成一条索引记录。</p> <h4 id="_6-3-4-索引的查询过程"><a href="#_6-3-4-索引的查询过程" class="header-anchor">#</a> 6.3.4 索引的查询过程</h4> <p>根据索引粒度生成多个MarkRange，两个相邻的MarkRange相距步长为1，所有MarkRange（整个数据片段）的最大数值区间为[0,+inf]</p> <p>索引查询过程分为3个步骤：</p> <ol><li><p>生成查询条件区间。例如：</p> <p>WHERE ID = 'A003' → ['A003' , 'A003']</p> <p>WHERE ID &gt; 'A003' → ['A003' ,  +inf]</p></li> <li><p>递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断，从最大的区间[0 , +inf]开始：</p> <ul><li>如果不存在交集，则直接通过剪枝算法优化此整段MarkRange</li> <li>如果存在交集，且MarkRange不可再分解（步长小于8），则记录MarkRange并返回</li></ul></li> <li><p>合并MarkRange区间：将最终匹配的MarkRange聚在一起，合并它们的范围。</p></li></ol> <h3 id="_6-4-二级索引"><a href="#_6-4-二级索引" class="header-anchor">#</a> 6.4 二级索引</h3> <p>二级索引又称为跳数索引，默认关闭，开启命令为：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SET</span> allow_experimental_data_skipping_indices <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div><h3 id="_6-5-数据存储"><a href="#_6-5-数据存储" class="header-anchor">#</a> 6.5 数据存储</h3> <h4 id="_6-5-1-各列独立存储"><a href="#_6-5-1-各列独立存储" class="header-anchor">#</a> 6.5.1 各列独立存储</h4> <p>每个字段都有一个对应的.bin文件，这些.bin文件承载着物理存储。</p> <p>存储的具体实现L：数据经过压缩后按照ORDER BY的声明排序，最后数据以压缩数据块的形式被组织写入.bin文件中</p> <h4 id="_6-5-2-压缩数据块"><a href="#_6-5-2-压缩数据块" class="header-anchor">#</a> 6.5.2 压缩数据块</h4> <p>JavaEnable.bin</p> <blockquote><blockquote><p>压缩数据块0</p> <p>hear stat(65536, 12000)</p></blockquote> <blockquote><p>压缩数据块1</p> <p>hear stat(65536, 14660)</p></blockquote> <p>...</p></blockquote> <p>MergeTree在数据具体的写入过程中，会按照索引粒度（默认8192行），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为size，则整个写入过程遵循以下规则：</p> <ol><li>单个批次数据 size &lt; 64KB：继续获取下一个批数据，直至累积到 size &gt;= 64 KB，生成下一个压缩数据块</li> <li>单个批次数据  64 KB &lt;= size &lt;= 1 MB​：直接生成下一个压缩数据块</li> <li>单个批次数据  size &gt;= 1 MB​：先按照1MB大小截断并生成下一个数据块，剩余数据继续依照上述规则执行。</li></ol> <h3 id="_6-6-数据标记"><a href="#_6-6-数据标记" class="header-anchor">#</a> 6.6 数据标记</h3> <p>下面用一个类比来说明数据标记是什么及其作用</p> <blockquote><p>MergeTree表：书</p> <p>primary.idx（一级索引）：章节目录</p> <p>.bin（数据文件）：书中的内容</p> <p>.mrk（数据标记）：章节与内容之间的联系（数据标记记录两个信息：1、页码；2、某段内容起始位置）</p></blockquote> <h3 id="_6-7-对于分区、索引、标记和压缩数据的协同总结"><a href="#_6-7-对于分区、索引、标记和压缩数据的协同总结" class="header-anchor">#</a> 6.7 对于分区、索引、标记和压缩数据的协同总结</h3> <h4 id="_6-7-1-写入过程"><a href="#_6-7-1-写入过程" class="header-anchor">#</a> 6.7.1 写入过程</h4> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png" alt=""></p> <h4 id="_6-7-2-查询过程"><a href="#_6-7-2-查询过程" class="header-anchor">#</a> 6.7.2 查询过程</h4> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png" alt=""></p> <h4 id="_6-7-3-数据标记与压缩数据块的对应关系"><a href="#_6-7-3-数据标记与压缩数据块的对应关系" class="header-anchor">#</a> 6.7.3 数据标记与压缩数据块的对应关系</h4> <ol><li><p>多对一</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png" alt=""></p></li> <li><p>一对一</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png" alt=""></p></li> <li><p>一对多</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png" alt=""></p></li></ol> <h2 id="第9章-数据查询"><a href="#第9章-数据查询" class="header-anchor">#</a> 第9章 数据查询</h2> <h3 id="_9-3-sample语句"><a href="#_9-3-sample语句" class="header-anchor">#</a> 9.3 SAMPLE语句</h3> <p>SAMPLE子句能够实现数据采样的功能，使查询返回采样数而不是全部数据，从而减少查询负载。SAMPLE子句的采样机制是一种<strong>幂等</strong>[^1]设计，所以相同的采样规则能返回相同的数据，这项特性适用于那些可以接受近似查询结果的场景。</p> <p>[^1]: 幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))</p> <p>SAMPLE子句只能用于MergeTree系列引擎的数据表，并且要求在<code>CREATE TABLE</code>时声明<code>SAMPLE BY</code>抽样表达式，例如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> hits_t1 <span class="token punctuation">(</span>
    ID UInt64<span class="token punctuation">,</span>
    EventTime <span class="token keyword">DATE</span><span class="token punctuation">,</span>
    UserID UInt64
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> toYYYYMM<span class="token punctuation">(</span>EventTime<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span>ID<span class="token punctuation">,</span>intHash32<span class="token punctuation">(</span>UserID<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">-- SAMPLE Key声明的表达式必须也包含在主键的声明中</span>
SAMPLE <span class="token keyword">BY</span> intHash32<span class="token punctuation">(</span>UserID<span class="token punctuation">)</span>
</code></pre></div><p><code>SAMPLE BY intHash32(UserID)</code>表示该表内的数据，按照<code>intHash32(UserID)</code>分布后的结果采样查询。</p> <blockquote><p>声明 SAMPLE Key的注意事项：</p> <ol><li>SAMPLE BY 所声明的表达式必须同时包含在主键的声明内；</li> <li>SAMPLE Key 必须是int类型（如果不是，建表时不会报错但会在查询时得到异常）。</li></ol></blockquote> <ul><li><p>SAMPLE factor</p> <p>factor范围在[0,1]，当factor是0或1的时候等同于不采样</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> hits_t1 SAMPLE <span class="token number">0.1</span>
</code></pre></div><p>近似取10%的数据</p></li> <li><p>SAMPLE rows</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> hits_t1 SAMPLE <span class="token number">10000</span>
</code></pre></div><p>近似采样10000行的数据</p></li> <li><p>SAMPLE factor OFFSET n</p> <p>OFFSET 表示偏移量</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> hits_t1 SAMPLE <span class="token number">0.5</span> <span class="token keyword">OFFSET</span> <span class="token number">0.4</span>
</code></pre></div><p>从二分之一处按0.4的系数采样（若出现了溢出则自动截断）</p></li></ul> <h3 id="_9-4-array-join子句"><a href="#_9-4-array-join子句" class="header-anchor">#</a> 9.4 ARRAY JOIN子句</h3> <p>ARRAY JOIN 允许在表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开为多行。（类似Hive里的<code>LATERNAL VIEW EXPLODE</code>函数）</p> <p>例如在表query_t1中：</p> <table><thead><tr><th>id</th> <th>value</th></tr></thead> <tbody><tr><td>1</td> <td>[1,2,3]</td></tr> <tr><td>2</td> <td>[3,4]</td></tr> <tr><td>3</td> <td>[ ]</td></tr></tbody></table> <h4 id="_9-4-1-inner-array-join"><a href="#_9-4-1-inner-array-join" class="header-anchor">#</a> 9.4.1 INNER ARRAY JOIN</h4> <ul><li>demo</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span><span class="token keyword">value</span> <span class="token keyword">FROM</span> query_t1 ARRAY <span class="token keyword">JOIN</span> <span class="token keyword">value</span>
</code></pre></div><p>得到结果：</p> <table><thead><tr><th>id</th> <th>value</th></tr></thead> <tbody><tr><td>1</td> <td>1</td></tr> <tr><td>1</td> <td>2</td></tr> <tr><td>1</td> <td>3</td></tr> <tr><td>2</td> <td>3</td></tr> <tr><td>2</td> <td>4</td></tr></tbody></table> <p>排除掉了空行</p> <blockquote><p>跟Hive的数组行转列很像，Hive中是这样写的：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>v <span class="token keyword">FROM</span> 
LATERNAL <span class="token keyword">VIEW</span> EXPLODE<span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">)</span> table_tmp <span class="token keyword">AS</span> v
</code></pre></div></blockquote> <ul><li>添加别名</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>v <span class="token keyword">FROM</span> query_t1 ARRAY <span class="token keyword">JOIN</span> <span class="token keyword">value</span> <span class="token keyword">AS</span> v
</code></pre></div><p>得到结果：</p> <table><thead><tr><th>id</th> <th>value</th> <th>value</th></tr></thead> <tbody><tr><td>1</td> <td>[1,2,3]</td> <td>1</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>2</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>3</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>3</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>4</td></tr></tbody></table> <h4 id="_9-4-2-left-array-join"><a href="#_9-4-2-left-array-join" class="header-anchor">#</a> 9.4.2 LEFT ARRAY JOIN</h4> <ul><li></li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>v <span class="token keyword">FROM</span> query_t1 ARRAY <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> <span class="token keyword">value</span> <span class="token keyword">AS</span> v
</code></pre></div><p>得到结果：</p> <table><thead><tr><th>id</th> <th>value</th> <th>v</th></tr></thead> <tbody><tr><td>1</td> <td>[1,2,3]</td> <td>1</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>2</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>3</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>3</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>4</td></tr> <tr><td>3</td> <td>[ ]</td> <td>0</td></tr></tbody></table> <p>改为LEFT查询以后，在INNER JOIN 中被排除的空数组出现了在返回的结果集中。</p> <blockquote><p>当同时对多个数组字段进行ARRAY JOIN 操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积，例如</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">,</span>v<span class="token punctuation">,</span>arrayMap<span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> mapv<span class="token punctuation">,</span>v_1 
<span class="token keyword">FROM</span> query_t1 
ARRAY <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> <span class="token keyword">value</span> <span class="token keyword">AS</span> v<span class="token punctuation">,</span>mapv <span class="token keyword">AS</span> v_1
</code></pre></div><p>得到结果：</p> <table><thead><tr><th>id</th> <th>value</th> <th>v</th> <th>mapv</th> <th>v_1</th></tr></thead> <tbody><tr><td>1</td> <td>[1,2,3]</td> <td>1</td> <td>[2,4,6]</td> <td>2</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>2</td> <td>[2,4,6]</td> <td>4</td></tr> <tr><td>1</td> <td>[1,2,3]</td> <td>3</td> <td>[2,4,6]</td> <td>6</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>3</td> <td>[6,8]</td> <td>6</td></tr> <tr><td>2</td> <td>[3,4]</td> <td>4</td> <td>[6,8]</td> <td>8</td></tr> <tr><td>3</td> <td>[ ]</td> <td>0</td> <td>[ ]</td> <td>0</td></tr></tbody></table></blockquote> <h3 id="_9-5-join子句"><a href="#_9-5-join子句" class="header-anchor">#</a> 9.5 JOIN子句</h3> <p>ClickHouse的JOIN语法包含<strong>连接精度</strong>和<strong>连接类型</strong>两部分：连接精度+连接类型+JOIN</p> <p>连接精度：ALL / ANY / ASOF (默认ALL)</p> <p>连接类型：</p> <ol><li>外连接：LEFT / RIGHT / FULL(OUTER)</li> <li>内连接：INNER</li> <li>外连接：CROSS</li></ol> <h4 id="_9-5-1-连接精度"><a href="#_9-5-1-连接精度" class="header-anchor">#</a> 9.5.1 连接精度</h4> <p>ALL：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中全部连接数据。</p> <p>ANY：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中<strong>第一行</strong>连接数据。</p> <p>ASOF：ASOF是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件 asof_column（感觉有点玄学，插个眼，mark）</p> <h4 id="_9-5-2-连接类型"><a href="#_9-5-2-连接类型" class="header-anchor">#</a> 9.5.2 连接类型</h4> <p>跟MySQL一样</p> <h4 id="_9-5-3-多表连接"><a href="#_9-5-3-多表连接" class="header-anchor">#</a> 9.5.3 多表连接</h4> <p>跟MySQL一样</p> <h4 id="_9-5-4-注意事项"><a href="#_9-5-4-注意事项" class="header-anchor">#</a> 9.5.4 注意事项</h4> <ol><li><p>关于性能</p> <p>首先，应该遵循<strong>左大又小</strong>的原则，即将数据量小的表放在右侧（跟MySQL或Hive的小表JOIN大表不太一样），因为ClickHouse中所有连接方式，右表都会被全部加载到内存中与左表进行比较。</p> <p>其次，<strong>JOIN查询目前没有缓存的支持</strong>，这意味着每一次JOIN查询，即便是连续执行的相同SQL，也都会生成一次全新的执行计划。故如果大量使用JOIN查询，则需要进一步考虑借助上次应用侧的缓存服务或使用JOIN表引擎来改善性能。</p> <p>最后，如果是<strong>在大量维度属性不全的查询场景中，建议使用字典代替JOIN查询</strong>。因为在进行多表的连接查询时，查询会转换成两两连接的形式，这种“滚雪球”式的查询很可能带来性能问题。</p></li> <li><p>关于空值策略与简写形式</p> <p>ClickHouse中连接查询的空值（未被连接的数据）是由默认值填充的，这跟其他常见的数据库的策略不同（由Null填充）。ClickHouse中连接查询的空值策略是通过<code>join_use_nulls</code>参数指定的，默认为0，默认充填0（当该参数为1时，空值由Null填充）。</p> <p>此外，JOIN Key支持简化写法，当数据表的连接字段名相同时，可以用<code>USING</code>语法简写，例如下面两条语句的效果是等同的：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> a<span class="token punctuation">.</span>id<span class="token punctuation">,</span>a<span class="token punctuation">.</span>name<span class="token punctuation">,</span>b<span class="token punctuation">.</span>rate <span class="token keyword">FROM</span> join_tb1 a
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> join_tb2 b <span class="token keyword">ON</span> a<span class="token punctuation">.</span>id <span class="token operator">=</span> b<span class="token punctuation">.</span>id

<span class="token comment">-- USING简写</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>rate <span class="token keyword">FROM</span> join_tb1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> join_tb2 <span class="token keyword">USING</span> id
</code></pre></div></li></ol> <h3 id="_9-6-where与prewhere子句"><a href="#_9-6-where与prewhere子句" class="header-anchor">#</a> 9.6 WHERE与PREWHERE子句</h3> <p>WHERE子句基于条件表达式来实现数据过滤（这个跟其他数据库一样），如果过滤条件恰好是主键字段，则能够借助索引进一步加速查询，所以WHERE子句是查询语句能否启用索引的判断依据（前提是表引擎支持索引特性）。</p> <p>PREWHERE目前只能用于MergeTree系列的表引擎，它是WHERE的一种优化，结果相同。它的不同之处在于：使用PREWHERE时，首先只会读取PREWHERE指定的列字段数据，用于数据过滤的条件判断，待数据过滤之后再读取SELECT声明的列字段以补全其余属性。所以再一些场合中PREWHERE相比WHERE处理的数据量更少（处理的数据行数可能没变，但是数据大小变小了），性能更高。</p> <p>PREWHERE优化默认打开，会在条件合适的情况下将WHERE替换为PREWHERE，其参数设置语句如下：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SET</span> optimize_move_to_prewhere <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">--参数为0时强制关闭</span>
</code></pre></div><h3 id="_9-7-group-by子句"><a href="#_9-7-group-by子句" class="header-anchor">#</a> 9.7 GROUP BY子句</h3> <p>GROUP BY后声明的字段通常称为<strong>聚合键</strong>或Key，在ClickHouse中的聚合查询中 SELECT 后只声明了聚合函数，则可以省略GROUP BY关键字，例如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t1 
</code></pre></div><p>SELECT的字段只能是聚合键、聚合函数，否则会报错。</p> <p>除了上述特性外，聚合查询还能配合<code>WITH ROLLUP</code>、<code>WITH CUBE</code>、<code>WITH TOTALS</code>三种修饰符获取额外的汇总信息。</p> <h4 id="_9-7-1-with-rollup"><a href="#_9-7-1-with-rollup" class="header-anchor">#</a> 9.7.1 WITH ROLLUP</h4> <p>ROLLUP能够按照聚合键从右向左上卷，基于聚合函数依次生成分组小计和总计。如果聚合键为n​，则最终会生成小计的个数为n+1​。</p> <h4 id="_9-7-2-with-rollup"><a href="#_9-7-2-with-rollup" class="header-anchor">#</a> 9.7.2 WITH ROLLUP</h4> <p>CUBE会像立方体模型一样，基于聚合键之间所有的组合生成小计信息。如果聚合键为n，则最终会生成小计的个数为2的n​次方。</p> <h4 id="_9-7-3-with-totals"><a href="#_9-7-3-with-totals" class="header-anchor">#</a> 9.7.3 WITH TOTALS</h4> <p>TOTALS会基于聚合函数对所有数据进行总计，例如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> a1<span class="token punctuation">,</span><span class="token function">SUM</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t1
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> a1 <span class="token keyword">WITH</span> TOTALS
</code></pre></div><p>其结果会额外显示累计总和的结果。</p> <h3 id="_9-10-limit-by子句"><a href="#_9-10-limit-by子句" class="header-anchor">#</a> 9.10 LIMIT BY子句</h3> <p>LIMIT BY子句运行于ORDER BY 之后和LIMIT之前，最多返回<strong>前n​个字段</strong>的数据，其常规语法如下：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">LIMIT</span> n <span class="token keyword">BY</span> 字段
</code></pre></div><h2 id="第10章"><a href="#第10章" class="header-anchor">#</a> 第10章</h2> <h3 id="_10-1-概述"><a href="#_10-1-概述" class="header-anchor">#</a> 10.1 概述</h3> <p>用Nx表示一个节点（服务器），例如N1,N2</p> <p>副本和分片有时候一样，有时候不一样，区分方法：</p> <p>如果N1的Y和N2的Y数据相同，则它们互为副本（N1Y = N2Y），否则互为分片（N1Y != N2Y）</p> <h3 id="_10-2-数据副本"><a href="#_10-2-数据副本" class="header-anchor">#</a> 10.2 数据副本</h3> <p>MegreTree表引擎前缀加了Replicated才有应用副本的能力（还有另一种副本的实现方式），例如ReplicatedMergeTree、ReplicatedReplacingMergeTree、ReplicatedSummingMergeTree，这类表引擎称为复制表系列引擎。</p> <p>ReplicatedMergeTree在MergeTree的基础上加入了分布式协同的能力，如图：</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png" width="70%"></p> <p>在MergeTree中，一个数据分区由开始创建到全部完成，会经历两类存储区域：</p> <ol><li>内存：数据首先会被写入内存缓冲区</li> <li>本地磁盘：数据接着会被写入tmp临时目录分区，待全部完成后再将临时目录重新命名为正式分区</li></ol> <ul><li>ReplicatedMergeTree在上述基础上增加了Zookeeper的部分，它会进一步在Zookeeper内创建一系列的监听节点，并以此实现多个实例之间的通信。在整个通信过程中，Zookeeper并不会涉及数据表的传输。</li></ul> <h3 id="_10-3-replicatedmergetree原理解析"><a href="#_10-3-replicatedmergetree原理解析" class="header-anchor">#</a> 10.3 ReplicatedMergeTree原理解析</h3> <p>ReplicatedMergeTree的核心逻辑中，大量运用了Zookeeper的能力，以实现ReplicatedMergeTree副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和BlockID去重判断等。</p> <p>副本协同的核心流程主要有<strong>INSERT</strong>、<strong>MERGE</strong>、<strong>MUTATION</strong>、<strong>ALTER</strong>，分别对应了数据写入、分区合并、数据修改、元数据修改。（其他查询不支持分布式执行，包括SELECT、CREATE、DROP、RENAME、ATTACH）</p> <p>拟定一个用ReplicatedMergeTree实现一张拥有1分片、1副本的数据表的演示场景，其完整过程如下：</p> <ul><li><p>INSERT的核心执行流程</p> <ol><li>创建第一个副本实例</li> <li>创建第二个副本实例</li> <li>向第一个副本实例写入数据</li> <li>由第一个副本实例推送Log日志</li> <li>第二个副本实例拉取Log日志</li> <li>第二个副本实例向其他副本发起下载请求</li> <li>第一个副本实例响应数据下载</li> <li>第二个实例下载数据并完成本地写入</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png" alt=""></p></li> <li><p>MERGE的核心执行流程</p> <ol><li>创建远程连接，尝试与主副本通信</li> <li>主副本接收通信</li> <li>由主副本制定MERGE计划并推送Log日志</li> <li>各副本分别拉取Log日志</li> <li>各个副本分别在本地执行MERGE</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png" alt=""></p></li> <li><p>MUTATION的核心执行流程</p> <ol><li>推送MUTATION日志</li> <li>所有副本实例各自监听MUTATION日志</li> <li>由主副本实例响应MUTATION日志并推送Log日志</li> <li>各个副本实例分别拉取Log日志</li> <li>各个副本实例分别在本地执行MUTATION</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png" alt=""></p></li> <li><p>ALTER的核心执行流程</p> <ol><li>修改共享元数据</li> <li>监听共享元数据变更并各自执行本地修改</li> <li>确认所有副本完成修改</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png" alt=""></p></li></ul> <h3 id="_10-4-数据分片"><a href="#_10-4-数据分片" class="header-anchor">#</a> 10.4 数据分片</h3> <p>通过引入副本可以有效降低数据丢失的风险（多份存储），并提升查询的性能（分摊查询、读写分离），但是仍没有解决数据表容量的问题。每个副本保存了数据表全量的数据，所以在业务庞大的场景中，依靠副本并不能解决单表的性能瓶颈，所以需要将数据水平切分，也就分片（shard）。</p> <p>数据表A分布在N个ClickHouse服务节点，且这些数据彼此之间没有重复数据，则称为数据表A有N个分片。为了进一步考虑数据在写入时，如何被均匀地写至各个分片，以及查询时路由到每个分片并组成结果集，所以ClickHouse的数据分片需要结合Distributed表引擎一同使用，如图：</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png" width="60%"></p> <p>Distributed表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。</p> <p>接下来以创建test_1_local的过程为例子，解释分布式DDL的核心执行流程</p> <ul><li><p>分布式DDL的核心执行流程</p> <ol><li>推送DDL日志</li> <li>拉取日志并执行</li> <li>确认执行进度</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png" width="60%"></p></li></ul> <h3 id="_10-5-distributed原理解析"><a href="#_10-5-distributed原理解析" class="header-anchor">#</a> 10.5 Distributed原理解析</h3> <p>Distributed表引擎是作为数据分片的透明代理，能自动路由数据至集群中的各个节点，所以Distributed表引擎和其他数据表一起协同工作，如图：</p> <p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png" width="60%"></p> <ul><li>本地表：通常以 _local 为后缀进行命名。本地表是承载数据的载体，可以使用非Distributed的任意表引擎，一张本地表对应了一个数据分片</li> <li>分布式表：通常以 _all 为后缀进行命名。分布式表只能用Distributed表引擎，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.21b076a1.js" defer></script><script src="./assets/js/2.47c06342.js" defer></script><script src="./assets/js/8.df68a8bb.js" defer></script>
  </body>
</html>
