(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{476:function(_,a,v){"use strict";v.r(a);var t=v(30),r=Object(t.a)({},(function(){var _=this,a=_.$createElement,v=_._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"数据库结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库结构"}},[_._v("#")]),_._v(" 数据库结构")]),_._v(" "),v("h3",{attrs:{id:"数据库与实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库与实例"}},[_._v("#")]),_._v(" 数据库与实例")]),_._v(" "),v("p",[_._v("MySQL被设计为一个单进程多线程架构的数据库")]),_._v(" "),v("p",[_._v("MySQL数据库实例在系统上表现就是一个进程")]),_._v(" "),v("h4",{attrs:{id:"数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[_._v("#")]),_._v(" 数据库")]),_._v(" "),v("p",[_._v("物理操作文件系统或其他形式文件类型的集合")]),_._v(" "),v("h4",{attrs:{id:"实例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[_._v("#")]),_._v(" 实例")]),_._v(" "),v("p",[_._v("MySQL数据库由后台线程以及共享的内存空间组成")]),_._v(" "),v("h3",{attrs:{id:"组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件"}},[_._v("#")]),_._v(" 组件")]),_._v(" "),v("ul",[v("li",[_._v("连接池")]),_._v(" "),v("li",[_._v("管理服务工具")]),_._v(" "),v("li",[_._v("SQL接口")]),_._v(" "),v("li",[_._v("查询分析器")]),_._v(" "),v("li",[_._v("优化器")]),_._v(" "),v("li",[_._v("缓冲")]),_._v(" "),v("li",[_._v("储存引擎")]),_._v(" "),v("li",[_._v("物理文件")])]),_._v(" "),v("h3",{attrs:{id:"结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[_._v("#")]),_._v(" 结构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210408143233.png",alt:"image-20210408143233206"}})]),_._v(" "),v("h3",{attrs:{id:"流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[_._v("#")]),_._v(" 流程")]),_._v(" "),v("h3",{attrs:{id:"连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[_._v("#")]),_._v(" 连接")]),_._v(" "),v("h4",{attrs:{id:"tcp-ip"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip"}},[_._v("#")]),_._v(" TCP/IP")]),_._v(" "),v("h4",{attrs:{id:"命名管道和共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#命名管道和共享内存"}},[_._v("#")]),_._v(" 命名管道和共享内存")]),_._v(" "),v("h4",{attrs:{id:"unix域套接字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unix域套接字"}},[_._v("#")]),_._v(" UNIX域套接字")]),_._v(" "),v("h2",{attrs:{id:"储存引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#储存引擎"}},[_._v("#")]),_._v(" 储存引擎")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210408143431.png",alt:"image-20210408143431579"}})]),_._v(" "),v("h3",{attrs:{id:"innodb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[_._v("#")]),_._v(" InnoDB")]),_._v(" "),v("h4",{attrs:{id:"架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[_._v("#")]),_._v(" 架构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210408143947.png",alt:"image-20210408143947334"}})]),_._v(" "),v("ul",[v("li",[_._v("内存\n"),v("ul",[v("li",[_._v("多个内存块")]),_._v(" "),v("li",[_._v("共同维护进程、线程 访问的内部数据结构")]),_._v(" "),v("li",[_._v("缓存磁盘数据")]),_._v(" "),v("li",[_._v("redo log缓冲")])])]),_._v(" "),v("li",[_._v("后台线程\n"),v("ul",[v("li",[_._v("多个线程负责不同任务")])])])]),_._v(" "),v("h5",{attrs:{id:"后台线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后台线程"}},[_._v("#")]),_._v(" 后台线程")]),_._v(" "),v("h6",{attrs:{id:"master-thread"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#master-thread"}},[_._v("#")]),_._v(" Master Thread")]),_._v(" "),v("p",[_._v("核心后台线程，主要将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存、UNDO页回收")]),_._v(" "),v("h6",{attrs:{id:"io-thread"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io-thread"}},[_._v("#")]),_._v(" IO Thread")]),_._v(" "),v("p",[_._v("负责IO请求的回调")]),_._v(" "),v("h6",{attrs:{id:"purge-thread"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#purge-thread"}},[_._v("#")]),_._v(" Purge Thread")]),_._v(" "),v("p",[_._v("回收已经使用并分配的UNDO页")]),_._v(" "),v("h6",{attrs:{id:"page-cleaner-thread"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#page-cleaner-thread"}},[_._v("#")]),_._v(" Page Cleaner Thread")]),_._v(" "),v("p",[_._v("脏页刷新")]),_._v(" "),v("h5",{attrs:{id:"内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存"}},[_._v("#")]),_._v(" 内存")]),_._v(" "),v("h6",{attrs:{id:"缓冲池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓冲池"}},[_._v("#")]),_._v(" 缓冲池")]),_._v(" "),v("p",[_._v("InnoDB基于磁盘储存，并将其中的记录按照页的方式管理。用缓冲池提高数据库性能")]),_._v(" "),v("p",[_._v("现在缓冲池中修改，再以一定的频率刷新到磁盘上")]),_._v(" "),v("p",[_._v("Checkpoint机制刷新回磁盘")]),_._v(" "),v("p",[_._v("数据类型包括")]),_._v(" "),v("ul",[v("li",[_._v("索引页")]),_._v(" "),v("li",[_._v("数据页UNDO页")]),_._v(" "),v("li",[_._v("插入缓冲")]),_._v(" "),v("li",[_._v("自适应哈希索引")]),_._v(" "),v("li",[_._v("锁信息")]),_._v(" "),v("li",[_._v("数据字典信息")])]),_._v(" "),v("h6",{attrs:{id:"redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[_._v("#")]),_._v(" redo log")]),_._v(" "),v("p",[_._v("InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，总共就可以记录4GB的操作。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210409145928.png",alt:"image-20210409145927978"}})]),_._v(" "),v("p",[_._v("write pos 与 check point 之间的距离是redo log 空余的空间")]),_._v(" "),v("h6",{attrs:{id:"bin-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bin-log"}},[_._v("#")]),_._v(" bin log")]),_._v(" "),v("p",[_._v("Server的日志（归档日志）")]),_._v(" "),v("ol",[v("li",[_._v("redo log是InnoDB引擎特有的；bin log是MySQL的Server层实现的，所有引擎都可以使用。")]),_._v(" "),v("li",[_._v("redo log是物理日志，记录的是“在某个数据页上做了什么修改”；bin log是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。")]),_._v(" "),v("li",[_._v("redo log是循环写的，空间固定会用完；bin log是可以追加写入的。“追加写”是指bin log文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。")])]),_._v(" "),v("h6",{attrs:{id:"uodo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#uodo-log"}},[_._v("#")]),_._v(" uodo log")]),_._v(" "),v("h6",{attrs:{id:"checkpoint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint"}},[_._v("#")]),_._v(" checkpoint")]),_._v(" "),v("p",[_._v("在InnoDB设计中，页操作首先在缓冲池中完成，缓冲池中的数据页与磁盘中数据页不同时，被称为脏页")]),_._v(" "),v("p",[_._v("事务提交时首先写rodo log ，Write-Ahead Logging，它的关键点就是先写日志，再写磁盘")]),_._v(" "),v("p",[_._v("解决了：")]),_._v(" "),v("ul",[v("li",[_._v("缩短了数据库恢复时间")]),_._v(" "),v("li",[_._v("将脏页写入磁盘，减少缓冲池储存压力")]),_._v(" "),v("li",[_._v("重做日志不可用时，刷新脏页")])]),_._v(" "),v("p",[_._v("可能发生的情况")]),_._v(" "),v("ul",[v("li",[_._v("redo log写满\n"),v("ul",[v("li",[_._v("需要尽量避免，此时数据库停止执行更新语句，性能降低为零")])])]),_._v(" "),v("li",[_._v("内存不足，数据页太多")]),_._v(" "),v("li",[_._v("空闲时刷入")]),_._v(" "),v("li",[_._v("数据库关闭刷入")])]),_._v(" "),v("h6",{attrs:{id:"lru-list、free-list和flush-list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lru-list、free-list和flush-list"}},[_._v("#")]),_._v(" LRU List、Free List和Flush List")]),_._v(" "),v("p",[v("strong",[_._v("LRU List")])]),_._v(" "),v("p",[_._v("最近最少使用算法")]),_._v(" "),v("p",[_._v("页的列表按使用次数排序")]),_._v(" "),v("p",[_._v("删除最尾部的页 在列表中点插入（减少刚刷入就被刷出的情况出现）")]),_._v(" "),v("p",[_._v("Free  List")]),_._v(" "),v("h4",{attrs:{id:"特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[_._v("#")]),_._v(" 特性")]),_._v(" "),v("ul",[v("li",[_._v("插入缓冲")]),_._v(" "),v("li",[_._v("二次写")]),_._v(" "),v("li",[_._v("自适应哈希索引")]),_._v(" "),v("li",[_._v("预读")])]),_._v(" "),v("h2",{attrs:{id:"文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件"}},[_._v("#")]),_._v(" 文件")]),_._v(" "),v("h3",{attrs:{id:"参数文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参数文件"}},[_._v("#")]),_._v(" 参数文件")]),_._v(" "),v("p",[_._v("用于寻找MySql文件所在地址和直到某些初始化参数，若找不到参数文件MySQL将以编译MySQL时指定的默认值和源代码中的默认值进行初始化。")]),_._v(" "),v("p",[_._v("以文本方式进行储存。")]),_._v(" "),v("p",[_._v("参数类型包括静态变量和动态变量。动态变量可以在实例运行期间进行修改。")]),_._v(" "),v("h3",{attrs:{id:"日志文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#日志文件"}},[_._v("#")]),_._v(" 日志文件")]),_._v(" "),v("p",[_._v("记录了数据库的活动信息")]),_._v(" "),v("ul",[v("li",[_._v("错误日志")]),_._v(" "),v("li",[_._v("二进制日志")]),_._v(" "),v("li",[_._v("慢查询日志")]),_._v(" "),v("li",[_._v("查询日志")])]),_._v(" "),v("h4",{attrs:{id:"错误日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#错误日志"}},[_._v("#")]),_._v(" 错误日志")]),_._v(" "),v("p",[_._v("对MySQL的启动、运行、关闭进行记录。")]),_._v(" "),v("p",[v("code",[_._v("SHOW VARIABLES LIKE'log_error'")]),_._v("可查看错误日志的路径")]),_._v(" "),v("p",[_._v("当数据库不能正常启动时应该首先查看错误日志。")]),_._v(" "),v("h5",{attrs:{id:"慢查询日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[_._v("#")]),_._v(" 慢查询日志")]),_._v(" "),v("p",[_._v("帮助DBA定位可能存在问题的SQL语句。设定阈值，记录所有运行时间超过阈值的SQL语句。")]),_._v(" "),v("p",[v("code",[_._v("long_query_time")]),_._v("设置阈值。")]),_._v(" "),v("h3",{attrs:{id:"socket文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket文件"}},[_._v("#")]),_._v(" socket文件")]),_._v(" "),v("h3",{attrs:{id:"pid文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pid文件"}},[_._v("#")]),_._v(" pid文件")]),_._v(" "),v("h3",{attrs:{id:"mysql表结构文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql表结构文件"}},[_._v("#")]),_._v(" MySQL表结构文件")]),_._v(" "),v("h3",{attrs:{id:"储存引擎文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#储存引擎文件"}},[_._v("#")]),_._v(" 储存引擎文件")]),_._v(" "),v("h2",{attrs:{id:"表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表"}},[_._v("#")]),_._v(" 表")]),_._v(" "),v("h3",{attrs:{id:"索引组织表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引组织表"}},[_._v("#")]),_._v(" 索引组织表")]),_._v(" "),v("p",[_._v("在InnoDB上，表都是根据主键顺序组织存放的，被称为索引组织表")]),_._v(" "),v("p",[v("em",[v("u",[_._v("数据即索引，索引即数据")])])]),_._v(" "),v("p",[_._v("主键设置：")]),_._v(" "),v("ul",[v("li",[_._v("显式定义")]),_._v(" "),v("li",[_._v("是否存在非空的唯一索引")]),_._v(" "),v("li",[_._v("自动创建一个6字节大小的指针")])]),_._v(" "),v("p",[_._v("优先级由上至下")]),_._v(" "),v("h3",{attrs:{id:"逻辑储存结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#逻辑储存结构"}},[_._v("#")]),_._v(" 逻辑储存结构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210410001025.png",alt:"image-20210410001025330"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210414221304.png",alt:"img"}}),_._v("在逻辑上，所有数据都被存放在表空间")]),_._v(" "),v("p",[_._v("表空间 由段、区、页组成")]),_._v(" "),v("p",[_._v("表空间被划分为许多连续的区，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了。")]),_._v(" "),v("h4",{attrs:{id:"表空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表空间"}},[_._v("#")]),_._v(" 表空间")]),_._v(" "),v("p",[_._v("InnoDB中逻辑储存结构的最高层")]),_._v(" "),v("p",[_._v("表空间是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为"),v("code",[_._v("表名.ibd")]),_._v("的实际文件。")]),_._v(" "),v("h4",{attrs:{id:"段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#段"}},[_._v("#")]),_._v(" 段")]),_._v(" "),v("p",[_._v("数据段、索引段、回滚段")]),_._v(" "),v("p",[_._v("索引段即B+树的的叶子节点")]),_._v(" "),v("p",[_._v("对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。")]),_._v(" "),v("p",[_._v("为了将叶子节点数据放在连续的物理结构中，对叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（"),v("code",[_._v("segment")]),_._v("），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段")]),_._v(" "),v("h4",{attrs:{id:"区和组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区和组"}},[_._v("#")]),_._v(" 区和组")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210414221318.png",alt:"img"}})]),_._v(" "),v("p",[_._v("连续页组成 任何情况下都为1MB")]),_._v(" "),v("p",[_._v("为保证区中页的连续性，InnoDB储存引擎一次从磁盘申请4~5个区。")]),_._v(" "),v("p",[_._v("一般页的大小为16KB，一个区中由64个连续的页")]),_._v(" "),v("p",[_._v("区的分类")]),_._v(" "),v("ul",[v("li",[_._v("空闲的区：现在还没有用到这个区中的任何页面。")]),_._v(" "),v("li",[_._v("有剩余空间的碎片区：表示碎片区中还有可用的页面。")]),_._v(" "),v("li",[_._v("没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。")]),_._v(" "),v("li",[_._v("附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。")])]),_._v(" "),v("p",[_._v("256个区被划分为一个组")]),_._v(" "),v("p",[_._v("第一组的前三个页面是固定的")]),_._v(" "),v("ul",[v("li",[_._v("FSP_HDR\n"),v("ul",[v("li",[_._v("用来等级整个表空间的一些整体属性以及本区所有的区，也就是0~255 共256个区的属性 整个表空间只有一个")])])]),_._v(" "),v("li",[_._v("IBUF_BITMAP\n"),v("ul",[v("li",[_._v("储存本组所有区的所有页面关于插入缓存信息")])])]),_._v(" "),v("li",[_._v("INODE\n*")])]),_._v(" "),v("h4",{attrs:{id:"页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页"}},[_._v("#")]),_._v(" 页")]),_._v(" "),v("p",[_._v("是InnoDB管理磁盘的最小单位，也是与内存交互的基本单位")]),_._v(" "),v("p",[_._v("默认16KB，可以通过"),v("code",[_._v("innodb_page_size")]),_._v("设置为4KB、8KB")]),_._v(" "),v("ul",[v("li",[_._v("数据页（B-tree Node）")]),_._v(" "),v("li",[_._v("undo页")]),_._v(" "),v("li",[_._v("系统也")]),_._v(" "),v("li",[_._v("事务数据页")]),_._v(" "),v("li",[_._v("插入缓冲位图页")]),_._v(" "),v("li",[_._v("插入缓冲空闲列表页")]),_._v(" "),v("li",[_._v("未压缩的二进制大对象页")]),_._v(" "),v("li",[_._v("压缩的二进制大对象页")])]),_._v(" "),v("h4",{attrs:{id:"行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行"}},[_._v("#")]),_._v(" 行")]),_._v(" "),v("p",[_._v("数据按行进行储存")]),_._v(" "),v("h3",{attrs:{id:"行记录格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行记录格式"}},[_._v("#")]),_._v(" 行记录格式")]),_._v(" "),v("h4",{attrs:{id:"compact"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#compact"}},[_._v("#")]),_._v(" Compact")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210410002023.png",alt:"image-20210410002023388"}})]),_._v(" "),v("p",[_._v("除了记录实际数据外，还有描述这行信息的额外信息")]),_._v(" "),v("ul",[v("li",[_._v("变长字段")]),_._v(" "),v("li",[_._v("NULL值列表")]),_._v(" "),v("li",[_._v("记录头信息")])]),_._v(" "),v("h5",{attrs:{id:"变长字段长度列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#变长字段长度列表"}},[_._v("#")]),_._v(" 变长字段长度列表")]),_._v(" "),v("p",[_._v("把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，")]),_._v(" "),v("p",[_._v("从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放")]),_._v(" "),v("h5",{attrs:{id:"null值标志位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#null值标志位"}},[_._v("#")]),_._v(" null值标志位")]),_._v(" "),v("p",[_._v("记录行内数据 为null值的位置，真实数据中不会保存null值")]),_._v(" "),v("p",[_._v("先统计允许储存null的列")]),_._v(" "),v("h5",{attrs:{id:"记录头信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#记录头信息"}},[_._v("#")]),_._v(" 记录头信息")]),_._v(" "),v("h5",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")]),_._v(" "),v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210411152213.png",alt:"image-20210411150031143"}})]),_._v(" "),v("h5",{attrs:{id:"真实数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#真实数据"}},[_._v("#")]),_._v(" 真实数据")]),_._v(" "),v("h6",{attrs:{id:"隐藏列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#隐藏列"}},[_._v("#")]),_._v(" 隐藏列")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210411152744.png",alt:"image-20210411152744619"}})]),_._v(" "),v("h6",{attrs:{id:"数据列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据列"}},[_._v("#")]),_._v(" 数据列")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210411153007.png",alt:"image-20210411153007777"}})]),_._v(" "),v("h4",{attrs:{id:"redundant"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redundant"}},[_._v("#")]),_._v(" Redundant")]),_._v(" "),v("h4",{attrs:{id:"行溢出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行溢出"}},[_._v("#")]),_._v(" 行溢出")]),_._v(" "),v("h4",{attrs:{id:"char的行储存结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#char的行储存结构"}},[_._v("#")]),_._v(" CHAR的行储存结构")]),_._v(" "),v("h3",{attrs:{id:"数据页结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据页结构"}},[_._v("#")]),_._v(" 数据页结构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210411155806.png",alt:"image-20210411155805839"}})]),_._v(" "),v("ul",[v("li",[_._v("File Header 页的通用信息")]),_._v(" "),v("li",[_._v("Page Header 数据页专有信息")]),_._v(" "),v("li",[_._v("infimun 、Supermun Records 最大记录和最小记录")]),_._v(" "),v("li",[_._v("User Records 用户记录")]),_._v(" "),v("li",[_._v("Free Space 空闲空间")]),_._v(" "),v("li",[_._v("Page Directory 页目录")]),_._v(" "),v("li",[_._v("File Trailer 文件尾部 校验是否完整")])]),_._v(" "),v("p",[_._v("业内数据的组织方式")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210413213658.webp",alt:"image_1d6g64af2sgj1816ktl1q22dehp.png-189.1kB"}})]),_._v(" "),v("p",[_._v("记录头信息表")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210413212359.png",alt:"img"}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210411202055.png",alt:"image-20210411202054987"}})]),_._v(" "),v("p",[_._v("delete_mask")]),_._v(" "),v("p",[_._v("这个属性标记着当前记录是否被删除，占用1个二进制位，值为"),v("code",[_._v("0")]),_._v("的时候代表记录并没有被删除，为"),v("code",[_._v("1")]),_._v("的时候代表记录被删除掉了")]),_._v(" "),v("p",[_._v("这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的"),v("code",[_._v("垃圾链表")]),_._v("，在这个链表中的记录占用的空间称之为所谓的"),v("code",[_._v("可重用空间")]),_._v("，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。")]),_._v(" "),v("p",[_._v("heap_no")]),_._v(" "),v("p",[_._v("这个属性表示当前记录在本页中的位置，包括最小记录和最大记录，这两条记录的构造十分简单，都是由5字节大小的"),v("code",[_._v("记录头信息")]),_._v("和8字节大小的一个固定的部分组成的")]),_._v(" "),v("p",[_._v("由于这两条记录不是我们自己定义的记录，所以它们并不存放在"),v("code",[_._v("页")]),_._v("的"),v("code",[_._v("User Records")]),_._v("部分，他们被单独放在一个称为"),v("code",[_._v("Infimum + Supremum")]),_._v("的部分")]),_._v(" "),v("p",[_._v("record_type")]),_._v(" "),v("p",[_._v("这个属性表示当前记录的类型，一共有4种类型的记录，"),v("code",[_._v("0")]),_._v("表示普通记录，"),v("code",[_._v("1")]),_._v("表示B+树非叶节点记录，"),v("code",[_._v("2")]),_._v("表示最小记录，"),v("code",[_._v("3")]),_._v("表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的"),v("code",[_._v("record_type")]),_._v("值都是"),v("code",[_._v("0")]),_._v("，而最小记录和最大记录的"),v("code",[_._v("record_type")]),_._v("值分别为"),v("code",[_._v("2")]),_._v("和"),v("code",[_._v("3")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"约束"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#约束"}},[_._v("#")]),_._v(" 约束")]),_._v(" "),v("h3",{attrs:{id:"视图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#视图"}},[_._v("#")]),_._v(" 视图")]),_._v(" "),v("h3",{attrs:{id:"分区表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区表"}},[_._v("#")]),_._v(" 分区表")]),_._v(" "),v("h2",{attrs:{id:"索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[_._v("#")]),_._v(" 索引")]),_._v(" "),v("h3",{attrs:{id:"常见索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见索引"}},[_._v("#")]),_._v(" 常见索引")]),_._v(" "),v("h4",{attrs:{id:"全文索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全文索引"}},[_._v("#")]),_._v(" 全文索引")]),_._v(" "),v("p",[_._v("将储存在数据库中的大段文本数据（文章等）中任意的内容信息查询出来的技术。")]),_._v(" "),v("h5",{attrs:{id:"倒排索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引"}},[_._v("#")]),_._v(" 倒排索引")]),_._v(" "),v("p",[_._v("全文索引通常使用倒排索引实现。")]),_._v(" "),v("p",[_._v("它在辅助表中储存了单词与单词自身在一个或多个文档中所在位置之间的映射。这种关联通常使用关联数组实现，拥有两种表现形式：")]),_._v(" "),v("ul",[v("li",[_._v("inverted file index")]),_._v(" "),v("li",[_._v("full inverted index")])]),_._v(" "),v("h5",{attrs:{id:"innodb中的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb中的实现"}},[_._v("#")]),_._v(" InnoDB中的实现")]),_._v(" "),v("p",[_._v("采用了full inverted index的实现方式。")]),_._v(" "),v("h5",{attrs:{id:"全文检索"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全文检索"}},[_._v("#")]),_._v(" 全文检索")]),_._v(" "),v("h4",{attrs:{id:"哈希索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哈希索引"}},[_._v("#")]),_._v(" 哈希索引")]),_._v(" "),v("p",[_._v("哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。")]),_._v(" "),v("p",[_._v("数据库中一般采用最简单的碰撞解决技术 链接法")]),_._v(" "),v("p",[_._v("即将发生碰撞的元素都连接在一个链表上")]),_._v(" "),v("p",[_._v("哈希函数最好能尽量避免碰撞的产生 数据库一般采用除法散列的方法")]),_._v(" "),v("h5",{attrs:{id:"使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[_._v("#")]),_._v(" 使用场景")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("等值查询的场景")])]),_._v(" "),v("li",[v("p",[_._v("有序数组索引只适用于静态存储引擎")])])]),_._v(" "),v("h5",{attrs:{id:"自适应哈希索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自适应哈希索引"}},[_._v("#")]),_._v(" 自适应哈希索引")]),_._v(" "),v("p",[_._v("由InnoDB自主控制、实现的哈希索引")]),_._v(" "),v("p",[_._v("基于缓存池内的数据库构建")]),_._v(" "),v("p",[_._v("根据访问频率和模式自动的为某些热点页构建哈希索引。")]),_._v(" "),v("h5",{attrs:{id:"innodb中的哈希索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb中的哈希索引"}},[_._v("#")]),_._v(" InnoDB中的哈希索引")]),_._v(" "),v("p",[_._v("InnoDB中使用哈希算法对字典进行查找，其冲突机制采用链表方式，哈希函数使用除法散列方式，")]),_._v(" "),v("h4",{attrs:{id:"b-树索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树索引"}},[_._v("#")]),_._v(" B+树索引")]),_._v(" "),v("p",[_._v("以2-3树为基础的实现的多元素节点多叉树，且在叶子节点储存数据，并用双向链表将叶子节点连接。")]),_._v(" "),v("h5",{attrs:{id:"聚簇索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引"}},[_._v("#")]),_._v(" 聚簇索引")]),_._v(" "),v("p",[v("code",[_._v("B+")]),_._v("树本身就是一个目录，或者说本身就是一个索引。它有两个特点：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：")]),_._v(" "),v("ul",[v("li",[_._v("页内的记录是按照主键的大小顺序排成一个单向链表。")]),_._v(" "),v("li",[_._v("各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。")]),_._v(" "),v("li",[_._v("存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。")])])]),_._v(" "),v("li",[v("p",[v("code",[_._v("B+")]),_._v("树的叶子节点存储的是完整的用户记录。")]),_._v(" "),v("p",[_._v("所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。")])])]),_._v(" "),v("p",[_._v("我们把具有这两种特性的"),v("code",[_._v("B+")]),_._v("树称为"),v("code",[_._v("聚簇索引")]),_._v("，所有完整的用户记录都存放在这个"),v("code",[_._v("聚簇索引")]),_._v("的叶子节点处。这种"),v("code",[_._v("聚簇索引")]),_._v("并不需要我们在"),v("code",[_._v("MySQL")]),_._v("语句中显式的使用"),v("code",[_._v("INDEX")]),_._v("语句去创建（后边会介绍索引相关的语句），"),v("code",[_._v("InnoDB")]),_._v("存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在"),v("code",[_._v("InnoDB")]),_._v("存储引擎中，"),v("code",[_._v("聚簇索引")]),_._v("就是数据的存储方式（所有的用户记录都存储在了"),v("code",[_._v("叶子节点")]),_._v("），也就是所谓的索引即数据，数据即索引。")]),_._v(" "),v("h5",{attrs:{id:"辅助索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#辅助索引"}},[_._v("#")]),_._v(" 辅助索引")]),_._v(" "),v("p",[_._v("在最终叶节点中储存的是主键值，即通过辅助索引查询还需要回表，拿主键值再在聚簇索引中查询。")]),_._v(" "),v("h5",{attrs:{id:"联合索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#联合索引"}},[_._v("#")]),_._v(" 联合索引")]),_._v(" "),v("h5",{attrs:{id:"覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[_._v("#")]),_._v(" 覆盖索引")]),_._v(" "),v("p",[_._v("仍然是B+树结构，但通过在辅助索引中通过维护冗余的数据，满足查询需求。就不用再进行回表。")]),_._v(" "),v("h5",{attrs:{id:"最左匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最左匹配原则"}},[_._v("#")]),_._v(" 最左匹配原则")]),_._v(" "),v("p",[_._v("MySQL会一直向右匹配直到遇到范围查询"),v("code",[_._v("（>,<,BETWEEN,LIKE）")]),_._v("就停止匹配。因为"),v("code",[_._v("B+")]),_._v("树的数据页和记录先是按照左边列的值排序的，在"),v("code",[_._v("左边")]),_._v("列的值相同的情况下才使用，右边列进行排序，也就是说左边列的值不同的记录中"),v("code",[_._v("右边")]),_._v("的值可能是无序的。")]),_._v(" "),v("h5",{attrs:{id:"索引下推"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[_._v("#")]),_._v(" 索引下推")]),_._v(" "),v("p",[_._v("MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。")]),_._v(" "),v("h3",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[_._v("#")]),_._v(" 作用")]),_._v(" "),v("h4",{attrs:{id:"优化单表访问"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化单表访问"}},[_._v("#")]),_._v(" 优化单表访问")]),_._v(" "),v("p",[_._v("直接使用全表扫描的方式执行查询要遍历好多记录，开销太大。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。")]),_._v(" "),v("ul",[v("li",[_._v("使用索引进行查询\n"),v("ul",[v("li",[_._v("针对主键或唯一二级索引的等值查询")]),_._v(" "),v("li",[_._v("针对普通二级索引的等值查询")]),_._v(" "),v("li",[_._v("针对索引列的范围查询")]),_._v(" "),v("li",[_._v("直接扫描整个索引")])])])]),_._v(" "),v("h3",{attrs:{id:"代价"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代价"}},[_._v("#")]),_._v(" 代价")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("空间上的代价")]),_._v(" "),v("p",[_._v("这个是显而易见的，每建立一个索引都要为它建立一棵"),v("code",[_._v("B+")]),_._v("树，每一棵"),v("code",[_._v("B+")]),_._v("树的每一个节点都是一个数据页，一个页默认会占用"),v("code",[_._v("16KB")]),_._v("的存储空间，一棵很大的"),v("code",[_._v("B+")]),_._v("树由许多数据页组成，那可是很大的一片存储空间呢。")])]),_._v(" "),v("li",[v("p",[_._v("时间上的代价")]),_._v(" "),v("p",[_._v("每次对表中的数据进行增、删、改操作时，都需要去修改各个"),v("code",[_._v("B+")]),_._v("树索引。而且我们讲过，"),v("code",[_._v("B+")]),_._v("树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。")])])]),_._v(" "),v("h3",{attrs:{id:"索引的选择和使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的选择和使用"}},[_._v("#")]),_._v(" 索引的选择和使用")]),_._v(" "),v("h4",{attrs:{id:"选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#选择"}},[_._v("#")]),_._v(" 选择")]),_._v(" "),v("h5",{attrs:{id:"只为用于搜索、排序或分组的列创建索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#只为用于搜索、排序或分组的列创建索引"}},[_._v("#")]),_._v(" 只为用于搜索、排序或分组的列创建索引")]),_._v(" "),v("p",[_._v("也就是说，只为出现在"),v("code",[_._v("WHERE")]),_._v("子句中的列、连接子句中的连接列，或者出现在"),v("code",[_._v("ORDER BY")]),_._v("或"),v("code",[_._v("GROUP BY")]),_._v("子句中的列创建索引。")]),_._v(" "),v("h5",{attrs:{id:"考虑重复数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#考虑重复数据"}},[_._v("#")]),_._v(" 考虑重复数据")]),_._v(" "),v("h5",{attrs:{id:"索引列的类型尽量小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引列的类型尽量小"}},[_._v("#")]),_._v(" 索引列的类型尽量小")]),_._v(" "),v("h5",{attrs:{id:"使用字符前缀建立索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用字符前缀建立索引"}},[_._v("#")]),_._v(" 使用字符前缀建立索引")]),_._v(" "),v("p",[_._v("减少空间占用，但失去了排序的特性")]),_._v(" "),v("h4",{attrs:{id:"全值匹配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全值匹配"}},[_._v("#")]),_._v(" 全值匹配")]),_._v(" "),v("p",[_._v("如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配")]),_._v(" "),v("blockquote",[v("p",[_._v("搜索条件的顺序不会影响，优化器会帮忙调整")])]),_._v(" "),v("h4",{attrs:{id:"匹配最左边的值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#匹配最左边的值"}},[_._v("#")]),_._v(" 匹配最左边的值")]),_._v(" "),v("p",[_._v("如果想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。")]),_._v(" "),v("h4",{attrs:{id:"匹配列前缀"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#匹配列前缀"}},[_._v("#")]),_._v(" 匹配列前缀")]),_._v(" "),v("p",[_._v("在字符串的排序中也是按从左到右进行排序的，因此使用前缀进行匹配也可以使用索引。但后缀不行，原因同最左匹配原则")]),_._v(" "),v("h4",{attrs:{id:"排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[_._v("#")]),_._v(" 排序")]),_._v(" "),v("p",[_._v("B+树索引的建立本身就是对某列数据进行排序")]),_._v(" "),v("h4",{attrs:{id:"分组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[_._v("#")]),_._v(" 分组")]),_._v(" "),v("h2",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[_._v("#")]),_._v(" 锁")]),_._v(" "),v("p",[_._v("为了支持对共享资源进行并发访问，保证提供数据的完整性和一致性")]),_._v(" "),v("p",[_._v("即保证了事务的隔离性，通过表锁，行锁等方式可以实现事务的各个隔离等级。")]),_._v(" "),v("h3",{attrs:{id:"lock与latch"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lock与latch"}},[_._v("#")]),_._v(" lock与latch")]),_._v(" "),v("p",[_._v("lock")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210425210322.png",alt:"image-20210425210321862"}})]),_._v(" "),v("h3",{attrs:{id:"锁的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁的分类"}},[_._v("#")]),_._v(" 锁的分类")]),_._v(" "),v("h4",{attrs:{id:"表锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[_._v("#")]),_._v(" 表锁")]),_._v(" "),v("p",[v("strong",[_._v("表锁下又分为两种模式")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("表读锁（Table Read Lock）")])]),_._v(" "),v("li",[v("p",[_._v("表写锁（Table Write Lock）")])]),_._v(" "),v("li",[v("p",[_._v("从下图可以清晰看到，在表读锁和表写锁的环境下：")]),_._v(" "),v("p",[_._v("读读不阻塞，读写阻塞，写写阻塞")]),_._v(" "),v("ul",[v("li",[_._v("读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁")]),_._v(" "),v("li",[_._v("读写阻塞：当前用户在读数据，其他的用户"),v("strong",[_._v("不能修改当前用户读的数据")]),_._v("，会加锁！")]),_._v(" "),v("li",[_._v("写写阻塞：当前用户在修改数据，其他的用户"),v("strong",[_._v("不能修改当前用户正在修改的数据")]),_._v("，会加锁！")])])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/23/164c6d7b21ecd949?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),_._v(" "),v("p",[_._v("从上面已经看到了："),v("strong",[_._v("读锁和写锁是互斥的，读写操作是串行")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("如果某个进程想要获取读锁，"),v("strong",[_._v("同时")]),_._v("另外一个进程想要获取写锁。在mysql里边，"),v("strong",[_._v("写锁是优先于读锁的")]),_._v("！")]),_._v(" "),v("li",[_._v("写锁和读锁优先级的问题是可以通过参数调节的："),v("code",[_._v("max_write_lock_count")]),_._v("和"),v("code",[_._v("low-priority-updates")])])]),_._v(" "),v("h4",{attrs:{id:"行锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[_._v("#")]),_._v(" 行锁")]),_._v(" "),v("p",[_._v("InnoDB中又以下"),v("strong",[_._v("两种")]),_._v("类型的行锁。")]),_._v(" "),v("ul",[v("li",[_._v("共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。")]),_._v(" "),v("li",[_._v("排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。")])]),_._v(" "),v("p",[v("strong",[_._v("为了允许行锁和表锁共存，实现多粒度锁机制")]),_._v("，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是"),v("strong",[_._v("表锁")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。")]),_._v(" "),v("li",[_._v("意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。")])]),_._v(" "),v("p",[_._v("在对某一行上锁之前，必须对此行的更粗粒度上获得意向锁，如果不兼容则必须等待。")]),_._v(" "),v("h3",{attrs:{id:"锁的算法与实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁的算法与实现"}},[_._v("#")]),_._v(" 锁的算法与实现")]),_._v(" "),v("h4",{attrs:{id:"记录锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#记录锁"}},[_._v("#")]),_._v(" 记录锁")]),_._v(" "),v("p",[_._v("只对索引上锁，锁定某一行")]),_._v(" "),v("h4",{attrs:{id:"间隙锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁"}},[_._v("#")]),_._v(" 间隙锁")]),_._v(" "),v("p",[_._v("锁定某一范围内的闭区间")]),_._v(" "),v("h4",{attrs:{id:"next-key-locks"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#next-key-locks"}},[_._v("#")]),_._v(" Next-Key Locks")]),_._v(" "),v("p",[_._v("结合记录锁和间隙锁，实现锁定某一范围内的开区间。")]),_._v(" "),v("h3",{attrs:{id:"在数据库中的使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在数据库中的使用"}},[_._v("#")]),_._v(" 在数据库中的使用")]),_._v(" "),v("p",[_._v("表锁在数据库中，几乎完全由数据库本身自动负责。")]),_._v(" "),v("p",[_._v("在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁")]),_._v(" "),v("h2",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),v("h3",{attrs:{id:"acid特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#acid特性"}},[_._v("#")]),_._v(" ACID特性")]),_._v(" "),v("p",[_._v("Atomic原子性")]),_._v(" "),v("p",[_._v("consistency一致性")]),_._v(" "),v("p",[_._v("isolation隔离性")]),_._v(" "),v("p",[_._v("durability持久性")]),_._v(" "),v("h3",{attrs:{id:"事务理论"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务理论"}},[_._v("#")]),_._v(" 事务理论")]),_._v(" "),v("ul",[v("li",[_._v("扁平事务 （Flat Transactions")]),_._v(" "),v("li",[_._v("带有保存点的扁平事务")]),_._v(" "),v("li",[_._v("链事务")]),_._v(" "),v("li",[_._v("嵌套事务")]),_._v(" "),v("li",[_._v("分布式事务")])]),_._v(" "),v("h4",{attrs:{id:"扁平事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#扁平事务"}},[_._v("#")]),_._v(" 扁平事务")]),_._v(" "),v("p",[_._v("事务类型中最简单的一种，也是实际生产环境中最为频繁使用的一种。")]),_._v(" "),v("p",[_._v("所有操作都处于同一个层次，期间的操作是原子的")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210606135151.png",alt:"image-20210606135148156"}})]),_._v(" "),v("p",[_._v("扁平事务主要缺陷是不能提交或回滚事务的某一部分，对于复杂事务的提交或回滚不够灵活")]),_._v(" "),v("h4",{attrs:{id:"到保存点的扁平事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#到保存点的扁平事务"}},[_._v("#")]),_._v(" 到保存点的扁平事务")]),_._v(" "),v("p",[_._v("在扁平事务的基础上，设立保存点用于支持部分提交或回滚功能。")]),_._v(" "),v("h4",{attrs:{id:"链事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链事务"}},[_._v("#")]),_._v(" 链事务")]),_._v(" "),v("p",[_._v("可视为保存点模式的一种变种。")]),_._v(" "),v("p",[_._v("在提交一个事务时，释放不需要的数据对象，将必要的上下文隐式地传给下一个要开始的事务。提交事务操作和开始下一个事务操作将合并为一个原子操作。")]),_._v(" "),v("p",[_._v("链式事务回滚只限于当前事务，即只能恢复到最近的一个保存点。")]),_._v(" "),v("h4",{attrs:{id:"嵌套事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#嵌套事务"}},[_._v("#")]),_._v(" 嵌套事务")]),_._v(" "),v("p",[_._v("是一个层次结构框架结构。由一个顶层事务控制各层次的事务。")]),_._v(" "),v("ul",[v("li",[_._v("嵌套事务是由若干事务组成的一颗树，子树既可以是嵌套事务，也可以是扁平事务")]),_._v(" "),v("li",[_._v("处于叶节点的是扁平事务，但每个字事务从根到叶节点的距离可以是不同的")]),_._v(" "),v("li",[_._v("位于根节点的事务为顶层事务，其他事务称为子事务。事务的前驱称为父事务，下一层称为儿子事务。")]),_._v(" "),v("li",[_._v("子事务既可以提交也可以回滚。但他的提交操作并不会马上生效，除非父事务已经提交。因此可以推出任何子事务都在顶层事务提交后才真正修改。")]),_._v(" "),v("li",[_._v("树中的任意一个事务回滚都会引起他的所有子事务一起回滚，所以子事务只具备ACI特性，不具备D特性。")])]),_._v(" "),v("h4",{attrs:{id:"分布式事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[_._v("#")]),_._v(" 分布式事务")]),_._v(" "),v("p",[_._v("通常是分布式环境下，运行的扁平事务，需要根据数据所在位置访问网络中的不同节点。")]),_._v(" "),v("h3",{attrs:{id:"事务实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务实现"}},[_._v("#")]),_._v(" 事务实现")]),_._v(" "),v("h4",{attrs:{id:"redo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo"}},[_._v("#")]),_._v(" redo")]),_._v(" "),v("p",[_._v("重做日志用于实现事物的持久性。")]),_._v(" "),v("p",[_._v("redo日志中记录了对每个页的修改")]),_._v(" "),v("blockquote",[v("p",[_._v("如果直接将修改的数据页刷入磁盘")]),_._v(" "),v("ul",[v("li",[_._v("可能修改的只是页中的一行数据，重新写入一整个数据页，开销很大")]),_._v(" "),v("li",[_._v("一个语句可能跨越的多个数据页进行修改，全部刷入是随机IO，速度太慢")])])]),_._v(" "),v("h5",{attrs:{id:"格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#格式"}},[_._v("#")]),_._v(" 格式")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210711210543.webp",alt:"image_1d36k7d3412oo1c0qcuuben12l79.png-31.3kB"}})]),_._v(" "),v("ul",[v("li",[v("p",[v("code",[_._v("type")]),_._v("：该条"),v("code",[_._v("redo")]),_._v("日志的类型。")]),_._v(" "),v("p",[_._v("在"),v("code",[_._v("MySQL 5.7.21")]),_._v("这个版本中，"),v("code",[_._v("InnoDB")]),_._v("中一共为"),v("code",[_._v("redo")]),_._v("日志设计了53种不同的类型，稍后会详细介绍不同类型的"),v("code",[_._v("redo")]),_._v("日志。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("space ID")]),_._v("：表空间ID。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("page number")]),_._v("：页号。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("data")]),_._v("：该条"),v("code",[_._v("redo")]),_._v("日志的具体内容。")])])]),_._v(" "),v("h5",{attrs:{id:"使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[_._v("#")]),_._v(" 使用")]),_._v(" "),v("p",[_._v("InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么 总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写")]),_._v(" "),v("p",[_._v("write pos指向当前写入的记录，checkpoint指向刷新入磁盘的记录")]),_._v(" "),v("blockquote",[v("p",[_._v("两阶段提交： redo log 的写入拆成了两个步骤：prepare 和 commit。这是为了让两份日志之间的逻辑一致。")])]),_._v(" "),v("h5",{attrs:{id:"binlog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[_._v("#")]),_._v(" binlog")]),_._v(" "),v("p",[_._v("Server 层也有自己的日志，称为 binlog（归档日志）")]),_._v(" "),v("p",[_._v("binlog记录了逻辑上的SQL语句，只能用于归档。")]),_._v(" "),v("h4",{attrs:{id:"undo日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo日志"}},[_._v("#")]),_._v(" undo日志")]),_._v(" "),v("p",[_._v("用于实现回滚操作。undo是逻辑日志，被储存于数据库内部的一个特殊段中。")]),_._v(" "),v("h4",{attrs:{id:"事务隔离等级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离等级"}},[_._v("#")]),_._v(" 事务隔离等级")]),_._v(" "),v("h4",{attrs:{id:"mvcc多版本并发控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvcc多版本并发控制"}},[_._v("#")]),_._v(" MVCC多版本并发控制")]),_._v(" "),v("p",[_._v("通过事务ID和数据的版本号，获取在事务ID开始前就存在且未被改动的数据集合，即事务开始瞬间的数据库快照。")]),_._v(" "),v("p",[_._v("用于实现提交读和可重复读两个隔离等级，称为一致性非锁定读")]),_._v(" "),v("p",[_._v("两种实现分别对应两种不同的隔离等级")]),_._v(" "),v("ul",[v("li",[_._v("事务开始时获得快照，保证整个事务过程中的一致性")]),_._v(" "),v("li",[_._v("每一个语句执行前都会重新计算出一个新的视图，保证每次执行语句的一致性")])]),_._v(" "),v("h5",{attrs:{id:"规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#规则"}},[_._v("#")]),_._v(" 规则")]),_._v(" "),v("p",[_._v("对于一个事务的快照来说，除了对自己更新的总是可见，另外还有三种情况：")]),_._v(" "),v("ul",[v("li",[_._v("版本未提交的，都是不可见的；")]),_._v(" "),v("li",[_._v("版本已经提交，但是是在创建视图之后提交的也是不可见的；")]),_._v(" "),v("li",[_._v("版本已经提交，若是在创建视图之前提交的是可见的")])]),_._v(" "),v("h4",{attrs:{id:"加锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#加锁"}},[_._v("#")]),_._v(" 加锁")]),_._v(" "),v("p",[_._v("InnoDB中可以通过MVCC和间隙锁实现解决幻读的隔离方案。")]),_._v(" "),v("p",[_._v("同时也可以通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁的方式，显式的实现隔离等级。")]),_._v(" "),v("blockquote",[v("p",[_._v("注意加锁必须在事务内进行，锁会随事务结束而释放")])]),_._v(" "),v("h2",{attrs:{id:"缓存池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存池"}},[_._v("#")]),_._v(" 缓存池")]),_._v(" "),v("h3",{attrs:{id:"作用-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用-2"}},[_._v("#")]),_._v(" 作用")]),_._v(" "),v("h3",{attrs:{id:"组成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组成"}},[_._v("#")]),_._v(" 组成")])])}),[],!1,null,null,null);a.default=r.exports}}]);