(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{460:function(a,v,t){"use strict";t.r(v);var r=t(30),_=Object(r.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"浅析jvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅析jvm"}},[a._v("#")]),a._v(" 浅析JVM")]),a._v(" "),t("h2",{attrs:{id:"从为什么要学jvm开始"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从为什么要学jvm开始"}},[a._v("#")]),a._v(" 从为什么要学JVM开始")]),a._v(" "),t("ul",[t("li",[a._v("深入了解Java，了解JVM，才能进一步了解Java内部运作")]),a._v(" "),t("li",[a._v("解决JVM的问题，如内存溢出、GC频繁等")])]),a._v(" "),t("h2",{attrs:{id:"了解java历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#了解java历史"}},[a._v("#")]),a._v(" 了解Java历史")]),a._v(" "),t("h3",{attrs:{id:"javase、javaee、javame"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javase、javaee、javame"}},[a._v("#")]),a._v(" JavaSE、JavaEE、JavaME")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Java SE（J2SE，Java 2 Platform Standard Edition，标准版）\nJava SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。")])]),a._v(" "),t("li",[t("p",[a._v("Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）\nJava EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。")])]),a._v(" "),t("li",[t("p",[a._v("Java ME（J2ME，Java 2 Platform Micro Edition，微型版）\nJava ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。")])])]),a._v(" "),t("h3",{attrs:{id:"jdk与jre"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk与jre"}},[a._v("#")]),a._v(" JDK与JRE")]),a._v(" "),t("p",[a._v("JRE（Java Runtime Environment）仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。而 JDK（Java Development Kit）除了包含 JRE外，还附带了一系列开发、诊断工具。")]),a._v(" "),t("p",[a._v("如果只需要运行 Java 程序，那么你安装 JRE 即可。但如果你要进行 Java 程序的开发，那么你就需要安装 JDK。")]),a._v(" "),t("h2",{attrs:{id:"jvm架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm架构"}},[a._v("#")]),a._v(" JVM架构")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210330014717.png",alt:"img"}})]),a._v(" "),t("ul",[t("li",[a._v("子系统\n"),t("ul",[t("li",[a._v("Class loader（类装载器）\n"),t("ul",[t("li",[a._v("根据全限定名类名来装载class文件到Runtime data area")])])]),a._v(" "),t("li",[a._v("Execution engine（执行引擎）\n"),t("ul",[t("li",[a._v("执行字节码指令")]),a._v(" "),t("li",[a._v("会使用即时编译技术将方法编译后译成机器码后再执行")])])])])]),a._v(" "),t("li",[a._v("组件\n"),t("ul",[t("li",[a._v("Runtime data area （运行时数据区）\n"),t("ul",[t("li",[a._v("运行时数据存储的地方，即JVM的内存")])])]),a._v(" "),t("li",[a._v("Native interface （本地接口）\n"),t("ul",[t("li",[a._v("与native libraries交互的接口")])])])])])]),a._v(" "),t("h3",{attrs:{id:"流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),t("p",[t("strong",[a._v("Java 源代码")]),a._v(" 被编译器转换为 "),t("strong",[a._v("字节码")]),a._v("  类加载器 将字节码 加载到运行时数据区 执行引擎 将字节码转为"),t("strong",[a._v("底层系统指令")]),a._v(" 交由CPU执行")]),a._v(" "),t("h2",{attrs:{id:"java内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[a._v("#")]),a._v(" Java内存模型")]),a._v(" "),t("h3",{attrs:{id:"公有"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#公有"}},[a._v("#")]),a._v(" 公有")]),a._v(" "),t("p",[a._v("（非线程安全）")]),a._v(" "),t("h4",{attrs:{id:"java堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java堆"}},[a._v("#")]),a._v(" Java堆")]),a._v(" "),t("p",[a._v("Java程序最主要的工作区域，在JVM启动时建立，专门用于实例对象内存分配的区域（但也有直接在栈上进行分配的情况）")]),a._v(" "),t("p",[a._v("Java NIO库会像直接内存区申请空间，直接内存访问速度优于Java堆，频繁读写的情况会考虑使用直接内存")]),a._v(" "),t("h4",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("p",[a._v("存储 Java 类字节码数据的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。"),t("strong",[a._v("储存类级别数据")])]),a._v(" "),t("h3",{attrs:{id:"私有"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#私有"}},[a._v("#")]),a._v(" 私有")]),a._v(" "),t("h4",{attrs:{id:"pc寄存器-程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pc寄存器-程序计数器"}},[a._v("#")]),a._v(" PC寄存器（程序计数器）")]),a._v(" "),t("p",[a._v("Program Counter 寄存器，指的是保存线程当前正在执行的方法。线程没有记忆，当发生线程切换时，需要回复线程状态（即执行到哪里），需要依靠计数器完成")]),a._v(" "),t("h4",{attrs:{id:"java虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),t("p",[a._v("Java 虚拟机栈，这个栈与线程同时创建，用来存储栈帧，即存储局部变量与一些过程结果的地方。栈帧存储的数据包括：局部变量表、操作数栈。")]),a._v(" "),t("p",[a._v("保存：局部变量、方法参数、Java方法的调用、返回")]),a._v(" "),t("ul",[t("li",[a._v("栈帧\n"),t("ul",[t("li",[a._v("局部变量数据")]),a._v(" "),t("li",[a._v("操作数栈")]),a._v(" "),t("li",[a._v("帧数据")])])])]),a._v(" "),t("h4",{attrs:{id:"本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),t("p",[a._v("与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的")]),a._v(" "),t("h2",{attrs:{id:"java类加载机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java类加载机制"}},[a._v("#")]),a._v(" Java类加载机制")]),a._v(" "),t("h3",{attrs:{id:"开始加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开始加载"}},[a._v("#")]),a._v(" 开始加载")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("启动类加载器")]),a._v(" – 负责从启动类路径中加载类，无非就是"),t("strong",[a._v("rt.jar")]),a._v("。这个加载器会被赋予最高优先级。")]),a._v(" "),t("li",[t("strong",[a._v("扩展类加载器")]),a._v(" – 负责加载"),t("strong",[a._v("ext")]),a._v(" 目录**(jre\\lib)"),t("strong",[a._v("内的类")]),a._v(".**")]),a._v(" "),t("li",[t("strong",[a._v("应用程序类加载器")]),a._v(" – 负责加载"),t("strong",[a._v("应用程序级别类路径")]),a._v("，涉及到路径的环境变量等etc.")])]),a._v(" "),t("p",[a._v("将字节码转为二进制字节流加载到内存中")]),a._v(" "),t("h3",{attrs:{id:"链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[a._v("#")]),a._v(" 链接")]),a._v(" "),t("h4",{attrs:{id:"校验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#校验"}},[a._v("#")]),a._v(" 校验")]),a._v(" "),t("p",[a._v("--字节码是否正确")]),a._v(" "),t("ul",[t("li",[a._v("JVM规范校验\n"),t("ul",[t("li",[a._v("JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。")])])]),a._v(" "),t("li",[a._v("代码逻辑校验\n"),t("ul",[t("li",[a._v("JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。")])])])]),a._v(" "),t("h4",{attrs:{id:"准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[a._v("#")]),a._v(" 准备")]),a._v(" "),t("p",[a._v("--分配内存和初始化默认值给静态变量")]),a._v(" "),t("ul",[t("li",[a._v("内存分配的对象")]),a._v(" "),t("li",[a._v("初始化的类型")])]),a._v(" "),t("h4",{attrs:{id:"解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[a._v("#")]),a._v(" 解析")]),a._v(" "),t("p",[a._v("--将符号内存引用替换为原始引用")]),a._v(" "),t("p",[a._v("JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。")]),a._v(" "),t("h3",{attrs:{id:"初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),t("ul",[t("li",[a._v("最后阶段，赋值静态变量、执行静态块")])]),a._v(" "),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("p",[a._v("对已经分配的内存空间进行分配")]),a._v(" "),t("h3",{attrs:{id:"判断垃圾对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断垃圾对象"}},[a._v("#")]),a._v(" 判断垃圾对象")]),a._v(" "),t("p",[a._v("不再被引用的的对象")]),a._v(" "),t("h4",{attrs:{id:"引用计数法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[a._v("#")]),a._v(" 引用计数法")]),a._v(" "),t("p",[a._v("设置一个计数变量，当被引用时计数+1，被出去引用时-1；当计数变量为0时，表示对象不能再被引用")]),a._v(" "),t("p",[a._v("实现简单 但无法解决循环引用的问题")]),a._v(" "),t("h4",{attrs:{id:"gc-root-tracing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc-root-tracing"}},[a._v("#")]),a._v(" GC Root Tracing")]),a._v(" "),t("p",[a._v("可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。")]),a._v(" "),t("h3",{attrs:{id:"内存分区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分区"}},[a._v("#")]),a._v(" 内存分区")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/20210401161912.png",alt:"未命名文件 (1)"}})]),a._v(" "),t("h3",{attrs:{id:"回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收策略"}},[a._v("#")]),a._v(" 回收策略")]),a._v(" "),t("h4",{attrs:{id:"分代回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[a._v("#")]),a._v(" 分代回收")]),a._v(" "),t("h5",{attrs:{id:"young-generation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#young-generation"}},[a._v("#")]),a._v(" Young Generation")]),a._v(" "),t("h6",{attrs:{id:"eden"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eden"}},[a._v("#")]),a._v(" Eden")]),a._v(" "),t("p",[a._v("新创建的类 C1")]),a._v(" "),t("h6",{attrs:{id:"from"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#from"}},[a._v("#")]),a._v(" From")]),a._v(" "),t("p",[a._v("一次minor GC后，C1存活 进入 From")]),a._v(" "),t("h6",{attrs:{id:"to"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#to"}},[a._v("#")]),a._v(" To")]),a._v(" "),t("p",[a._v("两次minor GC 后 C1 存活，age+1")]),a._v(" "),t("p",[a._v("再一次minor GC")]),a._v(" "),t("ul",[t("li",[a._v("如果C1同龄的类没有达到 survivor 空间的一半 互换From 和to")]),a._v(" "),t("li",[a._v("一直到达到survivor的一半以上（toSuv的区域已经满了） C1 进入老年代")])]),a._v(" "),t("h5",{attrs:{id:"old-generation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#old-generation"}},[a._v("#")]),a._v(" Old Generation")]),a._v(" "),t("p",[a._v("老年代空间比率超过阈值 出发marjor GC")]),a._v(" "),t("h4",{attrs:{id:"算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[a._v("#")]),a._v(" 算法")]),a._v(" "),t("h5",{attrs:{id:"复制算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[a._v("#")]),a._v(" 复制算法")]),a._v(" "),t("p",[a._v("复制算法。复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。")]),a._v(" "),t("h5",{attrs:{id:"标记清除算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[a._v("#")]),a._v(" 标记清除算法")]),a._v(" "),t("p",[a._v("在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。")]),a._v(" "),t("h5",{attrs:{id:"标记压缩算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记压缩算法"}},[a._v("#")]),a._v(" 标记压缩算法")]),a._v(" "),t("p",[a._v("分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("算法")]),a._v(" "),t("th",[a._v("优点")]),a._v(" "),t("th",[a._v("缺点")]),a._v(" "),t("th",[a._v("适用")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("复制算法")]),a._v(" "),t("td",[a._v("内存空间分配连续，效率高")]),a._v(" "),t("td",[a._v("内存空间折半，降低使用率，而且需要移动对象")]),a._v(" "),t("td",[a._v("存活对象少")])]),a._v(" "),t("tr",[t("td",[a._v("标记清除算法")]),a._v(" "),t("td",[a._v("实现简单，不用移动对象地址")]),a._v(" "),t("td",[a._v("空间碎片，内存空间不连续，分配效率降低")]),a._v(" "),t("td",[a._v("存货对象多")])]),a._v(" "),t("tr",[t("td",[a._v("标记压缩算法")]),a._v(" "),t("td",[a._v("优化了标记清除算法，减少了空间碎片的产生")]),a._v(" "),t("td"),a._v(" "),t("td")])])])])}),[],!1,null,null,null);v.default=_.exports}}]);