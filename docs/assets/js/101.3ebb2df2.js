(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{494:function(a,t,e){"use strict";e.r(t);var r=e(30),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"presto-impala-hive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#presto-impala-hive"}},[a._v("#")]),a._v(" presto  impala  hive")]),a._v(" "),e("p",[a._v("Presto和Impala更像师兄弟，分别来自FaceBook和Google，也同样属于RLOAP模型设计。 细细研究还是有些区别。")]),a._v(" "),e("h1",{attrs:{id:"impala与hive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#impala与hive"}},[a._v("#")]),a._v(" Impala与Hive")]),a._v(" "),e("blockquote",[e("p",[a._v("通过几方面对比下impala与hive")])]),a._v(" "),e("h4",{attrs:{id:"数据存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据存储"}},[a._v("#")]),a._v(" 数据存储")]),a._v(" "),e("p",[a._v("二者使用相同的存储数据池都支持把数据存储于HDFS, HBase。")]),a._v(" "),e("h4",{attrs:{id:"元数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元数据"}},[a._v("#")]),a._v(" 元数据")]),a._v(" "),e("p",[a._v("两者使用相同的元数据。")]),a._v(" "),e("h4",{attrs:{id:"sql解释处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql解释处理"}},[a._v("#")]),a._v(" SQL解释处理")]),a._v(" "),e("p",[a._v("比较相似都是通过词法分析生成执行计划。")]),a._v(" "),e("h4",{attrs:{id:"执行计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行计划"}},[a._v("#")]),a._v(" 执行计划")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 依赖于MapReduce执行框架，执行计划分成 map->shuffle->reduce->map->shuffle->reduce…的模型。如果一个Query会 被编译成多轮MapReduce，则会有更多的写中间结果。由于MapReduce执行框架本身的特点，过多的中间过程会增加整个Query的执行时间。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v(": 把执行计划表现为一棵完整的执行计划树，可以更自然地分发执行计划到各个Impalad执行查询，而不用像Hive那样把它组合成管道型的 map->reduce模式，以此保证Impala有更好的并发性和避免不必要的中间sort与shuffle。")]),a._v(" "),e("h4",{attrs:{id:"内存使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存使用"}},[a._v("#")]),a._v(" 内存使用")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 在执行过程中如果内存放不下所有数据，则会使用外存，以保证Query能顺序执行完。每一轮MapReduce结束，中间结果也会写入HDFS中，同样由于MapReduce执行架构的特性，shuffle过程也会有写本地磁盘的操作。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v(": 在遇到内存放不下数据时，当前版本1.0.1是直接返回错误，而不会利用外存，以后版本应该会进行改进。这使用得Impala目前处理Query会受到一 定的限制，最好还是与Hive配合使用。Impala在多个阶段之间利用网络传输数据，在执行过程不会有写磁盘的操作（insert除外）。")]),a._v(" "),e("h4",{attrs:{id:"数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据流"}},[a._v("#")]),a._v(" 数据流")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 采用推的方式，每一个计算节点计算完成后将数据主动推给后续节点。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v(": 采用拉的方式，后续节点通过getNext主动向前面节点要数据，以此方式数据可以流式的返回给客户端，且只要有1条数据被处理完，就可以立即展现出来，而不用等到全部处理完成，更符合SQL交互式查询使用。")]),a._v(" "),e("h4",{attrs:{id:"调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调度"}},[a._v("#")]),a._v(" 调度")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 任务调度依赖于Hadoop的调度策略。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v(": 调度由自己完成，目前只有一种调度器simple-schedule，它会尽量满足数据的局部性，扫描数据的进程尽量靠近数据本身所在的物理机器。调度器 目前还比较简单，在SimpleScheduler::GetBackend中可以看到，现在还没有考虑负载，网络IO状况等因素进行调度。但目前Impala已经有对执行过程的性能统计分析，应该以后版本会利用这些统计信息进行调度吧。")]),a._v(" "),e("h4",{attrs:{id:"容错"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容错"}},[a._v("#")]),a._v(" 容错")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 依赖于Hadoop的容错能力。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v(": 在查询过程中，没有容错逻辑，如果在执行过程中发生故障，则直接返回错误（这与Impala的设计有关，因为Impala定位于实时查询，一次查询失败， 再查一次就好了，再查一次的成本很低）。但从整体来看，Impala是能很好的容错，所有的Impalad是对等的结构，用户可以向任何一个Impalad提交查询，如果一个Impalad失效，其上正在运行的所有Query都将失败，但用户可以重新提交查询由其它Impalad代替执行，不会影响服务。对于State Store目前只有一个，但当State Store失效，也不会影响服务，每个Impalad都缓存了State Store的信息，只是不能再更新集群状态，有可能会把执行任务分配给已经失效的Impalad执行，导致本次Query失败。")]),a._v(" "),e("h4",{attrs:{id:"适用面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#适用面"}},[a._v("#")]),a._v(" 适用面")]),a._v(" "),e("p",[e("strong",[a._v("Hive")]),a._v(": 复杂的批处理查询任务，数据转换任务。")]),a._v(" "),e("p",[e("strong",[a._v("Impala")]),a._v("：实时数据分析，因为不支持UDF，能处理的问题域有一定的限制，与Hive配合使用，对Hive的结果数据集进行实时分析。")]),a._v(" "),e("h1",{attrs:{id:"impala与presto"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#impala与presto"}},[a._v("#")]),a._v(" Impala与Presto")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211126232846.jpg",alt:"对比"}})]),a._v(" "),e("p",[a._v("对比:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1. Impala的计算速度是其一大优点，多表查询性能和Presto差不多，单表查询方面却不如Presto好。\n2. Impala不支持update、delete操作，不支持Date数据类型，不支持ORC文件格式等，并且Impala在查询时占用的内存很大。比如多表join时，Impala占用的内存比presto要多。\n3. Impala对Kudu的支持非常友好。\n4. presto的社区活跃度更高。\n5. Presto支持数据源丰富，生态非常广泛，可以对接很多的数据库。有兴趣看官网。\n")])])]),e("p",[a._v("所以从整体性能对比看，两者差不多，但是Impala更重些，使用起来没有Presto方便。")])])}),[],!1,null,null,null);t.default=s.exports}}]);