(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{410:function(t,s,a){"use strict";a.r(s);var n=a(30),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"hive中的count-distinct-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hive中的count-distinct-优化"}},[t._v("#")]),t._v(" Hive中的count(distinct)优化")]),t._v(" "),a("h2",{attrs:{id:"问题描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题描述"}},[t._v("#")]),t._v(" 问题描述")]),t._v(" "),a("p",[t._v("COUNT(DISTINCT xxx)在hive中很容易造成数据倾斜。针对这一情况，网上已有很多优化方法，这里不再赘述。\n但有时，“数据倾斜”又几乎是必然的。我们来举个例子：")]),t._v(" "),a("p",[t._v("假设表detail_sdk_session中记录了访问某网站M的客户端会话信息，即：如果用户A打开app客户端，则会产生一条会话信息记录在该表中，该表的粒度为“一次”会话，其中每次会话都记录了用户的唯一标示uuid，uuid是一个很长的字符串，假定其长度为64位。现在的需求是：每天统计当月的活用用户数——“月活跃用户数”（当月访问过app就为活跃用户）。我们以2016年1月为例进行说明，now表示当前日期。\n最简单的方法")]),t._v(" "),a("p",[t._v("这个问题逻辑上很简单，SQL也很容易写出来，例如：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" detail_sdk_session t\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("date")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2016-01-01'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("date")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" now\n")])])]),a("p",[t._v("上述SQL代码中，now表示当天的日期。很容易想到，越接近月末，上面的统计的数据量就会越大。更重要的是，在这种情况下，“数据倾斜”是必然的，因为只有一个reducer在进行COUNT(DISTINCT uuid)的计算，所有的数据都流向唯一的一个reducer，不倾斜才怪。")]),t._v(" "),a("h2",{attrs:{id:"优化1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化1"}},[t._v("#")]),t._v(" "),a("strong",[t._v("优化1")])]),t._v(" "),a("p",[t._v("其实，在COUNT(DISTINCT xxx)的时候，我们可以采用“分治”的思想来解决。对于上面的例子，首先我们按照uuid的前n位进行GROUP BY，并做COUNT(DISTINCT )操作，然后再对所有的COUNT(DISTINCT)结果进行求和。\n我们先把SQL写出来，然后再做分析。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 外层SELECT求和")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mau_part"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" mau\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 内层SELECT分别进行COUNT(DISTINCT)计算")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n    substr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" uuid_part"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" substr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" mau_part\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" detail_sdk_session\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" partition_date "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2016-01-01'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" partition_date "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" now\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" substr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上述SQL中，内层SELECT根据uuid的前3位进行GROUP BY，并计算相应的活跃用户数COUNT(DISTINCT)，外层SELECT求和，得到最终的月活跃用户数。\n这种方法的好处在于，在不同的reducer各自进行COUNT(DISTINCT)计算，充分发挥hadoop的优势，然后进行求和。")]),t._v(" "),a("p",[t._v("注意，上面SQL中，n设为3，不应过大。\n为什么n不应该太大呢？我们假定uuid是由字母和数字组成的：大写字母、小写字母和数字，字符总数为26+26+10=62。理论上，内层SELECT进行GROUP BY时，会有 62^n 个分组，外层SELECT就会进行 62^n 次求和。所以n不宜过大。当然，如果数据量十分巨大，n必须充分大，才能保证内层SELECT中的COUNT(DISTINCT)能够计算出来，此时可以再嵌套一层SELECT，这里不再赘述。")]),t._v(" "),a("h2",{attrs:{id:"优化2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("优化2")])]),t._v(" "),a("p",[t._v("其实，很多博客中都记录了使用GROUP BY 操作代替 COUNT(DISTINCT) 操作，但有时仅仅使用GROUP BY操作还不够，还需要加点小技巧。\n还是先来看一下代码：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--  第三层SELECT")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mau_part"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" mau\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 第二层SELECT")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n    tag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" mau_part\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 第一层SELECT")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n      uuid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n      CAST"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("RAND"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BIGINT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" tag  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 为去重后的uuid打上标记，标记为：0-100之间的整数。")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" detail_sdk_session\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" partition_date "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2016-01-01'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" partition_date "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" now\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" uuid   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 通过GROUP BY，保证去重")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" t\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" tag\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" s\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("第一层SELECT：对uuid进行去重，并为去重后的uuid打上整数标记")]),t._v(" "),a("li",[t._v("第二层SELECT：按照标记进行分组，统计每个分组下uuid的个数")]),t._v(" "),a("li",[t._v("第三层SELECT：对所有分组进行求和\n上面这个方法最关键的是为每个uuid进行标记，这样就可以对其进行分组，分别计数，最后去和。如果数据量确实很大，也可以增加分组的个数。例如：CAST(RAND() * 1000 AS BIGINT) tag")])])])}),[],!1,null,null,null);s.default=r.exports}}]);