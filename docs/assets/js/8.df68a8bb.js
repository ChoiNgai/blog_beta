(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{395:function(t,a,s){"use strict";s.r(a);var _=s(30),e=function(t){t.options.__data__block__={mermaid_64a5706a:"graph LR\nA[Block流] --\x3eB(IBlockInputStream)\n    A --\x3e C(IBlockOutputStream)\n    B --\x3e D(DDL操作)\n    B --\x3e E(关系运算)\n    B --\x3e F(表引擎)\n    C --\x3e G(表引擎)\n",mermaid_64a56168:"graph LR\nA[数据字典] --\x3eB(内置字典 _ ClickHouse默认自带的字典)\n    A --\x3e C(外部扩展字典 _ 用户自定义配置实现的字典)\n"}},v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"《clickhouse原理解析与应用实践》阅读笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#《clickhouse原理解析与应用实践》阅读笔记"}},[t._v("#")]),t._v(" 《ClickHouse原理解析与应用实践》阅读笔记")]),t._v(" "),s("h2",{attrs:{id:"第2章-clickhouse架构概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第2章-clickhouse架构概述"}},[t._v("#")]),t._v(" 第2章 ClickHouse架构概述")]),t._v(" "),s("h3",{attrs:{id:"_2-1-clickhouse的核心特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-clickhouse的核心特性"}},[t._v("#")]),t._v(" 2.1 ClickHouse的核心特性")]),t._v(" "),s("h4",{attrs:{id:"_2-1-2-列式存储与数据压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-列式存储与数据压缩"}},[t._v("#")]),t._v(" 2.1.2 列式存储与数据压缩")]),t._v(" "),s("p",[t._v("行式存储：逐行扫描")]),t._v(" "),s("p",[t._v("列式存储：逐列扫描")]),t._v(" "),s("h4",{attrs:{id:"_2-1-3-向量化执行引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-向量化执行引擎"}},[t._v("#")]),t._v(" 2.1.3 向量化执行引擎")]),t._v(" "),s("p",[t._v("向量化执行引擎：一项消除程序循环的优化\n（原理上类似增加空间复杂度减少时间复杂度）")]),t._v(" "),s("p",[t._v("通过CPU的SIMD指令（Single Instruction Multiple Data,SIMD）即用单条指令操作多条数据，从而通过数据并行以提高性能，它的原理是在CPU寄存器层面实现数据的并行操作。")]),t._v(" "),s("blockquote",[s("p",[t._v("ClickHouse目前用SSE4.2指令集实现向量化执行")])]),t._v(" "),s("h4",{attrs:{id:"_2-1-4-关系模型与sql查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-关系模型与sql查询"}},[t._v("#")]),t._v(" 2.1.4 关系模型与SQL查询")]),t._v(" "),s("p",[t._v("相比HBase和Redis这类NoSQL数据库，ClickHouse使用关系模型描述并提供了传统数据库的概念（数据库、表、视图、函数等）。此外ClickHouse完全使用SQL作为查询语言。")]),t._v(" "),s("h4",{attrs:{id:"_2-1-5-表引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-表引擎"}},[t._v("#")]),t._v(" 2.1.5 表引擎")]),t._v(" "),s("p",[t._v("ClickHouse共拥有合并树、内存、文件、接口和其他等6大类20多种的表引擎。")]),t._v(" "),s("h4",{attrs:{id:"_2-1-7-多主架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-7-多主架构"}},[t._v("#")]),t._v(" 2.1.7 多主架构")]),t._v(" "),s("p",[t._v("不同于HDFS、Spark、ElasticSearch这类采用主从架构（Master-Slave）的分布式系统，ClickHouse采用多主架构（Multi-Master）。")]),t._v(" "),s("h4",{attrs:{id:"_2-1-8-在线查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-8-在线查询"}},[t._v("#")]),t._v(" 2.1.8 在线查询")]),t._v(" "),s("p",[t._v("在线查询（好像就是即席查询，指用户临时写的查询语句并且需要立刻得到返回结果）")]),t._v(" "),s("p",[t._v("ClickHouse在在线查询方面很快（相比Hive、Spark SQL），而且开源（Vertica性能很好，但是价格很高）")]),t._v(" "),s("h4",{attrs:{id:"_2-1-9-数据分片与分布式查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-9-数据分片与分布式查询"}},[t._v("#")]),t._v(" 2.1.9 数据分片与分布式查询")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("数据分片")]),t._v(" "),s("p",[t._v("分片是一种大数据处理下的分治思想，ClickHouse支持数据分片。")]),t._v(" "),s("p",[t._v("一个集群由1到多个分片组成，每个分片对应ClickHouse的1个服务节点（故数据分片数量取决于ClickHouse服务节点数）")])]),t._v(" "),s("li",[s("p",[t._v("分布式查询")]),t._v(" "),s("p",[t._v("ClickHouse提供本地表（Local Tabel）和分布式表（Distributed Table）。")]),t._v(" "),s("p",[t._v("本地表等同于一份数据分片")]),t._v(" "),s("p",[t._v("分布式表不存储数据，它是本地表的代理访问，类似分库中间件，能够代理访问多个数据分片，从而实现分布式查询。ClickHouse")])])]),t._v(" "),s("h3",{attrs:{id:"_2-2-clickhouse的架构设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-clickhouse的架构设计"}},[t._v("#")]),t._v(" 2.2 ClickHouse的架构设计")]),t._v(" "),s("h4",{attrs:{id:"_2-2-1-column和field"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-column和field"}},[t._v("#")]),t._v(" 2.2.1 Column和Field")]),t._v(" "),s("p",[t._v("ClickHouse按列存储数据，内存中一列数据由一个Column对象表示；Column采用泛化的设计模式。")]),t._v(" "),s("p",[t._v("ClickHouse都会以整列的方式操作数据，除非需要操作具体单个的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值；Field采用聚合的设计模式，内部聚合了Null、UInt64、String、Array等13种数据类型及相应的处理逻辑。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-2-datatype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-datatype"}},[t._v("#")]),t._v(" 2.2.2 DataType")]),t._v(" "),s("p",[t._v("ClickHouse数据的序列化和反序列化工作由DataType负责。IDataType采用泛华的设计模式，支持二进制、文本、json、xml、csv、protobuf等多种格式。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-3-block和block流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-block和block流"}},[t._v("#")]),t._v(" 2.2.3 Block和Block流")]),t._v(" "),s("p",[t._v("Column和Filed组成了数据的基本映射单元，但对应实际操作中缺少了必要补充信息，所以ClickHouse设计了Block。")]),t._v(" "),s("p",[t._v("Block对象本质是由数据对象、数据类型和列名称组成的三元组，即（Column，DataType，列名称字符串）。")]),t._v(" "),s("p",[t._v("Column提供数据读取能力，DataType负责正反序列化，所以Block在这些对象的基础上实现了进一步的抽象和封装，使得仅通过Block对象就能完成一系列的数据操作（Block并没有直接聚合Column和DataType对象，而是间接引用）。")]),t._v(" "),s("p",[t._v("Block流有两个顶层接口，分别是IBlockInputStream和IBlockOutputStream，每个顶层接口又有很多类方法。")]),t._v(" "),s("Mermaid",{attrs:{id:"mermaid_64a5706a",graph:t.$dataBlock.mermaid_64a5706a}}),s("h4",{attrs:{id:"_2-2-4-table"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-table"}},[t._v("#")]),t._v(" 2.2.4 Table")]),t._v(" "),s("p",[t._v("数据表的底层设计中并没有所谓的Table对象，它直接使用"),s("code",[t._v("IStorage接口")]),t._v("指代数据表。")]),t._v(" "),s("p",[t._v("IStorage定义了DDL（如ALTER、RENAME、OPTIMIZE、DROP等）、read、write方法，它们分别负责数据的定义、查询、写入。")]),t._v(" "),s("p",[t._v("对Table发起的一次操作通常都会经历这样的过程：接收AST查询语句（抽象语法树，简称AST），根据AST返回指定列的数据，之后再将数据交由Interpreter做进一步处理。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-5-parser和interpreter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-parser和interpreter"}},[t._v("#")]),t._v(" 2.2.5 Parser和Interpreter")]),t._v(" "),s("p",[t._v("Parser负责创建AST对象（将SQL以递归下降的方法发解析成AST语法树）；Interpreter负责解释AST，并进一步创建查询的执行管道（起到串联查询过程的作用，会根据解释器的雷系聚合它所需要的资源）。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-6-functions和aggregate-functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-6-functions和aggregate-functions"}},[t._v("#")]),t._v(" 2.2.6 Functions和Aggregate Functions")]),t._v(" "),s("p",[t._v("ClickHouse主要提供两类函数：普通函数（无状态）和聚合函数（有状态）。")]),t._v(" "),s("p",[t._v("普通函数由IFunctions定义，聚合函数由IAggregateFunctions接口定义，并支持序列化和反序列化。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-7-cluster和replication"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-7-cluster和replication"}},[t._v("#")]),t._v(" 2.2.7 Cluster和Replication")]),t._v(" "),s("p",[t._v("ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成，其具有以下特性：")]),t._v(" "),s("ol",[s("li",[t._v("ClickHouse的1个节点只能拥有1个分片")]),t._v(" "),s("li",[t._v("分片只是一个逻辑概念，其物理承载还是由副本承担。")])]),t._v(" "),s("h2",{attrs:{id:"第3章-安装与部署-略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第3章-安装与部署-略"}},[t._v("#")]),t._v(" 第3章 安装与部署（略）")]),t._v(" "),s("h2",{attrs:{id:"第4章-数据定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第4章-数据定义"}},[t._v("#")]),t._v(" 第4章 数据定义")]),t._v(" "),s("h3",{attrs:{id:"_4-1-数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-数据类型"}},[t._v("#")]),t._v(" 4.1 数据类型")]),t._v(" "),s("ul",[s("li",[t._v("基础类型")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("基础类型")]),t._v(" "),s("th",[t._v("具体类型")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("数值类型")]),t._v(" "),s("td",[t._v("Int、Float、Decimal")])]),t._v(" "),s("tr",[s("td",[t._v("字符串类型")]),t._v(" "),s("td",[t._v("String、FixedString、UUID")])]),t._v(" "),s("tr",[s("td",[t._v("时间类型")]),t._v(" "),s("td",[t._v("DateTime、DateTime64、Date")])])])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("复合类型")]),t._v(" "),s("ol",[s("li",[t._v("Array")]),t._v(" "),s("li",[t._v("Tuple")]),t._v(" "),s("li",[t._v("Enum")]),t._v(" "),s("li",[t._v("Nested")])])]),t._v(" "),s("li",[s("p",[t._v("特殊类型")]),t._v(" "),s("ol",[s("li",[t._v("Nullable")]),t._v(" "),s("li",[t._v("Domain")])])])]),t._v(" "),s("h3",{attrs:{id:"_4-2-如何定义数据表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-如何定义数据表"}},[t._v("#")]),t._v(" 4.2 如何定义数据表")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATABASE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("IF")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXISTS")]),t._v(" db_name "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Oridinary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("ENGINE处的参数表示数据库所使用的引擎，一共有五种：")]),t._v(" "),s("ul",[s("li",[t._v("Oridinary：默认引擎，大部分情况都用这个")]),t._v(" "),s("li",[t._v("Dictionary：字典引擎")]),t._v(" "),s("li",[t._v("Memory：内存引擎")]),t._v(" "),s("li",[t._v("Lazy：日志引擎")]),t._v(" "),s("li",[t._v("MySQL：MySQL引擎")])]),t._v(" "),s("h3",{attrs:{id:"_4-5-分布式ddl执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-分布式ddl执行"}},[t._v("#")]),t._v(" 4.5 分布式DDL执行")]),t._v(" "),s("p",[t._v("普通DDL语句转化为分布式DDL语句，只需加上"),s("code",[t._v("ON CLUSTER cluster_name")]),t._v("声明即可，如：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" CLUSTER ch_cluster "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\tid String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    url String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    EventTime "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Date")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MergeTree"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" toYYYYMM"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EventTime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" id\n")])])]),s("p",[t._v("该语句会对ch_cluster集群内所有节点广播这条DDL语句")]),t._v(" "),s("h2",{attrs:{id:"第5章-数据字典"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第5章-数据字典"}},[t._v("#")]),t._v(" 第5章 数据字典")]),t._v(" "),s("p",[t._v("数据字典是ClickHouse提供的一种存储介质，它以（键值，属性映射）的形式定义数据。")]),t._v(" "),s("p",[t._v("数据字典被"),s("strong",[t._v("加载到内存")]),t._v("，支持动态更新，因而数据字典非常适合保存常量或者经常使用的维度表数据，以避免不必要的JOIN查询。")]),t._v(" "),s("Mermaid",{attrs:{id:"mermaid_64a56168",graph:t.$dataBlock.mermaid_64a56168}}),s("p",[t._v("字典中的数据只能通过"),s("strong",[t._v("字典函数")]),t._v("访问（有一种例外情况，就是使用特殊的字典表引擎）")]),t._v(" "),s("ul",[s("li",[t._v("7种类型字典的特点总结")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("名称")]),t._v(" "),s("th",[t._v("存储结构")]),t._v(" "),s("th",[t._v("字典键类型")]),t._v(" "),s("th",[t._v("支持的数据来源")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("flat")]),t._v(" "),s("td",[t._v("数组")]),t._v(" "),s("td",[t._v("UInt64")]),t._v(" "),s("td",[t._v("Local file、 Executable file、 HTTP、DBMS")])]),t._v(" "),s("tr",[s("td",[t._v("hashed")]),t._v(" "),s("td",[t._v("散列")]),t._v(" "),s("td",[t._v("UInt64")]),t._v(" "),s("td",[t._v("Local file、 Executable file、 HTTP、DBMS")])]),t._v(" "),s("tr",[s("td",[t._v("range_hashed")]),t._v(" "),s("td",[t._v("散列并按时间排序")]),t._v(" "),s("td",[t._v("UInt64和时间")]),t._v(" "),s("td",[t._v("Local file、 Executable file、 HTTP、DBMS")])]),t._v(" "),s("tr",[s("td",[t._v("complex_key_hashed")]),t._v(" "),s("td",[t._v("散列")]),t._v(" "),s("td",[t._v("复合型Key")]),t._v(" "),s("td",[t._v("Local file、 Executable file、 HTTP、DBMS")])]),t._v(" "),s("tr",[s("td",[t._v("ip_trie")]),t._v(" "),s("td",[t._v("层次结构")]),t._v(" "),s("td",[t._v("复合型Key（单个String）")]),t._v(" "),s("td",[t._v("Local file、 Executable file、 HTTP、DBMS")])]),t._v(" "),s("tr",[s("td",[t._v("cache")]),t._v(" "),s("td",[t._v("固定大小数组")]),t._v(" "),s("td",[t._v("UInt64")]),t._v(" "),s("td",[t._v("Executable file、HTTP、 ClickHouse、MySQL")])]),t._v(" "),s("tr",[s("td",[t._v("complex_key_cache")]),t._v(" "),s("td",[t._v("固定大小数组")]),t._v(" "),s("td",[t._v("复合型Key")]),t._v(" "),s("td",[t._v("Executable file、HTTP、 ClickHouse、MySQL")])])])]),t._v(" "),s("h2",{attrs:{id:"第6章-mergetree原理解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第6章-mergetree原理解析"}},[t._v("#")]),t._v(" 第6章 MergeTree原理解析")]),t._v(" "),s("p",[t._v("表引擎是ClickHouse的一大特色，表引擎决定了一张表的特性，比如数据以何种形式被存储以及如何被加载。")]),t._v(" "),s("p",[t._v("合并树（MergeTree）是ClickHouse中最常用的表引擎，因为只有MergeTree系列（MergeTree的变种表引擎有很多）的表引擎才支持"),s("strong",[t._v("主键索引")]),t._v("、"),s("strong",[t._v("数据分区")]),t._v("、"),s("strong",[t._v("数据副本")]),t._v("、"),s("strong",[t._v("数据采样")]),t._v("这些特性，同时也只有此系列表引擎支持ALTER相关操作。")]),t._v(" "),s("h3",{attrs:{id:"_6-1-mergetree的创建方式与存储结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-mergetree的创建方式与存储结构"}},[t._v("#")]),t._v(" 6.1 MergeTree的创建方式与存储结构")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("MergeTree创建方式")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("IF")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("EXISTS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("db_name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("table_name "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\tname1 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("MATERIALIZED"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("ALIAS expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    name2 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DEFAULT")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("MATERIALIZED"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("ALIAS expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--省略 ...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MergeTree"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--选择合并树表引擎")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--选填，分区键\t")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--必填，排序键")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),t._v(" expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--选题，主键")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("SAMPLE "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" expr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--选题，抽样表达式")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("SETTINGS name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("省略"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--index_granularity[选填]，索引粒度，默认8192（每隔8192行生成一条索引）;index_granularity[选填]，每一批写书数据的体量大小，默认10M；enable_mixed_granularity_parts[选填]，设置是否开启自适应索引间隔，默认开启；merge_mixed_with_ttl_timeout[选填]；storage_policy[选填]")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("MergeTree存储结构")]),t._v(" "),s("blockquote",[s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("table_name\n│\n├─partition_1\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 分区目录")]),t._v("\n│    ├─ checksums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 检验文件，二进制格式存储")]),t._v("\n│    ├─ colums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 列文件，明文格式存储，保存该分区下的字段信息")]),t._v("\n│    ├─ count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 计数文件，明文格式存储，记录该分区下数据的总行数")]),t._v("\n│    ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("idx\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 一级索引文件，二进制格式存储，用于存放稀疏索引")]),t._v("\n│    ├─ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bin\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 数据文件，压缩格式存储（默认LZ4压缩格式）")]),t._v("\n│    ├─ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mrk\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 列字段标记文件，二进制格式存储，保存了.bin文件的数据偏移量")]),t._v("\n│    ├─ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mrk2\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 如果使用了适应性大小的间隔索引，作用和原理与.mrk文件相同")]),t._v("\n│    ├─ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("partition")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dat\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 使用了分区才会生成，保存当前分区表达式最终生成的值")]),t._v("\n│    ├─ minmax_"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("idx\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 使用了分区才会生成，记录当前分区原始字段最大值和最小值")]),t._v("\n│    ├─ skp_idx _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("idx\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 使用了二级索引才会生成")]),t._v("\n│    ├─ skp_idx _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Column")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("mrk\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 使用了二级索引才会生成")]),t._v("\n│    \n└─ partition_2\n│ \n└─ partition_n\n")])])])])])]),t._v(" "),s("h3",{attrs:{id:"_6-2-数据分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-数据分区"}},[t._v("#")]),t._v(" 6.2 数据分区")]),t._v(" "),s("h4",{attrs:{id:"_6-2-1-数据的分区规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-数据的分区规则"}},[t._v("#")]),t._v(" 6.2.1 数据的分区规则")]),t._v(" "),s("ul",[s("li",[t._v("ID在不同分区类型下的示例")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("类型")]),t._v(" "),s("th",[t._v("样例数据")]),t._v(" "),s("th",[t._v("分区表达式")]),t._v(" "),s("th",[t._v("分区ID")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("整型")]),t._v(" "),s("td",[t._v("18，19，20")]),t._v(" "),s("td",[t._v("PARTITION BY Age")]),t._v(" "),s("td",[t._v("分区1：18；分区2：19；分区3：20")])]),t._v(" "),s("tr",[s("td",[t._v("日期")]),t._v(" "),s("td",[t._v("2021-05-01，2021-05-2")]),t._v(" "),s("td",[t._v("PARTITION BY EventTime")]),t._v(" "),s("td",[t._v("分区1：20210501；分区2：20210502")])]),t._v(" "),s("tr",[s("td",[t._v("其他")]),t._v(" "),s("td",[t._v("‘www.nauu.com’")]),t._v(" "),s("td",[t._v("PARTITION BY URL")]),t._v(" "),s("td",[t._v("分区1：15b31467")])])])]),t._v(" "),s("h4",{attrs:{id:"_6-2-2-分区目录的命名规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-分区目录的命名规则"}},[t._v("#")]),t._v(" 6.2.2 分区目录的命名规则")]),t._v(" "),s("p",[t._v("分区目录 = 分区ID（PartitionID）+MaxBlockNum+MinBlockNum+Level")]),t._v(" "),s("p",[t._v("例如分区目录是202105_1_1_0")]),t._v(" "),s("blockquote",[s("p",[t._v("MaxBlockNum和MinBlockNum是最大数据块编号和最小数据块编号（跟数据压缩的数据压缩块无关）")])]),t._v(" "),s("h4",{attrs:{id:"_6-2-3-分区目录的合并过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-3-分区目录的合并过程"}},[t._v("#")]),t._v(" 6.2.3 分区目录的合并过程")]),t._v(" "),s("p",[t._v("MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值")]),t._v(" "),s("p",[t._v("MaxBlockNum：取同一分区内所有目录中最小的MaxBlockNum值")]),t._v(" "),s("p",[t._v("Level：取同一分区内最大Level值并加1")]),t._v(" "),s("h3",{attrs:{id:"_6-3-一级索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-一级索引"}},[t._v("#")]),t._v(" 6.3 一级索引")]),t._v(" "),s("h4",{attrs:{id:"_6-3-1-稀疏索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-1-稀疏索引"}},[t._v("#")]),t._v(" 6.3.1 稀疏索引")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png",width:"50%"}})]),t._v(" "),s("h4",{attrs:{id:"_6-3-2-索引粒度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-2-索引粒度"}},[t._v("#")]),t._v(" 6.3.2 索引粒度")]),t._v(" "),s("p",[t._v("ClickHouse中索引粒度默认为8192，数据以index_granularity的粒度（默认8192）被标记成多个小的区间，其中每个区间最多8192行数据。")]),t._v(" "),s("h4",{attrs:{id:"_6-3-3-索引数据的生成规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-3-索引数据的生成规则"}},[t._v("#")]),t._v(" 6.3.3 索引数据的生成规则")]),t._v(" "),s("p",[t._v("由于是稀疏索引，所以MergeTree需要间隔 index_granularity 行数据才会生成一条索引记录。")]),t._v(" "),s("h4",{attrs:{id:"_6-3-4-索引的查询过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-4-索引的查询过程"}},[t._v("#")]),t._v(" 6.3.4 索引的查询过程")]),t._v(" "),s("p",[t._v("根据索引粒度生成多个MarkRange，两个相邻的MarkRange相距步长为1，所有MarkRange（整个数据片段）的最大数值区间为[0,+inf]")]),t._v(" "),s("p",[t._v("索引查询过程分为3个步骤：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("生成查询条件区间。例如：")]),t._v(" "),s("p",[t._v("WHERE ID = 'A003' → ['A003' , 'A003']")]),t._v(" "),s("p",[t._v("WHERE ID > 'A003' → ['A003' ,  +inf]")])]),t._v(" "),s("li",[s("p",[t._v("递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断，从最大的区间[0 , +inf]开始：")]),t._v(" "),s("ul",[s("li",[t._v("如果不存在交集，则直接通过剪枝算法优化此整段MarkRange")]),t._v(" "),s("li",[t._v("如果存在交集，且MarkRange不可再分解（步长小于8），则记录MarkRange并返回")])])]),t._v(" "),s("li",[s("p",[t._v("合并MarkRange区间：将最终匹配的MarkRange聚在一起，合并它们的范围。")])])]),t._v(" "),s("h3",{attrs:{id:"_6-4-二级索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-二级索引"}},[t._v("#")]),t._v(" 6.4 二级索引")]),t._v(" "),s("p",[t._v("二级索引又称为跳数索引，默认关闭，开启命令为：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" allow_experimental_data_skipping_indices "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),s("h3",{attrs:{id:"_6-5-数据存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-数据存储"}},[t._v("#")]),t._v(" 6.5 数据存储")]),t._v(" "),s("h4",{attrs:{id:"_6-5-1-各列独立存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-1-各列独立存储"}},[t._v("#")]),t._v(" 6.5.1 各列独立存储")]),t._v(" "),s("p",[t._v("每个字段都有一个对应的.bin文件，这些.bin文件承载着物理存储。")]),t._v(" "),s("p",[t._v("存储的具体实现L：数据经过压缩后按照ORDER BY的声明排序，最后数据以压缩数据块的形式被组织写入.bin文件中")]),t._v(" "),s("h4",{attrs:{id:"_6-5-2-压缩数据块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-2-压缩数据块"}},[t._v("#")]),t._v(" 6.5.2 压缩数据块")]),t._v(" "),s("p",[t._v("JavaEnable.bin")]),t._v(" "),s("blockquote",[s("blockquote",[s("p",[t._v("压缩数据块0")]),t._v(" "),s("p",[t._v("hear stat(65536, 12000)")])]),t._v(" "),s("blockquote",[s("p",[t._v("压缩数据块1")]),t._v(" "),s("p",[t._v("hear stat(65536, 14660)")])]),t._v(" "),s("p",[t._v("...")])]),t._v(" "),s("p",[t._v("MergeTree在数据具体的写入过程中，会按照索引粒度（默认8192行），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为size，则整个写入过程遵循以下规则：")]),t._v(" "),s("ol",[s("li",[t._v("单个批次数据 size < 64KB：继续获取下一个批数据，直至累积到 size >= 64 KB，生成下一个压缩数据块")]),t._v(" "),s("li",[t._v("单个批次数据  64 KB <= size <= 1 MB​：直接生成下一个压缩数据块")]),t._v(" "),s("li",[t._v("单个批次数据  size >= 1 MB​：先按照1MB大小截断并生成下一个数据块，剩余数据继续依照上述规则执行。")])]),t._v(" "),s("h3",{attrs:{id:"_6-6-数据标记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-数据标记"}},[t._v("#")]),t._v(" 6.6 数据标记")]),t._v(" "),s("p",[t._v("下面用一个类比来说明数据标记是什么及其作用")]),t._v(" "),s("blockquote",[s("p",[t._v("MergeTree表：书")]),t._v(" "),s("p",[t._v("primary.idx（一级索引）：章节目录")]),t._v(" "),s("p",[t._v(".bin（数据文件）：书中的内容")]),t._v(" "),s("p",[t._v(".mrk（数据标记）：章节与内容之间的联系（数据标记记录两个信息：1、页码；2、某段内容起始位置）")])]),t._v(" "),s("h3",{attrs:{id:"_6-7-对于分区、索引、标记和压缩数据的协同总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-对于分区、索引、标记和压缩数据的协同总结"}},[t._v("#")]),t._v(" 6.7 对于分区、索引、标记和压缩数据的协同总结")]),t._v(" "),s("h4",{attrs:{id:"_6-7-1-写入过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-1-写入过程"}},[t._v("#")]),t._v(" 6.7.1 写入过程")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"_6-7-2-查询过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-2-查询过程"}},[t._v("#")]),t._v(" 6.7.2 查询过程")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"_6-7-3-数据标记与压缩数据块的对应关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-3-数据标记与压缩数据块的对应关系"}},[t._v("#")]),t._v(" 6.7.3 数据标记与压缩数据块的对应关系")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("多对一")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("一对一")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("一对多")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png",alt:""}})])])]),t._v(" "),s("h2",{attrs:{id:"第9章-数据查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第9章-数据查询"}},[t._v("#")]),t._v(" 第9章 数据查询")]),t._v(" "),s("h3",{attrs:{id:"_9-3-sample语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-sample语句"}},[t._v("#")]),t._v(" 9.3 SAMPLE语句")]),t._v(" "),s("p",[t._v("SAMPLE子句能够实现数据采样的功能，使查询返回采样数而不是全部数据，从而减少查询负载。SAMPLE子句的采样机制是一种"),s("strong",[t._v("幂等")]),t._v("[^1]设计，所以相同的采样规则能返回相同的数据，这项特性适用于那些可以接受近似查询结果的场景。")]),t._v(" "),s("p",[t._v("[^1]: 幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))")]),t._v(" "),s("p",[t._v("SAMPLE子句只能用于MergeTree系列引擎的数据表，并且要求在"),s("code",[t._v("CREATE TABLE")]),t._v("时声明"),s("code",[t._v("SAMPLE BY")]),t._v("抽样表达式，例如：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" hits_t1 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    ID UInt64"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    EventTime "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    UserID UInt64\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ENGINE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" MergeTree"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" toYYYYMM"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EventTime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("intHash32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UserID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- SAMPLE Key声明的表达式必须也包含在主键的声明中")]),t._v("\nSAMPLE "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" intHash32"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UserID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[s("code",[t._v("SAMPLE BY intHash32(UserID)")]),t._v("表示该表内的数据，按照"),s("code",[t._v("intHash32(UserID)")]),t._v("分布后的结果采样查询。")]),t._v(" "),s("blockquote",[s("p",[t._v("声明 SAMPLE Key的注意事项：")]),t._v(" "),s("ol",[s("li",[t._v("SAMPLE BY 所声明的表达式必须同时包含在主键的声明内；")]),t._v(" "),s("li",[t._v("SAMPLE Key 必须是int类型（如果不是，建表时不会报错但会在查询时得到异常）。")])])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("SAMPLE factor")]),t._v(" "),s("p",[t._v("factor范围在[0,1]，当factor是0或1的时候等同于不采样")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" ID "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" hits_t1 SAMPLE "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\n")])])]),s("p",[t._v("近似取10%的数据")])]),t._v(" "),s("li",[s("p",[t._v("SAMPLE rows")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" hits_t1 SAMPLE "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v("\n")])])]),s("p",[t._v("近似采样10000行的数据")])]),t._v(" "),s("li",[s("p",[t._v("SAMPLE factor OFFSET n")]),t._v(" "),s("p",[t._v("OFFSET 表示偏移量")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" hits_t1 SAMPLE "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OFFSET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.4")]),t._v("\n")])])]),s("p",[t._v("从二分之一处按0.4的系数采样（若出现了溢出则自动截断）")])])]),t._v(" "),s("h3",{attrs:{id:"_9-4-array-join子句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-array-join子句"}},[t._v("#")]),t._v(" 9.4 ARRAY JOIN子句")]),t._v(" "),s("p",[t._v("ARRAY JOIN 允许在表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开为多行。（类似Hive里的"),s("code",[t._v("LATERNAL VIEW EXPLODE")]),t._v("函数）")]),t._v(" "),s("p",[t._v("例如在表query_t1中：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("id")]),t._v(" "),s("th",[t._v("value")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")])]),t._v(" "),s("tr",[s("td",[t._v("3")]),t._v(" "),s("td",[t._v("[ ]")])])])]),t._v(" "),s("h4",{attrs:{id:"_9-4-1-inner-array-join"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-1-inner-array-join"}},[t._v("#")]),t._v(" 9.4.1 INNER ARRAY JOIN")]),t._v(" "),s("ul",[s("li",[t._v("demo")])]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" query_t1 ARRAY "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),t._v("\n")])])]),s("p",[t._v("得到结果：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("id")]),t._v(" "),s("th",[t._v("value")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("1")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("2")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("4")])])])]),t._v(" "),s("p",[t._v("排除掉了空行")]),t._v(" "),s("blockquote",[s("p",[t._v("跟Hive的数组行转列很像，Hive中是这样写的：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" \nLATERNAL "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VIEW")]),t._v(" EXPLODE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("','")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" table_tmp "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" v\n")])])])]),t._v(" "),s("ul",[s("li",[t._v("添加别名")])]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" query_t1 ARRAY "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" v\n")])])]),s("p",[t._v("得到结果：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("id")]),t._v(" "),s("th",[t._v("value")]),t._v(" "),s("th",[t._v("value")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("1")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("2")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("4")])])])]),t._v(" "),s("h4",{attrs:{id:"_9-4-2-left-array-join"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-2-left-array-join"}},[t._v("#")]),t._v(" 9.4.2 LEFT ARRAY JOIN")]),t._v(" "),s("ul",[s("li")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" query_t1 ARRAY "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEFT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" v\n")])])]),s("p",[t._v("得到结果：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("id")]),t._v(" "),s("th",[t._v("value")]),t._v(" "),s("th",[t._v("v")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("1")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("2")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("3")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("4")])]),t._v(" "),s("tr",[s("td",[t._v("3")]),t._v(" "),s("td",[t._v("[ ]")]),t._v(" "),s("td",[t._v("0")])])])]),t._v(" "),s("p",[t._v("改为LEFT查询以后，在INNER JOIN 中被排除的空数组出现了在返回的结果集中。")]),t._v(" "),s("blockquote",[s("p",[t._v("当同时对多个数组字段进行ARRAY JOIN 操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积，例如")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("arrayMap"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" mapv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("v_1 \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" query_t1 \nARRAY "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEFT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("mapv "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" v_1\n")])])]),s("p",[t._v("得到结果：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("id")]),t._v(" "),s("th",[t._v("value")]),t._v(" "),s("th",[t._v("v")]),t._v(" "),s("th",[t._v("mapv")]),t._v(" "),s("th",[t._v("v_1")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[2,4,6]")]),t._v(" "),s("td",[t._v("2")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[2,4,6]")]),t._v(" "),s("td",[t._v("4")])]),t._v(" "),s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("[1,2,3]")]),t._v(" "),s("td",[t._v("3")]),t._v(" "),s("td",[t._v("[2,4,6]")]),t._v(" "),s("td",[t._v("6")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("3")]),t._v(" "),s("td",[t._v("[6,8]")]),t._v(" "),s("td",[t._v("6")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("[3,4]")]),t._v(" "),s("td",[t._v("4")]),t._v(" "),s("td",[t._v("[6,8]")]),t._v(" "),s("td",[t._v("8")])]),t._v(" "),s("tr",[s("td",[t._v("3")]),t._v(" "),s("td",[t._v("[ ]")]),t._v(" "),s("td",[t._v("0")]),t._v(" "),s("td",[t._v("[ ]")]),t._v(" "),s("td",[t._v("0")])])])])]),t._v(" "),s("h3",{attrs:{id:"_9-5-join子句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-join子句"}},[t._v("#")]),t._v(" 9.5 JOIN子句")]),t._v(" "),s("p",[t._v("ClickHouse的JOIN语法包含"),s("strong",[t._v("连接精度")]),t._v("和"),s("strong",[t._v("连接类型")]),t._v("两部分：连接精度+连接类型+JOIN")]),t._v(" "),s("p",[t._v("连接精度：ALL / ANY / ASOF (默认ALL)")]),t._v(" "),s("p",[t._v("连接类型：")]),t._v(" "),s("ol",[s("li",[t._v("外连接：LEFT / RIGHT / FULL(OUTER)")]),t._v(" "),s("li",[t._v("内连接：INNER")]),t._v(" "),s("li",[t._v("外连接：CROSS")])]),t._v(" "),s("h4",{attrs:{id:"_9-5-1-连接精度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-1-连接精度"}},[t._v("#")]),t._v(" 9.5.1 连接精度")]),t._v(" "),s("p",[t._v("ALL：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中全部连接数据。")]),t._v(" "),s("p",[t._v("ANY：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中"),s("strong",[t._v("第一行")]),t._v("连接数据。")]),t._v(" "),s("p",[t._v("ASOF：ASOF是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件 asof_column（感觉有点玄学，插个眼，mark）")]),t._v(" "),s("h4",{attrs:{id:"_9-5-2-连接类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-2-连接类型"}},[t._v("#")]),t._v(" 9.5.2 连接类型")]),t._v(" "),s("p",[t._v("跟MySQL一样")]),t._v(" "),s("h4",{attrs:{id:"_9-5-3-多表连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-3-多表连接"}},[t._v("#")]),t._v(" 9.5.3 多表连接")]),t._v(" "),s("p",[t._v("跟MySQL一样")]),t._v(" "),s("h4",{attrs:{id:"_9-5-4-注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-4-注意事项"}},[t._v("#")]),t._v(" 9.5.4 注意事项")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("关于性能")]),t._v(" "),s("p",[t._v("首先，应该遵循"),s("strong",[t._v("左大又小")]),t._v("的原则，即将数据量小的表放在右侧（跟MySQL或Hive的小表JOIN大表不太一样），因为ClickHouse中所有连接方式，右表都会被全部加载到内存中与左表进行比较。")]),t._v(" "),s("p",[t._v("其次，"),s("strong",[t._v("JOIN查询目前没有缓存的支持")]),t._v("，这意味着每一次JOIN查询，即便是连续执行的相同SQL，也都会生成一次全新的执行计划。故如果大量使用JOIN查询，则需要进一步考虑借助上次应用侧的缓存服务或使用JOIN表引擎来改善性能。")]),t._v(" "),s("p",[t._v("最后，如果是"),s("strong",[t._v("在大量维度属性不全的查询场景中，建议使用字典代替JOIN查询")]),t._v("。因为在进行多表的连接查询时，查询会转换成两两连接的形式，这种“滚雪球”式的查询很可能带来性能问题。")])]),t._v(" "),s("li",[s("p",[t._v("关于空值策略与简写形式")]),t._v(" "),s("p",[t._v("ClickHouse中连接查询的空值（未被连接的数据）是由默认值填充的，这跟其他常见的数据库的策略不同（由Null填充）。ClickHouse中连接查询的空值策略是通过"),s("code",[t._v("join_use_nulls")]),t._v("参数指定的，默认为0，默认充填0（当该参数为1时，空值由Null填充）。")]),t._v(" "),s("p",[t._v("此外，JOIN Key支持简化写法，当数据表的连接字段名相同时，可以用"),s("code",[t._v("USING")]),t._v("语法简写，例如下面两条语句的效果是等同的：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rate "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" join_tb1 a\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INNER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" join_tb2 b "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- USING简写")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("rate "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" join_tb1\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INNER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" join_tb2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("USING")]),t._v(" id\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"_9-6-where与prewhere子句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-6-where与prewhere子句"}},[t._v("#")]),t._v(" 9.6 WHERE与PREWHERE子句")]),t._v(" "),s("p",[t._v("WHERE子句基于条件表达式来实现数据过滤（这个跟其他数据库一样），如果过滤条件恰好是主键字段，则能够借助索引进一步加速查询，所以WHERE子句是查询语句能否启用索引的判断依据（前提是表引擎支持索引特性）。")]),t._v(" "),s("p",[t._v("PREWHERE目前只能用于MergeTree系列的表引擎，它是WHERE的一种优化，结果相同。它的不同之处在于：使用PREWHERE时，首先只会读取PREWHERE指定的列字段数据，用于数据过滤的条件判断，待数据过滤之后再读取SELECT声明的列字段以补全其余属性。所以再一些场合中PREWHERE相比WHERE处理的数据量更少（处理的数据行数可能没变，但是数据大小变小了），性能更高。")]),t._v(" "),s("p",[t._v("PREWHERE优化默认打开，会在条件合适的情况下将WHERE替换为PREWHERE，其参数设置语句如下：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" optimize_move_to_prewhere "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("--参数为0时强制关闭")]),t._v("\n")])])]),s("h3",{attrs:{id:"_9-7-group-by子句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-group-by子句"}},[t._v("#")]),t._v(" 9.7 GROUP BY子句")]),t._v(" "),s("p",[t._v("GROUP BY后声明的字段通常称为"),s("strong",[t._v("聚合键")]),t._v("或Key，在ClickHouse中的聚合查询中 SELECT 后只声明了聚合函数，则可以省略GROUP BY关键字，例如：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 \n")])])]),s("p",[t._v("SELECT的字段只能是聚合键、聚合函数，否则会报错。")]),t._v(" "),s("p",[t._v("除了上述特性外，聚合查询还能配合"),s("code",[t._v("WITH ROLLUP")]),t._v("、"),s("code",[t._v("WITH CUBE")]),t._v("、"),s("code",[t._v("WITH TOTALS")]),t._v("三种修饰符获取额外的汇总信息。")]),t._v(" "),s("h4",{attrs:{id:"_9-7-1-with-rollup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-1-with-rollup"}},[t._v("#")]),t._v(" 9.7.1 WITH ROLLUP")]),t._v(" "),s("p",[t._v("ROLLUP能够按照聚合键从右向左上卷，基于聚合函数依次生成分组小计和总计。如果聚合键为n​，则最终会生成小计的个数为n+1​。")]),t._v(" "),s("h4",{attrs:{id:"_9-7-2-with-rollup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-2-with-rollup"}},[t._v("#")]),t._v(" 9.7.2 WITH ROLLUP")]),t._v(" "),s("p",[t._v("CUBE会像立方体模型一样，基于聚合键之间所有的组合生成小计信息。如果聚合键为n，则最终会生成小计的个数为2的n​次方。")]),t._v(" "),s("h4",{attrs:{id:"_9-7-3-with-totals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-7-3-with-totals"}},[t._v("#")]),t._v(" 9.7.3 WITH TOTALS")]),t._v(" "),s("p",[t._v("TOTALS会基于聚合函数对所有数据进行总计，例如：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" a1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" a1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" TOTALS\n")])])]),s("p",[t._v("其结果会额外显示累计总和的结果。")]),t._v(" "),s("h3",{attrs:{id:"_9-10-limit-by子句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-10-limit-by子句"}},[t._v("#")]),t._v(" 9.10 LIMIT BY子句")]),t._v(" "),s("p",[t._v("LIMIT BY子句运行于ORDER BY 之后和LIMIT之前，最多返回"),s("strong",[t._v("前n​个字段")]),t._v("的数据，其常规语法如下：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" 字段\n")])])]),s("h2",{attrs:{id:"第10章"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第10章"}},[t._v("#")]),t._v(" 第10章")]),t._v(" "),s("h3",{attrs:{id:"_10-1-概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-概述"}},[t._v("#")]),t._v(" 10.1 概述")]),t._v(" "),s("p",[t._v("用Nx表示一个节点（服务器），例如N1,N2")]),t._v(" "),s("p",[t._v("副本和分片有时候一样，有时候不一样，区分方法：")]),t._v(" "),s("p",[t._v("如果N1的Y和N2的Y数据相同，则它们互为副本（N1Y = N2Y），否则互为分片（N1Y != N2Y）")]),t._v(" "),s("h3",{attrs:{id:"_10-2-数据副本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-数据副本"}},[t._v("#")]),t._v(" 10.2 数据副本")]),t._v(" "),s("p",[t._v("MegreTree表引擎前缀加了Replicated才有应用副本的能力（还有另一种副本的实现方式），例如ReplicatedMergeTree、ReplicatedReplacingMergeTree、ReplicatedSummingMergeTree，这类表引擎称为复制表系列引擎。")]),t._v(" "),s("p",[t._v("ReplicatedMergeTree在MergeTree的基础上加入了分布式协同的能力，如图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png",width:"70%"}})]),t._v(" "),s("p",[t._v("在MergeTree中，一个数据分区由开始创建到全部完成，会经历两类存储区域：")]),t._v(" "),s("ol",[s("li",[t._v("内存：数据首先会被写入内存缓冲区")]),t._v(" "),s("li",[t._v("本地磁盘：数据接着会被写入tmp临时目录分区，待全部完成后再将临时目录重新命名为正式分区")])]),t._v(" "),s("ul",[s("li",[t._v("ReplicatedMergeTree在上述基础上增加了Zookeeper的部分，它会进一步在Zookeeper内创建一系列的监听节点，并以此实现多个实例之间的通信。在整个通信过程中，Zookeeper并不会涉及数据表的传输。")])]),t._v(" "),s("h3",{attrs:{id:"_10-3-replicatedmergetree原理解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-replicatedmergetree原理解析"}},[t._v("#")]),t._v(" 10.3 ReplicatedMergeTree原理解析")]),t._v(" "),s("p",[t._v("ReplicatedMergeTree的核心逻辑中，大量运用了Zookeeper的能力，以实现ReplicatedMergeTree副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和BlockID去重判断等。")]),t._v(" "),s("p",[t._v("副本协同的核心流程主要有"),s("strong",[t._v("INSERT")]),t._v("、"),s("strong",[t._v("MERGE")]),t._v("、"),s("strong",[t._v("MUTATION")]),t._v("、"),s("strong",[t._v("ALTER")]),t._v("，分别对应了数据写入、分区合并、数据修改、元数据修改。（其他查询不支持分布式执行，包括SELECT、CREATE、DROP、RENAME、ATTACH）")]),t._v(" "),s("p",[t._v("拟定一个用ReplicatedMergeTree实现一张拥有1分片、1副本的数据表的演示场景，其完整过程如下：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("INSERT的核心执行流程")]),t._v(" "),s("ol",[s("li",[t._v("创建第一个副本实例")]),t._v(" "),s("li",[t._v("创建第二个副本实例")]),t._v(" "),s("li",[t._v("向第一个副本实例写入数据")]),t._v(" "),s("li",[t._v("由第一个副本实例推送Log日志")]),t._v(" "),s("li",[t._v("第二个副本实例拉取Log日志")]),t._v(" "),s("li",[t._v("第二个副本实例向其他副本发起下载请求")]),t._v(" "),s("li",[t._v("第一个副本实例响应数据下载")]),t._v(" "),s("li",[t._v("第二个实例下载数据并完成本地写入")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("MERGE的核心执行流程")]),t._v(" "),s("ol",[s("li",[t._v("创建远程连接，尝试与主副本通信")]),t._v(" "),s("li",[t._v("主副本接收通信")]),t._v(" "),s("li",[t._v("由主副本制定MERGE计划并推送Log日志")]),t._v(" "),s("li",[t._v("各副本分别拉取Log日志")]),t._v(" "),s("li",[t._v("各个副本分别在本地执行MERGE")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("MUTATION的核心执行流程")]),t._v(" "),s("ol",[s("li",[t._v("推送MUTATION日志")]),t._v(" "),s("li",[t._v("所有副本实例各自监听MUTATION日志")]),t._v(" "),s("li",[t._v("由主副本实例响应MUTATION日志并推送Log日志")]),t._v(" "),s("li",[t._v("各个副本实例分别拉取Log日志")]),t._v(" "),s("li",[t._v("各个副本实例分别在本地执行MUTATION")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("ALTER的核心执行流程")]),t._v(" "),s("ol",[s("li",[t._v("修改共享元数据")]),t._v(" "),s("li",[t._v("监听共享元数据变更并各自执行本地修改")]),t._v(" "),s("li",[t._v("确认所有副本完成修改")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png",alt:""}})])])]),t._v(" "),s("h3",{attrs:{id:"_10-4-数据分片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-数据分片"}},[t._v("#")]),t._v(" 10.4 数据分片")]),t._v(" "),s("p",[t._v("通过引入副本可以有效降低数据丢失的风险（多份存储），并提升查询的性能（分摊查询、读写分离），但是仍没有解决数据表容量的问题。每个副本保存了数据表全量的数据，所以在业务庞大的场景中，依靠副本并不能解决单表的性能瓶颈，所以需要将数据水平切分，也就分片（shard）。")]),t._v(" "),s("p",[t._v("数据表A分布在N个ClickHouse服务节点，且这些数据彼此之间没有重复数据，则称为数据表A有N个分片。为了进一步考虑数据在写入时，如何被均匀地写至各个分片，以及查询时路由到每个分片并组成结果集，所以ClickHouse的数据分片需要结合Distributed表引擎一同使用，如图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png",width:"60%"}})]),t._v(" "),s("p",[t._v("Distributed表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。")]),t._v(" "),s("p",[t._v("接下来以创建test_1_local的过程为例子，解释分布式DDL的核心执行流程")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("分布式DDL的核心执行流程")]),t._v(" "),s("ol",[s("li",[t._v("推送DDL日志")]),t._v(" "),s("li",[t._v("拉取日志并执行")]),t._v(" "),s("li",[t._v("确认执行进度")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png",width:"60%"}})])])]),t._v(" "),s("h3",{attrs:{id:"_10-5-distributed原理解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-5-distributed原理解析"}},[t._v("#")]),t._v(" 10.5 Distributed原理解析")]),t._v(" "),s("p",[t._v("Distributed表引擎是作为数据分片的透明代理，能自动路由数据至集群中的各个节点，所以Distributed表引擎和其他数据表一起协同工作，如图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png",width:"60%"}})]),t._v(" "),s("ul",[s("li",[t._v("本地表：通常以 _local 为后缀进行命名。本地表是承载数据的载体，可以使用非Distributed的任意表引擎，一张本地表对应了一个数据分片")]),t._v(" "),s("li",[t._v("分布式表：通常以 _all 为后缀进行命名。分布式表只能用Distributed表引擎，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表")])])],1)}),[],!1,null,null,null);"function"==typeof e&&e(v);a.default=v.exports}}]);