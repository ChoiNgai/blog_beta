<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《鸟哥的 Linux 私房菜》 | 大数据技术文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="./favicon.ico">
    <meta name="description" content="从入门到入土">
    
    <link rel="preload" href="./assets/css/0.styles.8b017a1a.css" as="style"><link rel="preload" href="./assets/js/app.dbe5dc78.js" as="script"><link rel="preload" href="./assets/js/2.fa5f1a4a.js" as="script"><link rel="preload" href="./assets/js/64.abb48239.js" as="script"><link rel="prefetch" href="./assets/js/10.af7e6d14.js"><link rel="prefetch" href="./assets/js/100.f98d6b7c.js"><link rel="prefetch" href="./assets/js/101.3ebb2df2.js"><link rel="prefetch" href="./assets/js/102.bddf26fd.js"><link rel="prefetch" href="./assets/js/103.3c13d131.js"><link rel="prefetch" href="./assets/js/104.76e7b64f.js"><link rel="prefetch" href="./assets/js/105.b8907b13.js"><link rel="prefetch" href="./assets/js/106.26f679d0.js"><link rel="prefetch" href="./assets/js/107.7670ff83.js"><link rel="prefetch" href="./assets/js/108.c620cb38.js"><link rel="prefetch" href="./assets/js/109.394140cc.js"><link rel="prefetch" href="./assets/js/11.99d58157.js"><link rel="prefetch" href="./assets/js/110.8a03d1ab.js"><link rel="prefetch" href="./assets/js/111.709e74df.js"><link rel="prefetch" href="./assets/js/112.e7c7c661.js"><link rel="prefetch" href="./assets/js/113.b9c7ba9e.js"><link rel="prefetch" href="./assets/js/114.45aede8c.js"><link rel="prefetch" href="./assets/js/115.1ad69003.js"><link rel="prefetch" href="./assets/js/116.0f4944de.js"><link rel="prefetch" href="./assets/js/117.338b1f46.js"><link rel="prefetch" href="./assets/js/118.56fa4871.js"><link rel="prefetch" href="./assets/js/119.1374f6e2.js"><link rel="prefetch" href="./assets/js/12.2e190b00.js"><link rel="prefetch" href="./assets/js/120.7e3bde42.js"><link rel="prefetch" href="./assets/js/121.bf4c105b.js"><link rel="prefetch" href="./assets/js/122.9678e246.js"><link rel="prefetch" href="./assets/js/123.4f9c51b8.js"><link rel="prefetch" href="./assets/js/124.6ed32d31.js"><link rel="prefetch" href="./assets/js/125.c1c1f240.js"><link rel="prefetch" href="./assets/js/126.f7dae67d.js"><link rel="prefetch" href="./assets/js/127.aa5de251.js"><link rel="prefetch" href="./assets/js/128.7a097fcd.js"><link rel="prefetch" href="./assets/js/129.62b823c3.js"><link rel="prefetch" href="./assets/js/13.5d4714fa.js"><link rel="prefetch" href="./assets/js/130.04125268.js"><link rel="prefetch" href="./assets/js/131.f93632b5.js"><link rel="prefetch" href="./assets/js/132.8efcb3ab.js"><link rel="prefetch" href="./assets/js/133.045ade7e.js"><link rel="prefetch" href="./assets/js/134.82af04a6.js"><link rel="prefetch" href="./assets/js/135.06de65c0.js"><link rel="prefetch" href="./assets/js/136.3fc5ce45.js"><link rel="prefetch" href="./assets/js/137.ca4e288e.js"><link rel="prefetch" href="./assets/js/138.f8e9409a.js"><link rel="prefetch" href="./assets/js/139.51cc74b3.js"><link rel="prefetch" href="./assets/js/14.cd95effa.js"><link rel="prefetch" href="./assets/js/15.d7a053dc.js"><link rel="prefetch" href="./assets/js/16.241383de.js"><link rel="prefetch" href="./assets/js/17.cdf37f90.js"><link rel="prefetch" href="./assets/js/18.54a8e3ff.js"><link rel="prefetch" href="./assets/js/19.b1f41278.js"><link rel="prefetch" href="./assets/js/20.00809aa4.js"><link rel="prefetch" href="./assets/js/21.ed4af20e.js"><link rel="prefetch" href="./assets/js/22.d70e789f.js"><link rel="prefetch" href="./assets/js/23.4bd4acfc.js"><link rel="prefetch" href="./assets/js/24.b68c0ece.js"><link rel="prefetch" href="./assets/js/25.56ed8a43.js"><link rel="prefetch" href="./assets/js/26.6bcb257f.js"><link rel="prefetch" href="./assets/js/27.c00845f2.js"><link rel="prefetch" href="./assets/js/28.6badc057.js"><link rel="prefetch" href="./assets/js/29.9230aae3.js"><link rel="prefetch" href="./assets/js/3.b52d03f5.js"><link rel="prefetch" href="./assets/js/30.24beb61e.js"><link rel="prefetch" href="./assets/js/31.f2a94727.js"><link rel="prefetch" href="./assets/js/32.a3ba2747.js"><link rel="prefetch" href="./assets/js/33.c524bae4.js"><link rel="prefetch" href="./assets/js/34.163f85b3.js"><link rel="prefetch" href="./assets/js/35.c42df8de.js"><link rel="prefetch" href="./assets/js/36.03d4748a.js"><link rel="prefetch" href="./assets/js/37.07cd39b4.js"><link rel="prefetch" href="./assets/js/38.18db04a1.js"><link rel="prefetch" href="./assets/js/39.c1633a4e.js"><link rel="prefetch" href="./assets/js/4.1d0a3544.js"><link rel="prefetch" href="./assets/js/40.a49e9f5c.js"><link rel="prefetch" href="./assets/js/41.0490672b.js"><link rel="prefetch" href="./assets/js/42.03ff0a41.js"><link rel="prefetch" href="./assets/js/43.7567d202.js"><link rel="prefetch" href="./assets/js/44.e36ca589.js"><link rel="prefetch" href="./assets/js/45.5b0f064d.js"><link rel="prefetch" href="./assets/js/46.11d921c5.js"><link rel="prefetch" href="./assets/js/47.f961d914.js"><link rel="prefetch" href="./assets/js/48.ba14e041.js"><link rel="prefetch" href="./assets/js/49.566ddc43.js"><link rel="prefetch" href="./assets/js/5.cc194294.js"><link rel="prefetch" href="./assets/js/50.b70961ac.js"><link rel="prefetch" href="./assets/js/51.3c084f92.js"><link rel="prefetch" href="./assets/js/52.14662c12.js"><link rel="prefetch" href="./assets/js/53.c40aa86f.js"><link rel="prefetch" href="./assets/js/54.300e2058.js"><link rel="prefetch" href="./assets/js/55.3b06c210.js"><link rel="prefetch" href="./assets/js/56.227ea682.js"><link rel="prefetch" href="./assets/js/57.19a5d767.js"><link rel="prefetch" href="./assets/js/58.7fc8ce3f.js"><link rel="prefetch" href="./assets/js/59.9abc1a7f.js"><link rel="prefetch" href="./assets/js/6.a67b19a4.js"><link rel="prefetch" href="./assets/js/60.21e470b2.js"><link rel="prefetch" href="./assets/js/61.342c1882.js"><link rel="prefetch" href="./assets/js/62.b8d083e4.js"><link rel="prefetch" href="./assets/js/63.d98056bc.js"><link rel="prefetch" href="./assets/js/65.06d2edcf.js"><link rel="prefetch" href="./assets/js/66.11f32f94.js"><link rel="prefetch" href="./assets/js/67.55fb49ed.js"><link rel="prefetch" href="./assets/js/68.6a9fb92c.js"><link rel="prefetch" href="./assets/js/69.ea206161.js"><link rel="prefetch" href="./assets/js/7.4db7fac4.js"><link rel="prefetch" href="./assets/js/70.19b21c67.js"><link rel="prefetch" href="./assets/js/71.6d30915f.js"><link rel="prefetch" href="./assets/js/72.c663480f.js"><link rel="prefetch" href="./assets/js/73.c64a8bc9.js"><link rel="prefetch" href="./assets/js/74.b4853538.js"><link rel="prefetch" href="./assets/js/75.ed723be5.js"><link rel="prefetch" href="./assets/js/76.bd2efea1.js"><link rel="prefetch" href="./assets/js/77.8e8632d7.js"><link rel="prefetch" href="./assets/js/78.69ef8849.js"><link rel="prefetch" href="./assets/js/79.9785ef8d.js"><link rel="prefetch" href="./assets/js/8.eace717d.js"><link rel="prefetch" href="./assets/js/80.5365bfc6.js"><link rel="prefetch" href="./assets/js/81.69b36a86.js"><link rel="prefetch" href="./assets/js/82.aad515c0.js"><link rel="prefetch" href="./assets/js/83.050ac97d.js"><link rel="prefetch" href="./assets/js/84.78bb8c43.js"><link rel="prefetch" href="./assets/js/85.feeffda7.js"><link rel="prefetch" href="./assets/js/86.f38af2cb.js"><link rel="prefetch" href="./assets/js/87.3c875b53.js"><link rel="prefetch" href="./assets/js/88.ccc36d1b.js"><link rel="prefetch" href="./assets/js/89.44e2573e.js"><link rel="prefetch" href="./assets/js/9.3a163afb.js"><link rel="prefetch" href="./assets/js/90.816482fc.js"><link rel="prefetch" href="./assets/js/91.9072f45b.js"><link rel="prefetch" href="./assets/js/92.858235e2.js"><link rel="prefetch" href="./assets/js/93.ef35de87.js"><link rel="prefetch" href="./assets/js/94.2701ba5d.js"><link rel="prefetch" href="./assets/js/95.666433f2.js"><link rel="prefetch" href="./assets/js/96.f2b93c96.js"><link rel="prefetch" href="./assets/js/97.cb6eb699.js"><link rel="prefetch" href="./assets/js/98.8f172db0.js"><link rel="prefetch" href="./assets/js/99.26797ef8.js">
    <link rel="stylesheet" href="./assets/css/0.styles.8b017a1a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">大数据技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link router-link-active">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link router-link-active">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Linux</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./coding-base/linux/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/./coding-base/linux/Linux基础命令.html" class="sidebar-link">Linux基础命令</a></li><li><a href="/./coding-base/linux/Linux大数据框架命令.html" class="sidebar-link">Linux大数据框架命令</a></li><li><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html" class="active sidebar-link">《鸟哥的 Linux 私房菜》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-电脑-辅助人脑的好工具" class="sidebar-link">0.1 电脑：辅助人脑的好工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-1-电脑硬件的五大单元" class="sidebar-link">0.1.1 电脑硬件的五大单元</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-2-一切设计的起点-cpu-的架构" class="sidebar-link">0.1.2 一切设计的起点：CPU 的架构</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-3-其他单元的设备" class="sidebar-link">0.1.3 其他单元的设备</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-4-运作流程" class="sidebar-link">0.1.4 运作流程</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-5-电脑的分类" class="sidebar-link">0.1.5 电脑的分类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-1-6-电脑上面常用的计算单位-容量、速度等" class="sidebar-link">0.1.6 电脑上面常用的计算单位（容量、速度等）</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-个人电脑架构与相关设备组件" class="sidebar-link">0.2 个人电脑架构与相关设备组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-1-执行运算与判断的-cpu" class="sidebar-link">0.2.1 执行运算与判断的 CPU</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-2-内存" class="sidebar-link">0.2.2 内存</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-3-显卡" class="sidebar-link">0.2.3 显卡</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-4-硬盘与存储设备" class="sidebar-link">0.2.4 硬盘与存储设备</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-5-扩展卡与接口" class="sidebar-link">0.2.5 扩展卡与接口</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-6-主板" class="sidebar-link">0.2.6 主板</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-2-7-主机电源" class="sidebar-link">0.2.7 主机电源</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-3-数据表示方式" class="sidebar-link">0.3 数据表示方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-3-1-数字系统" class="sidebar-link">0.3.1 数字系统</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-3-2-字符编码系统" class="sidebar-link">0.3.2 字符编码系统</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-4-软件程序运行" class="sidebar-link">0.4 软件程序运行</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-4-1-机器语言程序与编译型程序" class="sidebar-link">0.4.1 机器语言程序与编译型程序</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-4-2-操作系统" class="sidebar-link">0.4.2 操作系统</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_0-4-3-应用程序" class="sidebar-link">0.4.3 应用程序</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-1-linux-是什么" class="sidebar-link">1.1 Linux 是什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-1-1-linux-是什么-操作系统-应用程序" class="sidebar-link">1.1.1 Linux 是什么？操作系统/应用程序？</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-1-2-linux-之前-unix-的历史" class="sidebar-link">1.1.2 Linux 之前，UNIX 的历史</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-1-3-关于-gnu-计划-自由软件与开发源代码" class="sidebar-link">1.1.3 关于 GNU 计划，自由软件与开发源代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-托瓦兹的-linux-的发展" class="sidebar-link">1.2 托瓦兹的 Linux 的发展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-1-与-minix-之间" class="sidebar-link">1.2.1 与 Minix 之间</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-2-对-386-硬件的多任务测试" class="sidebar-link">1.2.2 对 386 硬件的多任务测试</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-3-初次发布-linux-0-02" class="sidebar-link">1.2.3 初次发布 Linux 0.02</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-4-linux-的发展-虚拟团队的产生" class="sidebar-link">1.2.4 Linux 的发展：虚拟团队的产生</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-5-linux-的内核版本" class="sidebar-link">1.2.5 Linux 的内核版本</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-2-6-linux-发行版" class="sidebar-link">1.2.6 Linux 发行版</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-3-linux-当前应用的角色" class="sidebar-link">1.3 Linux 当前应用的角色</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-3-1-企业环境的使用" class="sidebar-link">1.3.1 企业环境的使用</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-3-2-个人环境的使用" class="sidebar-link">1.3.2 个人环境的使用</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-3-3-云端应用" class="sidebar-link">1.3.3 云端应用</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_1-4-linux-该如何学习" class="sidebar-link">1.4 Linux 该如何学习</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-1-linux-与硬件的搭配" class="sidebar-link">2.1 Linux 与硬件的搭配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-1-1-认识计算机的硬件设备" class="sidebar-link">2.1.1 认识计算机的硬件设备</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-1-2-选择与-linux-搭配的主机设备" class="sidebar-link">2.1.2 选择与 Linux 搭配的主机设备</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-1-3-各硬件设备在-linux-中的文件名" class="sidebar-link">2.1.3 各硬件设备在 Linux 中的文件名</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-1-4-使用虚拟机学习" class="sidebar-link">2.1.4 使用虚拟机学习</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-2-磁盘分区" class="sidebar-link">2.2 磁盘分区</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-2-1-磁盘连接方式与设备文件名的关系" class="sidebar-link">2.2.1 磁盘连接方式与设备文件名的关系</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-2-2-mbr-ms-dos-与-gpt-磁盘分区表-partition-table" class="sidebar-link">2.2.2 MBR（MS-DOS）与 GPT 磁盘分区表（partition table）</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-2-3-启动流程中的-bios-与-uefi-启动检测程序" class="sidebar-link">2.2.3 启动流程中的 BIOS 与 UEFI 启动检测程序</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-2-4-linux-安装模式下-磁盘分区的选择" class="sidebar-link">2.2.4 Linux 安装模式下，磁盘分区的选择</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_2-3-安装-linux-前的规划" class="sidebar-link">2.3 安装 Linux 前的规划</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-1-首次登录系统" class="sidebar-link">4.1 首次登录系统</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-2-命令行模式下命令的执行" class="sidebar-link">4.2 命令行模式下命令的执行</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-2-1-开始执行命令" class="sidebar-link">4.2.1 开始执行命令</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-2-2-基础命令的操作" class="sidebar-link">4.2.2 基础命令的操作</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-2-3-重要的几个热键-tab-、-ctrl-c、-ctrl-d" class="sidebar-link">4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-2-4-错误信息的查看" class="sidebar-link">4.2.4 错误信息的查看</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-3-linux-系统的在线求助-man-page-与-info-page" class="sidebar-link">4.3 Linux 系统的在线求助 man page 与 info page</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-4-超简单的文本编辑器-nano" class="sidebar-link">4.4 超简单的文本编辑器：nano</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_4-5-正确的关机方法" class="sidebar-link">4.5 正确的关机方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-1-用户与用户组" class="sidebar-link">5.1 用户与用户组</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-2-linux-文件权限概念" class="sidebar-link">5.2 Linux 文件权限概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-2-1-linux-文件属性" class="sidebar-link">5.2.1 Linux 文件属性</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-2-2-如何修改文件属性与权限" class="sidebar-link">5.2.2 如何修改文件属性与权限</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-2-3-目录与文件的权限意义" class="sidebar-link">5.2.3 目录与文件的权限意义</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-2-4-linux-文件种类与扩展名" class="sidebar-link">5.2.4 Linux 文件种类与扩展名</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-3-linux-目录配置" class="sidebar-link">5.3 Linux 目录配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-3-1-linux-目录配置的依据-fhs" class="sidebar-link">5.3.1 Linux 目录配置的依据——FHS</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-3-2-目录树" class="sidebar-link">5.3.2 目录树</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-3-3-绝对路径与相对路径" class="sidebar-link">5.3.3 绝对路径与相对路径</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_5-3-4-centos-的观察" class="sidebar-link">5.3.4 CentOS 的观察</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-1-目录与路径" class="sidebar-link">6.1 目录与路径</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-1-1-相对路径与绝对路径" class="sidebar-link">6.1.1 相对路径与绝对路径</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-1-2-目录的相关操作" class="sidebar-link">6.1.2 目录的相关操作</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-1-3-关于执行文件路径的变量-path" class="sidebar-link">6.1.3 关于执行文件路径的变量：$PATH</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-2-文件与目录管理" class="sidebar-link">6.2 文件与目录管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-2-1-文件与目录的查看-ls" class="sidebar-link">6.2.1 文件与目录的查看：ls</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-2-2-复制、删除与移动-cp、rm、mv" class="sidebar-link">6.2.2 复制、删除与移动：cp、rm、mv</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-2-3-获取路径的文件名与目录名称" class="sidebar-link">6.2.3 获取路径的文件名与目录名称</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-文件内容查看" class="sidebar-link">6.3 文件内容查看</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-1-直接查看文件内容" class="sidebar-link">6.3.1 直接查看文件内容</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-2-可翻页查看" class="sidebar-link">6.3.2 可翻页查看</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-3-数据截取" class="sidebar-link">6.3.3 数据截取</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-4-非纯文本文件-od" class="sidebar-link">6.3.4 非纯文本文件：od</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-3-5-修改文件时间或创建新文件-touch" class="sidebar-link">6.3.5 修改文件时间或创建新文件：touch</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-4-文件与目录的默认权限与隐藏权限" class="sidebar-link">6.4 文件与目录的默认权限与隐藏权限</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-4-1-文件默认权限-umask" class="sidebar-link">6.4.1 文件默认权限：umask</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-4-2-文件隐藏属性" class="sidebar-link">6.4.2 文件隐藏属性</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-4-3-文件特殊权限-suid、sgid、sbit" class="sidebar-link">6.4.3 文件特殊权限：SUID、SGID、SBIT</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-4-4-观察文件类型-file" class="sidebar-link">6.4.4 观察文件类型：file</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-5-命令与文件的查找" class="sidebar-link">6.5 命令与文件的查找</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-5-1-脚本文件的查找" class="sidebar-link">6.5.1 脚本文件的查找</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_6-5-2-文件的查找" class="sidebar-link">6.5.2 文件的查找</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-认识-linux-文件系统" class="sidebar-link">7.1 认识 Linux 文件系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-1-磁盘组成与分区的复习" class="sidebar-link">7.1.1 磁盘组成与分区的复习</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-2-文件系统特性" class="sidebar-link">7.1.2 文件系统特性</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-3-linux-的-ext2-文件系统-inode" class="sidebar-link">7.1.3 Linux 的 ext2 文件系统（inode）</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-4-与目录树的关系" class="sidebar-link">7.1.4 与目录树的关系</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-5-ext2-ext3-ext4-文件的存取与日志式文件系统的功能" class="sidebar-link">7.1.5 ext2/ext3/ext4 文件的存取与日志式文件系统的功能</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-6-linux-文件系统的运行" class="sidebar-link">7.1.6 Linux 文件系统的运行</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-7-挂载点的意义" class="sidebar-link">7.1.7 挂载点的意义</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-8-其他-linux-支持的文件系统与-vfs" class="sidebar-link">7.1.8 其他 Linux 支持的文件系统与 VFS</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-1-9-xfs-文件系统简介" class="sidebar-link">7.1.9 XFS 文件系统简介</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-2-文件系统的简单操作" class="sidebar-link">7.2 文件系统的简单操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-2-1-磁盘与目录的容量" class="sidebar-link">7.2.1 磁盘与目录的容量</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-2-2-硬链接与符号链接-ln" class="sidebar-link">7.2.2 硬链接与符号链接：ln</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-磁盘的分区、格式化、检验与挂载" class="sidebar-link">7.3 磁盘的分区、格式化、检验与挂载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-1-观察磁盘分区状态" class="sidebar-link">7.3.1 观察磁盘分区状态</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-2-磁盘分区-gdisk-fdisk" class="sidebar-link">7.3.2 磁盘分区：gdisk/fdisk</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-3-磁盘格式化-创建文件系统" class="sidebar-link">7.3.3 磁盘格式化（创建文件系统）</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-4-文件系统检验" class="sidebar-link">7.3.4 文件系统检验</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-5-文件系统挂载与卸载" class="sidebar-link">7.3.5 文件系统挂载与卸载</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-3-6-磁盘-文件系统参数自定义" class="sidebar-link">7.3.6 磁盘/文件系统参数自定义</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-4-设置启动挂载" class="sidebar-link">7.4 设置启动挂载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-4-1-启动挂载-etc-fstab-及-etc-mtab" class="sidebar-link">7.4.1 启动挂载 /etc/fstab 及 /etc/mtab</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-4-2-特殊设备-loop-挂载" class="sidebar-link">7.4.2 特殊设备 loop 挂载</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-5-内存交换分区-swap-创建" class="sidebar-link">7.5 内存交换分区（swap）创建</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-5-1-使用物理分区创建内存交换分区" class="sidebar-link">7.5.1 使用物理分区创建内存交换分区</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-5-2-使用文件创建内存交换文件" class="sidebar-link">7.5.2 使用文件创建内存交换文件</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_7-6-文件系统的特殊观察与操作" class="sidebar-link">7.6 文件系统的特殊观察与操作</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-1-压缩文件的用途与技术" class="sidebar-link">8.1 压缩文件的用途与技术</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-2-linux-系统常见的压缩命令" class="sidebar-link">8.2 Linux 系统常见的压缩命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-2-1-gzip-zcat-zmore-zless-zgrep" class="sidebar-link">8.2.1 gzip，zcat/zmore/zless/zgrep</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-2-2-bzip2-bzcat-bzmore-bzless-bzgrep" class="sidebar-link">8.2.2 bzip2，bzcat/bzmore/bzless/bzgrep</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-2-3-xz-xzcat-xzmore-xzless-xzgrep" class="sidebar-link">8.2.3 xz，xzcat/xzmore/xzless/xzgrep</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-3-打包命令-tar" class="sidebar-link">8.3 打包命令：tar</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-4-xfs-文件系统的备份与还原" class="sidebar-link">8.4 XFS 文件系统的备份与还原</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-5-光盘写入工具" class="sidebar-link">8.5 光盘写入工具</a></li><li class="sidebar-sub-header"><a href="/./coding-base/linux/《鸟哥的 Linux 私房菜》（语雀：北冥有鱼）.html#_8-6-其他常见的压缩与备份工具" class="sidebar-link">8.6 其他常见的压缩与备份工具</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《鸟哥的-linux-私房菜》"><a href="#《鸟哥的-linux-私房菜》" class="header-anchor">#</a> 《鸟哥的 Linux 私房菜》</h1> <blockquote><p>原文链接：https://www.yuque.com/beimingyouyu-9woka/computer/stette</p></blockquote> <h1 id="第一部分-检验linux-的规则与安装"><a href="#第一部分-检验linux-的规则与安装" class="header-anchor">#</a> 第一部分 检验Linux 的规则与安装</h1> <h1 id="_0-计算机概论"><a href="#_0-计算机概论" class="header-anchor">#</a> 0 计算机概论</h1> <hr> <h2 id="_0-1-电脑-辅助人脑的好工具"><a href="#_0-1-电脑-辅助人脑的好工具" class="header-anchor">#</a> 0.1 电脑：辅助人脑的好工具</h2> <p>所谓的电脑就是一种计算机，而计算机其实是：<strong>接受用户输入的命令与数据，经由中央处理器的算术与逻辑单元运算处理后，产生或存储成有用的信息</strong>。</p> <h3 id="_0-1-1-电脑硬件的五大单元"><a href="#_0-1-1-电脑硬件的五大单元" class="header-anchor">#</a> 0.1.1 电脑硬件的五大单元</h3> <p>关于电脑的硬件组成部分主要可分为如下三个部分：</p> <ul><li><p>输入单元</p></li> <li><p>输出单元</p></li> <li><p>主机部分</p></li></ul> <p>整台主机的重点在于中央处理器（Central Processing Unit，CPU），CPU 为<strong>一个具有特定功能的芯片，里面含有指令集</strong>，如果你想要让主机进行什么特殊的功能，就得要参考这块 CPU 是否有相关内置的指令集。</p> <p>由于 CPU 的工作主要在于管理与运算，因此在 CPU 内又可分为两个主要的单元，分别是：<strong>算术逻辑单元与控制单元</strong>。其中算术逻辑单元主要负责程序运算与逻辑判断，控制单元则主要协调各周边组件与各单元间的工作。</p> <p><strong>CPU 读取的数据都是从内存来的</strong>，内存中的数据则是从输入单元所传输进来的，而 CPU 处理完毕的数据也必须要先写回内存，最后数据才从内存传输到输出单元。</p> <p>综上所述，我们会知道其实电脑是由几个单元所组成的，包括<strong>输入单元</strong>、<strong>输出单元</strong>、CPU 内部的<strong>控制单元</strong>、<strong>算术逻辑单元</strong>与<strong>内存</strong>五大部分。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597193952339-e96b6159-e947-4244-8aff-483f5d9b02d1.png" alt="img"></p> <p>上面图例中的<strong>系统单元</strong>其实指的就是电脑机箱内的主要组件，而重点在于 CPU 与内存。特别要注意的是实线部分的传输方向，<strong>基本上数据都是通过内存再流出去的</strong>。至于数据会流进/流出内存则是由 CPU 所发出的命令控制。而 CPU 实际要处理的数据则完全来自于内存（不管是程序还是一般文件数据）。</p> <h3 id="_0-1-2-一切设计的起点-cpu-的架构"><a href="#_0-1-2-一切设计的起点-cpu-的架构" class="header-anchor">#</a> 0.1.2 一切设计的起点：CPU 的架构</h3> <p>如前所述，CPU 内部已经含有一些微指令，我们所使用的软件都要经过 CPU 内部的指令集来完成。这些指令集的设计又主要分为两种设计理念，这就是目前世界上最常见的两种 CPU 架构，分别是：精简指令集（RISC）与复杂指令集（CISC）系统。</p> <ol><li><strong>精简指令集（Reduced Instruction Set Computer，RISC）</strong></li></ol> <p>这种 CPU 的设计中，指令集较为精简，每个指令的运行时间都很短，完成的操作也很简单，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 指令集 CPU 主要有甲骨文（Oracle）公司的 SPARC 系列、IBM 公司的 Power Architecture（包括 PowerPC）系列与 ARM 公司（ARM Holdings）的 ARM CPU 系列等。</p> <ol><li><strong>复杂指令集（Complex Instruction Set Computer，CISC）</strong></li></ol> <p>与 RISC 不同的是，CISC 指令集的每个小指令可以执行一些较底层的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂，所以每条指令花费的时间较长，但每个单条指令可以处理的工作较为丰富。常见的使用 CISC 指令集的 CPU 有 AMD、Intel、VIA 等 x86 架构的 CPU。</p> <p>由于 AMD、Intel、VIA 所开发出来的 x86 架构 CPU 被大量使用于个人电脑，因此，个人电脑常被称为 x86 架构电脑。那为何称为 x86 架构？这是因为最早的那块 Intel 研发出来的 CPU 代号称为 8086，后来依此架构又开发出 80286、80386 等，因此这种架构的 CPU 就被称为 x86 架构了。</p> <p>在 2003 年以前由 Intel 所开发的 x86 架构 CPU 由 8 位升级到 16、32 位，后来 AMD 依此架构修改新一代的 CPU 为 64 位，为了区别两者的差异，因此 64 位的个人电脑 CPU 又被称为 x86-64 架构。</p> <p><strong>64 位 CPU 代表 CPU 一次可以读写 64 位的数据，32 位 CPU 则是 CPU 一次能读取 32 位的意思。因为 CPU 读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以，一般 32 位的 CPU 所能读写的最大数据量，大概就是 4 GB。</strong></p> <h3 id="_0-1-3-其他单元的设备"><a href="#_0-1-3-其他单元的设备" class="header-anchor">#</a> 0.1.3 其他单元的设备</h3> <ul><li><p>系统单元</p></li> <li><p>存储单元</p></li> <li><p>输入、输出单元</p></li></ul> <h3 id="_0-1-4-运作流程"><a href="#_0-1-4-运作流程" class="header-anchor">#</a> 0.1.4 运作流程</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1600763633992-8b1922cc-a9b0-4a1c-93a9-ad36ff1d42fa.png" alt="img"></p> <h3 id="_0-1-5-电脑的分类"><a href="#_0-1-5-电脑的分类" class="header-anchor">#</a> 0.1.5 电脑的分类</h3> <ul><li><p>超级计算机</p></li> <li><p>大型计算机</p></li> <li><p>迷你计算机</p></li> <li><p>工作站</p></li> <li><p>微电脑</p></li></ul> <h3 id="_0-1-6-电脑上面常用的计算单位-容量、速度等"><a href="#_0-1-6-电脑上面常用的计算单位-容量、速度等" class="header-anchor">#</a> 0.1.6 电脑上面常用的计算单位（容量、速度等）</h3> <ol><li><strong>容量单位</strong></li></ol> <table><thead><tr><th>进制位</th> <th>Kilo</th> <th>Mega</th> <th>Giga</th> <th>Tera</th> <th>Peta</th> <th>Exa</th> <th>Zetta</th></tr></thead> <tbody><tr><td>二进制</td> <td>1024</td> <td>1024K</td> <td>1024M</td> <td>1024G</td> <td>1024T</td> <td>1024P</td> <td>1024E</td></tr> <tr><td>十进制</td> <td>1000</td> <td>1000K</td> <td>1000M</td> <td>1000G</td> <td>1000T</td> <td>1000P</td> <td>1000E</td></tr></tbody></table> <p>一般来说，数据容量使用的是二进制的方式，所以 1GB 的文件大小实际上为：1024 * 1024 * 1024B 这么大。速度单位则常使用十进制，例如 1GHz 就是 1000 * 1000 * 1000Hz 的意思。</p> <ol><li><strong>速度单位</strong></li></ol> <p>CPU 的命令周期常使用 MHz 或是 GHz 之类的单位，这个 Hz 其实就是“次数/秒”的意思。而在网络传输方面，由于网络使用的是位（bit）为单位，因此网络常使用的单位为 Mbit/s 是 Mbits per second，亦即是每秒多少 Mbit。</p> <h2 id="_0-2-个人电脑架构与相关设备组件"><a href="#_0-2-个人电脑架构与相关设备组件" class="header-anchor">#</a> 0.2 个人电脑架构与相关设备组件</h2> <p>由于主板是连接各组件的一个重要部分，因此在主板上连接各部分组件的芯片组，其设计优劣，就会影响性能。早期的芯片组通常分为两个网桥来控制各组件的通信，分别是：</p> <ol><li><p>北桥：<strong>负责连接速度较快的 CPU、内存与显卡等组件</strong></p></li> <li><p>南桥：<strong>负责连接速度较慢的设备接口，包括硬盘、USB 设备、网卡等</strong></p></li></ol> <p>不过由于北桥最重要的就是 CPU 与内存之间的桥接，因此在目前的主流架构中，大多<strong>将北桥的内存控制器整合到了 CPU 当中</strong>。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597243042204-07998cfa-5454-4451-a056-b08e457862be.png" alt="img"></p> <p>早期芯片组分南北桥，北桥可以连接 CPU、内存与显卡。只是如果 CPU 有读写到内存的操作，还需要北桥的支持，也就是 CPU 与内存的交流，会消耗掉北桥的总可用带宽。因此目前将内存控制器整合到 CPU 后，CPU 与内存之间的通信是直接交流，速度较快之外，也不会消耗更多的带宽。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1600785676307-b5eace46-a5d1-45c0-ba9f-cf0e668966a2.png" alt="img"></p> <h3 id="_0-2-1-执行运算与判断的-cpu"><a href="#_0-2-1-执行运算与判断的-cpu" class="header-anchor">#</a> 0.2.1 执行运算与判断的 CPU</h3> <p>不同的 CPU 之间不能单纯地以频率来判断运算性能。这是因为每块 CPU 的指令集不同，架构也不见得一样，可使用的二级缓存及其运算机制可能也不同，加上每一次频率能够进行的工作指令数也不同，所以，频率目前仅能用来比较同款 CPU 的速度。</p> <ol><li><strong>CPU 的工作频率：外频与倍频</strong></li></ol> <p>早期的 CPU 架构主要通过北桥来连接系统最重要的 CPU、内存与显卡。因为所有的设备都得通过北桥来连接，因此每个设备的工作频率应该要相同。于是就有所谓的前端总线（FSB）这个东西的产生。但因为 CPU 的命令周期比其他的设备都要快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速，于是就有所谓的外频与倍频。</p> <p>总结来说，在早期的 CPU 设计中，所谓的<strong>外频指的是 CPU 与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作性能的一个倍数，两者相乘才是 CPU 的频率速度</strong>。例如 Intel Core 2 E8400 的频率为 3.0GHz，而外频是 333MHz，因此倍频就是 9 倍。</p> <p>所谓的超频指的是：将 CPU 的倍频或是外频通过主板提供的设置功能更改成较高频率的一种方式。但因为 CPU 的倍频通常在出厂时已经被锁定而无法修改，因此通常被超频的为外频。</p> <p>举例来说，像上述 3.0GHz 的 CPU 如果想要超频，可以将它的外频 333MHz 调整成为 400MHz，这样整个主板的各个组件的运行频率可能都会被提高到额定频率的 1.333 倍（4/3），虽然 CPU 可能会达到 3.6GHz，但却因为频率并非正常速度，可能会造成宕机等问题。</p> <p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此北桥通常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中，已经将内存控制器整合到了 CPU 内部，CPU 可以直接与内存、显卡等设备分别进行通信，而不需要通过外部的连接芯片。</p> <p>因为现在没有所谓的北桥（已整合到 CPU 内），因此，CPU 的频率设计就无须考虑要同步的外频，只需要考虑整体的频率即可。</p> <p>现在 Intel 的 CPU 会主动帮你超频。例如 i7-4790 这块 CPU 的默认规格中，基本频率为 3.6GHz，但是最高可自动超频到 4GHz，使用的是 Intel 的 Turbo（睿频）技术。同时，如果你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的。</p> <ol><li><strong>32 位与 64 位的 CPU 与总线“位宽”</strong></li></ol> <p>与 CPU 的频率类似，内存中也有其工作频率，这个频率的限制还是来自于 CPU 中的内存控制器所决定。以 0.2 节中的图为例，CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz，这只是工作频率（每秒几次）。一般来说，每个时钟周期能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“位宽”了。因此，图中这个系统，CPU 可以从内存中取得的最快带宽就是 1600MHz * 64bit=1600MHz * 8B=12.8GB/s。</p> <p>与总线位宽类似，<strong>CPU 每次能够处理的数据量称为字长，字长依据 CPU 的设计而有 32 位与 64 位</strong>。<strong>我们现在所称的电脑是 32 或 64 位主要是依据这个 CPU 解析的字长而来的</strong>。早期的 32 位 CPU 中，因为 CPU 每次能够解析的数据量有限，因此由内存传来的数据量就有所限制，<strong>这也导致 32 位的 CPU 最多只能支持最大到 4GB 的内存</strong>。</p> <ol><li><p><strong>CPU 等级</strong></p></li> <li><p><strong>超线程（Hyper-Threading，HT）</strong></p></li></ol> <p>超线程功能的实现：</p> <p>在每一个 CPU 内部将重要的寄存器分成两组，而让程序分别使用这两组寄存器。也就是说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换。这一过程就会让 CPU 好像“同时有两个内核”的样子。</p> <h3 id="_0-2-2-内存"><a href="#_0-2-2-内存" class="header-anchor">#</a> 0.2.2 内存</h3> <p>个人电脑的内存主要元件为<strong>动态随机存取内存（Dynamic Random Access Memory，DRAM）</strong>，随机读写内存只有在通电时才能记录与使用，断电之后数据就消失。因此我们也称这种 RAM 为挥发性内存。</p> <p>DRAM 根据技术的更新又分好几代，而使用上较广泛的有所谓的 SDRAM 与 DDR SDRAM 两种。这两种内存的差别除了在于脚位与工作电压上的不同之外，DDR 是所谓的双倍数据传送速度（Double Data Rate），他可以在一次工作周期中进行两次数据的传送，所以传输频率方面比 SDRAM 还要好。</p> <ol><li><strong>多通道设计</strong></li></ol> <p>由于所有的数据必须要存放在内存，所以内存的数据宽度当然是越大越好。但传统的总线位宽一般大约仅为 64 位，为了要加大这个位宽，芯片组厂商就将两个内存集合在一起，如果一根内存可达 64 位，两根内存就可以达到 128 位，这就是双通道的设计理念。</p> <ol><li><strong>DRAM 与 SRAM</strong></li></ol> <p>除了内存之外，事实上个人电脑当中还有许多类似内存的存储结构存在。最为我们所知的就是 CPU 内的二级高速缓存。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597322005250-7601d2ff-65bc-4703-87d7-b909a3819be6.png" alt="img"></p> <p>因为二级缓存整合到 CPU 内部，因此这个 L2 内存的速度必须要和 CPU 频率相同。使用 DRAM 是无法达到这个频率速度的，此时就需要<strong>静态随机存取内存（Static Random Access Memory，SRAM）</strong>。</p> <ol><li><strong>只读存储器（ROM）</strong></li></ol> <p>BIOS（Basic Input Output System）是一个程序，这个程序是写死到主板上面的一个存储芯片中，这个存储芯片在没有通电时也能够记录数据，这就是只读存储器（Read Only Memory，ROM）。ROM 是一种非易失性的存储。另外，BIOS 对于个人电脑来说是非常重要的，因为它是系统在启动的时候首先会去读取的一个小程序。</p> <p>另外，固件很多也是使用 ROM 来进行软件的写入的。固件像软件一样也是一个被电脑所执行的程序，然而它是对于硬件内部而言更加重要的部分。</p> <h3 id="_0-2-3-显卡"><a href="#_0-2-3-显卡" class="header-anchor">#</a> 0.2.3 显卡</h3> <p>显卡又称为 VGA（Video Graphics Array），他对于图形影像的显示扮演相当关键的角色。一般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内存，因此显卡上面会有一个内存的容量，这个<strong>显存容量将会影响到你的屏幕分辨率与色彩深度</strong>。</p> <p>除了显存之外，现在由于 3D 游戏与一些 3D 动画的流行，因此显卡的运算能力越来越重要。一些 3D 的运算任务早期是由 CPU 完成，但是 CPU 并非完全针对这些 3D 运算需求来进行设计的，而且 CPU 平时已经非常忙碌了。所以后来显卡厂商直接在显卡上面嵌入 3D 加速的芯片，这就是所谓的 GPU 称为的由来。</p> <p>显卡主要也是通过 GPU 的控制芯片来与 CPU、内存等通信。</p> <p>显卡与电脑屏幕连接接口有：</p> <ul><li><p>D-Sub（VGA 端子）</p></li> <li><p>DVI</p></li> <li><p>HDMI</p></li> <li><p>Display port</p></li></ul> <h3 id="_0-2-4-硬盘与存储设备"><a href="#_0-2-4-硬盘与存储设备" class="header-anchor">#</a> 0.2.4 硬盘与存储设备</h3> <ol><li><strong>硬盘的物理组成</strong></li></ol> <p>硬盘其实是由许许多多的<strong>圆形碟片、机械手臂、磁头与主轴马达</strong>所组成的。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597325306720-8e91d1f6-f034-4248-9e1b-f13985061556.png" alt="img"></p> <p>实际的数据都是写在具有磁性物质的碟片上面，而读写主要是通过在机械手臂上的磁头来完成。<strong>实际运行时，主轴马达让碟片转动，然后机械手臂可伸展让磁头在碟片上面进行读写的操作</strong>。另外，由于单一碟片的容量有限，因此有的硬盘内部会有两个以上的碟片。</p> <ol><li><strong>碟片上的数据</strong></li></ol> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597325498581-45cea040-1028-4906-b58a-fdc121bd9f7b.png" alt="img"></p> <p>由于碟片是圆的，并且通过机器手臂去读写数据，碟片要转动才能够让机器手臂读写。所以，当初设计就是在类似碟片同心圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的磁头去读写。<strong>这个小区块就是磁盘的最小物理存储单位，称之为扇区（sector），同一个同心圆的扇区组合成的圆就是所谓的磁道（track）</strong>。由于磁盘里面可能会有多个碟片，因此在<strong>所有碟片上面的同一个磁道可以组合成所谓的柱面（cylinder）</strong>。</p> <p>我们知道同心圆外圈的圆比较大，占用的面积比内圈多。所以，为了合理利用这些空间，外围的圆会具有更多的扇区。此外，当碟片转一圈时，外圈的扇区数量比较多，因此如果数据写入在外圈，转一圈能够读写的数据量当然比内圈还要多。因此通常数据的读写会由外圈开始往内写，这是默认方式。</p> <ol><li><strong>传输接口</strong></li></ol> <p>传统磁盘接口包括有 SATA、SAS、IDE 与 SCSI 等。若考虑外接式磁盘，那就还包括了 USB，eSATA 等接口。不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 替换。</p> <ol><li><strong>固态硬盘（Solid State Disk，SSD）</strong></li></ol> <p>传统硬盘有个很致命的问题，就是需要驱动马达去转动碟片，这会造成很严重的磁盘读取延迟。因此，后来就有厂商拿闪存去制作成高容量的设备，这些设备的连接接口也使用 SATA 或 SAS，而且外型还做的跟传统磁盘一样。所以，虽然这类设备已经不能称为是磁盘（因为没有磁头与碟片，都是闪存），但是为了方便大家称呼，所以还是称为磁盘。只是跟传统的机械磁盘（Hard Disk Drive，HDD）不同，就称为固态硬盘（Solid State Disk，SSD）。</p> <p>固态硬盘最大的好处是，它没有马达不需要转动，而是通过闪存直接读写的特性，因此除了没数据延迟且快速之外，还很省电。</p> <h3 id="_0-2-5-扩展卡与接口"><a href="#_0-2-5-扩展卡与接口" class="header-anchor">#</a> 0.2.5 扩展卡与接口</h3> <p>你的服务器可能因为某些特殊的需求，需要使用主板之外的其他适配卡。所以主板上面通常会预留多个扩展接口的插槽，这些插槽规格依据其来历，又包括 PCI、AGP、PCI-X、PCIe 等。但是由于 PCIe 速度太快，因此几乎所有的卡都以 PCIe 来设计。</p> <p>由于各组件的价格直落，现在主板上面通常已经集成了相当多的设备组件。常见的集成到主板的组件包括声卡、网卡、USB 控制器、显卡、磁盘阵列卡等。不过，因为某些特殊的需求，有时可能还是需要增加额外的扩展卡。</p> <h3 id="_0-2-6-主板"><a href="#_0-2-6-主板" class="header-anchor">#</a> 0.2.6 主板</h3> <h3 id="_0-2-7-主机电源"><a href="#_0-2-7-主机电源" class="header-anchor">#</a> 0.2.7 主机电源</h3> <h2 id="_0-3-数据表示方式"><a href="#_0-3-数据表示方式" class="header-anchor">#</a> 0.3 数据表示方式</h2> <h3 id="_0-3-1-数字系统"><a href="#_0-3-1-数字系统" class="header-anchor">#</a> 0.3.1 数字系统</h3> <p>早期的电脑使用的是利用通电与否的特性制造的电子管，如果通电就是 1，没有通电就是 0，后来沿用至今，我们称这种只有 0 和 1 的环境为二进制，英文称为 binary。</p> <h3 id="_0-3-2-字符编码系统"><a href="#_0-3-2-字符编码系统" class="header-anchor">#</a> 0.3.2 字符编码系统</h3> <p>文本文件是被记录为 0 与 1，而这个文件的内容被读取查看时，必须要经过一个编码系统的处理才行。所谓的编码系统可以想成是一个字码对照表，如下图所示：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597366558399-9e7725a7-071f-4039-881d-dba11132d493.png" alt="img"></p> <h2 id="_0-4-软件程序运行"><a href="#_0-4-软件程序运行" class="header-anchor">#</a> 0.4 软件程序运行</h2> <p>一般来说，目前的电脑系统将软件分为两大类，一类是系统软件，另一类是应用程序。</p> <h3 id="_0-4-1-机器语言程序与编译型程序"><a href="#_0-4-1-机器语言程序与编译型程序" class="header-anchor">#</a> 0.4.1 机器语言程序与编译型程序</h3> <p>我们前面谈到电脑只认识 0 与 1 而已，而且电脑最重要的运算与逻辑判断是在 CPU 内部，而 CPU 其实具有指令集。因此，我们需要 CPU 帮忙工作时，就得要参考指令集的内容，然后编写让 CPU 读得懂的脚本给 CPU 执行，这样就能够让 CPU 运行。</p> <p>不过这样的流程有几个很麻烦的地方，包括：</p> <ul><li><p>需要了解机器语言</p></li> <li><p>需要了解所有硬件的相关功能函数</p></li> <li><p>程序不具有可移植性</p></li> <li><p>程序具有专一性</p></li></ul> <p>为了解决这个问题，电脑科学家设计出一种让人类看得懂的程序语言，然后创造一种编译器来将这些人类写的程序语言转译成为机器能看懂的机器码。机器语言与高级程序语言的差别如下图所示。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597376619359-2e6c6ac6-3886-4095-9579-a6c52a54a8e8.png" alt="img"></p> <p>从图中我们可以看到高级程序语言的程序代码是很容易查看的。问题是，在这样的环境下面我们还是得要考虑整体的硬件系统来设计程序。</p> <p>举例来说，当你需要将运行的数据写入内存中，你就得要自行分配一个内存区块出来让自己的数据能够填上去，所以你还得要了解到内存的地址是如何定位。</p> <p>为了要解决硬件方面老是需要重复编写句柄的问题，所以就有操作系统的出现了。</p> <h3 id="_0-4-2-操作系统"><a href="#_0-4-2-操作系统" class="header-anchor">#</a> 0.4.2 操作系统</h3> <p>在早期想要让电脑执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够编写程序。同时每次写程序时都必须要重新改写，因为硬件与软件功能不见得都一致。那如果我能够将所有的硬件都驱动，并且提供一个软件的参考接口来给工程师开发软件的话，那开发软件不就变得非常的简单了吗？这就是操作系统。</p> <ol><li><strong>操作系统内核（Kernel）</strong></li></ol> <p><strong>操作系统（Operating System，OS）其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件</strong>。</p> <p>你的电脑能不能做到某些事情，都与内核有关。只有内核提供的功能，你的电脑系统才能帮你完成。</p> <p>但是单有内核我们用户也不知道能做什么事情，因为内核主要在管理硬件与提供相关的功能，这些管理的操作都非常重要，如果用户能够直接使用到内核的话，万一用户不小心将内核程序停止或破坏，将会导致整个系统的崩溃。因此<strong>内核程序放置到内存当中的区块是受保护的，并且启动后就一直常驻在内存当中</strong>。</p> <ol><li><strong>系统调用（System Call）</strong></li></ol> <p>操作系统通常会提供一套应用程序编程接口（Application Programming Interface，API）给程序员来开发软件，工程师只要遵循该 API 那就很容易开发软件。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597455753809-a1bc3e34-7731-400f-bb6d-19e7f07cfce6.png" alt="img"></p> <p>电脑系统主要由硬件构成，然后内核程序主要在管理硬件，提供合理的电脑系统资源分配，因此只要硬件不同，内核就得要进行修改才行。而由于内核只会进行电脑系统的资源分配，所以在上面还需要有应用程序的提供，用户才能够使用系统。</p> <p>为了保护内核，并且能让程序员比较容易开发软件，操作系统除了内核程序之外，通常还会提供一套 API，那就是系统调用层。程序员只要遵循公认的系统调用参数来开发软件，该软件就能够在该内核上运行。</p> <ul><li><p>操作系统的内核层直接参考硬件规格写成，所以同一个操作系统程序不能够在不一样的硬件架构下运行。</p></li> <li><p>操作系统只是管理整个硬件资源，包括 CPU、内存、输入输出设备及文件系统等。</p></li> <li><p>应用程序的开发都是参考操作系统提供的 API，所以该应用程序只能在该操作系统上面运行，不可以在其他操作系统上运行。</p></li></ul> <ol><li><strong>内核功能</strong></li></ol> <ul><li><p>系统调用接口</p></li> <li><p>进程管理</p></li> <li><p>内存管理</p></li> <li><p>文件系统管理</p></li> <li><p>设备驱动</p></li></ul> <ol><li><strong>操作系统与驱动程序</strong></li></ol> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597456690699-4539048e-fda3-413f-b1d9-8eecdd5aabeb.png" alt="img"></p> <ul><li><p>操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能</p></li> <li><p>一般来说，操作系统会提供 API，让开发商编写他们的驱动程序</p></li> <li><p>要使用新硬件功能，必须要安装厂商提供的驱动程序才行</p></li> <li><p>驱动程序是由厂商提供，与操作系统无关</p></li></ul> <h3 id="_0-4-3-应用程序"><a href="#_0-4-3-应用程序" class="header-anchor">#</a> 0.4.3 应用程序</h3> <p>应用程序是参考操作系统提供的 API 所开发出来的软件，这些软件可以让用户操作，以实现某些功能。</p> <h1 id="_1-linux-是什么与如何学习"><a href="#_1-linux-是什么与如何学习" class="header-anchor">#</a> 1 Linux 是什么与如何学习</h1> <hr> <h2 id="_1-1-linux-是什么"><a href="#_1-1-linux-是什么" class="header-anchor">#</a> 1.1 Linux 是什么</h2> <h3 id="_1-1-1-linux-是什么-操作系统-应用程序"><a href="#_1-1-1-linux-是什么-操作系统-应用程序" class="header-anchor">#</a> 1.1.1 Linux 是什么？操作系统/应用程序？</h3> <p>Linux 是一个操作系统！</p> <p>早期的 Linux 是针对 386 的计算机来开发的，由于 Linux 只是一个操作系统，并不含有其他的操作程序，因此很多工程师在下载了 Linux 内核并且实际安装之后，就只能看着计算机开始运行。接下来这些高级工程师为了自己的需求，再在 Linux 上面安装它们所需要的软件即可。</p> <p>由于不同的硬件它的功能函数并不相同，例如 IBM 的 Power CPU 与 Intel 的 x86 架构就不一样，所以同一个操作系统是无法在不同硬件平台上面运行的！举例来说，如果你想要让 x86 上面运行的那个操作系统也能够在 Power CPU 上运行时，就得要将该操作系统进行修改才行。如果能够参考硬件的功能函数并以此修改你的操作系统程序代码，那经过改版后的操作系统就能够在另一个硬件平台上运行，这个过程我们通常就称为“<strong>软件移植</strong>”。</p> <h3 id="_1-1-2-linux-之前-unix-的历史"><a href="#_1-1-2-linux-之前-unix-的历史" class="header-anchor">#</a> 1.1.2 Linux 之前，UNIX 的历史</h3> <ol><li><p><strong>1969 年以前：一个伟大的梦想——Bell，MIT 与 GE 的 “Multics”系统</strong></p></li> <li><p><strong>1969 年：Ken Thompson 的小型 file server system</strong></p></li> <li><p><strong>1973 年：UNIX 的正式诞生，Ritchie 等人用 C 语言写出第一个正式 UNIX 内核</strong></p></li> <li><p><strong>1977 年：重要的 UNIX 分支——BSD 的诞生</strong></p></li> <li><p><strong>1979 年：重要的 System V 架构与版权声明</strong></p></li> <li><p><strong>1984 年之一：x86 架构的 Minix 操作系统开始编写并于两年后诞生</strong></p></li> <li><p><strong>1984 年之二：GNU 计划与 FSF 基金会的成立</strong></p></li> <li><p><strong>1988 年：图形用户界面模式 XFree86 计划</strong></p></li> <li><p><strong>1991 年：芬兰大学生 Linus Torvalds 的一则简讯</strong></p></li></ol> <h3 id="_1-1-3-关于-gnu-计划-自由软件与开发源代码"><a href="#_1-1-3-关于-gnu-计划-自由软件与开发源代码" class="header-anchor">#</a> 1.1.3 关于 GNU 计划，自由软件与开发源代码</h3> <h2 id="_1-2-托瓦兹的-linux-的发展"><a href="#_1-2-托瓦兹的-linux-的发展" class="header-anchor">#</a> 1.2 托瓦兹的 Linux 的发展</h2> <h3 id="_1-2-1-与-minix-之间"><a href="#_1-2-1-与-minix-之间" class="header-anchor">#</a> 1.2.1 与 Minix 之间</h3> <h3 id="_1-2-2-对-386-硬件的多任务测试"><a href="#_1-2-2-对-386-硬件的多任务测试" class="header-anchor">#</a> 1.2.2 对 386 硬件的多任务测试</h3> <p>理论上，一个 CPU 在一个时间内仅能运行一个程序，当两个以上的程序同时出现在系统中，具有多任务能力的 CPU 就会在不同的程序间切换。假设 CPU 频率为 1GHz 的话，那表示 CPU 一秒钟可以进行 10^9 次工作。假设 CPU 对每个程序都只进行 1000 次运行周期，然后就得要切换到下个程序的话，那么 CPU 一秒钟就能够切换 10^6 次。这么快的处理速度下，你会发现两个程序感觉上几乎是同步在进行。</p> <p>要实现多任务的环境，除了硬件（主要是 CPU）需要能够具有多任务的特性外，操作系统也需要支持这个功能。</p> <p>至于多任务的操作系统中，每个程序被执行时，都会有一个最大 CPU 使用时间，若该任务运行的时间超过这个 CPU 使用时间时，该任务就会先被移出 CPU 的运行队列，而再度进入内核计划任务中等待下一次被 CPU 使用来运行。</p> <h3 id="_1-2-3-初次发布-linux-0-02"><a href="#_1-2-3-初次发布-linux-0-02" class="header-anchor">#</a> 1.2.3 初次发布 Linux 0.02</h3> <h3 id="_1-2-4-linux-的发展-虚拟团队的产生"><a href="#_1-2-4-linux-的发展-虚拟团队的产生" class="header-anchor">#</a> 1.2.4 Linux 的发展：虚拟团队的产生</h3> <h3 id="_1-2-5-linux-的内核版本"><a href="#_1-2-5-linux-的内核版本" class="header-anchor">#</a> 1.2.5 Linux 的内核版本</h3> <p>Linux 的内核版本编号有点类似如下的样子：</p> <p>3.10.0-123.e17.x86-64</p> <p>主版本.次版本.发布版本-修改版本</p> <p>虽然编号就是如上的方式来编的，不过依据 Linux 内核的发展历程，内核版本的定义有点不太相同。</p> <ol><li><strong>奇数、偶数版本分类</strong></li></ol> <p>在 2.6.x 版本以前，托瓦兹将内核的发展方向分为两类，并根据这两类内核的发展分别给予不同的内核编号，那就是：</p> <ul><li>主、次版本为奇数：开发中版本</li> <li>主、次版本为偶数：稳定版本</li></ul> <ol><li><strong>主线版本、长期维护版本</strong></li></ol> <p>不过，这种奇数、偶数的编号格式在 3.0 版推出之后就不再使用了。从 3.0 版开始，内核主要依据主线版本（MainLine）来开发，开发完毕后会往下一个主线版本进行。</p> <p>而旧的版本在新的主线版本出现之后，会有两种机制来处理。一种机制为结束开发（End Of Live，EOL）。另一种机制为保持该版本的持续维护，亦即为长期维护版本（Longterm）。</p> <ol><li><strong>Linux 内核版本与 Linux 发行版本</strong></li></ol> <h3 id="_1-2-6-linux-发行版"><a href="#_1-2-6-linux-发行版" class="header-anchor">#</a> 1.2.6 Linux 发行版</h3> <p>Linux 其实就是一个操作系统最底层的内核及其提供的内核工具。它是 GNU GPL 授权模式，所以，任何人均可取得源代码与可执行这个内核程序，并且可以修改。此外，因为 Linux 参考 POSIX 设计规范，于是兼容 UNIX 操作系统，故亦可称之为 UNIX-like（类 UNIX）的一种。</p> <p>“内核+软件+工具+可完全安装程序”，我们称之为 Linux distribution，即 Linux 发行版。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1600927535868-050d4e8f-81c8-4928-a504-97122da26c14.png" alt="img"></p> <table><thead><tr><th></th> <th>RPM 软件管理</th> <th>DPKG 软件管理</th> <th>其他未分类</th></tr></thead> <tbody><tr><td>商业公司</td> <td>RHEL(Red Hat)SUSE(Micro Focus)</td> <td>Ubuntu</td> <td></td></tr> <tr><td>网络社区</td> <td>FedoraCentOSopenSUSE</td> <td>DebianB2D</td> <td>Gentoo</td></tr></tbody></table> <h2 id="_1-3-linux-当前应用的角色"><a href="#_1-3-linux-当前应用的角色" class="header-anchor">#</a> 1.3 Linux 当前应用的角色</h2> <h3 id="_1-3-1-企业环境的使用"><a href="#_1-3-1-企业环境的使用" class="header-anchor">#</a> 1.3.1 企业环境的使用</h3> <ul><li><p>网络服务器</p></li> <li><p>关键任务的应用（金融数据库、大型企业网络环境）</p></li> <li><p>学术机构的高性能计算任务</p></li></ul> <h3 id="_1-3-2-个人环境的使用"><a href="#_1-3-2-个人环境的使用" class="header-anchor">#</a> 1.3.2 个人环境的使用</h3> <ul><li><p>桌面计算机</p></li> <li><p>手持系统（PDA、手机）</p></li> <li><p>嵌入式系统</p></li></ul> <h3 id="_1-3-3-云端应用"><a href="#_1-3-3-云端应用" class="header-anchor">#</a> 1.3.3 云端应用</h3> <ul><li>云程序</li> <li>终端设备</li></ul> <h2 id="_1-4-linux-该如何学习"><a href="#_1-4-linux-该如何学习" class="header-anchor">#</a> 1.4 Linux 该如何学习</h2> <h1 id="_2-主机规划与磁盘分区"><a href="#_2-主机规划与磁盘分区" class="header-anchor">#</a> 2 主机规划与磁盘分区</h1> <hr> <h2 id="_2-1-linux-与硬件的搭配"><a href="#_2-1-linux-与硬件的搭配" class="header-anchor">#</a> 2.1 Linux 与硬件的搭配</h2> <p>各个组件或设备在 Linux 下面都是一个文件。</p> <h3 id="_2-1-1-认识计算机的硬件设备"><a href="#_2-1-1-认识计算机的硬件设备" class="header-anchor">#</a> 2.1.1 认识计算机的硬件设备</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597753806448-c1e907ec-d48c-48be-9c5a-efbecad794c1.png" alt="img"></p> <h3 id="_2-1-2-选择与-linux-搭配的主机设备"><a href="#_2-1-2-选择与-linux-搭配的主机设备" class="header-anchor">#</a> 2.1.2 选择与 Linux 搭配的主机设备</h3> <h3 id="_2-1-3-各硬件设备在-linux-中的文件名"><a href="#_2-1-3-各硬件设备在-linux-中的文件名" class="header-anchor">#</a> 2.1.3 各硬件设备在 Linux 中的文件名</h3> <table><thead><tr><th>设备</th> <th>设备在 Linux 中的文件名</th></tr></thead> <tbody><tr><td>SCSI、SATA、USB 磁盘驱动器</td> <td>/dev/sd[a-p]</td></tr> <tr><td>U 盘</td> <td>/dev/sd[a-p]（与 SATA 相同）</td></tr> <tr><td>Virtio 接口</td> <td>/dev/vd[a-p]（用于虚拟机内）</td></tr> <tr><td>软盘驱动器</td> <td>/dev/fd[0-7]</td></tr> <tr><td>打印机</td> <td>/dev/lp[0-2]（25 针打印机）/dev/usb/lp[0-15]（USB 接口）</td></tr> <tr><td>鼠标</td> <td>/dev/input/mouse[0-15]（通用）/dev/psaux（PS/2 接口）/dev/mouse（当前鼠标）</td></tr> <tr><td>CD-ROM、DVD-ROM</td> <td>/dev/scd[0-1]（通用）/dev/sr[0-1]（通用，CentOS 较常见）/dev/cdrom（当前 CD-ROM）</td></tr> <tr><td>磁带机</td> <td>/dev/ht0（IDE 接口）/dev/st0（SATA/SCSI 接口）/dev/tape（当前磁带）</td></tr> <tr><td>IDE 磁盘驱动器</td> <td>/dev/hd[a-d]（旧式系统才有）</td></tr></tbody></table> <h3 id="_2-1-4-使用虚拟机学习"><a href="#_2-1-4-使用虚拟机学习" class="header-anchor">#</a> 2.1.4 使用虚拟机学习</h3> <h2 id="_2-2-磁盘分区"><a href="#_2-2-磁盘分区" class="header-anchor">#</a> 2.2 磁盘分区</h2> <h3 id="_2-2-1-磁盘连接方式与设备文件名的关系"><a href="#_2-2-1-磁盘连接方式与设备文件名的关系" class="header-anchor">#</a> 2.2.1 磁盘连接方式与设备文件名的关系</h3> <p>正常的物理机器大概使用的都是 /dev/sd[a-p] 的磁盘文件名，至于虚拟机环境中，为了加速，可能就会使用 /dev/vd[a-p] 这种设备文件名。</p> <p>再以 SATA 接口来说，由于 SATA、USB、SAS 等磁盘接口都是使用 SCSI 模块来驱动的，因此这些接口的磁盘设备文件名都是 /dev/sd[a-p] 的格式。所以 SATA 或 USB 接口的磁盘根本就没有一定的顺序，这个时候就得要<strong>根据 Linux 内核检测到磁盘的顺序</strong>来命名。</p> <p>碟片上面可细分出扇区与磁道两种单位，其中扇区的物理大小设计有两种，分别是 512 字节与 4K 字节。</p> <p>整块磁盘的第一个扇区特别重要，因为它记录了整块磁盘的重要信息。早期磁盘第一个扇区里面含有的重要信息我们称为 MBR（Master Boot Record）格式，但是由于近年来磁盘的容量不断扩大，造成读写上的一些困扰，甚至有些 2TB 以上的磁盘分区已经让某些操作系统无法存取，因此后来又多了一个新的磁盘分区格式，称为 GPT（GUID partition table），这两种分区格式与限制不太相同。</p> <h3 id="_2-2-2-mbr-ms-dos-与-gpt-磁盘分区表-partition-table"><a href="#_2-2-2-mbr-ms-dos-与-gpt-磁盘分区表-partition-table" class="header-anchor">#</a> 2.2.2 MBR（MS-DOS）与 GPT 磁盘分区表（partition table）</h3> <p>通常磁盘可能有多个碟片，所有碟片的同一个磁道我们称为柱面（Cylinder），通常那是文件系统的最小单位，也就是分区的最小单位。为什么说“通常”？因为近来有 GPT 这个可达到 64 位记录功能的分区表，现在我们甚至可以使用扇区（Sector）号码来作为分区单位。</p> <ol><li><strong>MBR（MS-DOS）分区表格式与限制</strong></li></ol> <p>早期的 Linux 系统为了兼容 Windows 的磁盘，因此使用的是支持 Windows 的 MBR（Master Boot Record，主引导记录）的方式来处理启动引导程序与分区表。而启动引导程序记录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是 512 字节的大小（旧的磁盘扇区都是 512 字节），所以说，第一个扇区的 512 字节主要会有：</p> <ul><li>主引导记录（Master Boot Record，MBR）：可以安装启动引导程序的地方，有 446 字节；</li> <li>分区表（partition table）：记录整块硬盘分区的状态，有 64 字节。</li></ul> <p><strong>由于分区表所在区块仅有 64 字节容量，因此最多仅能有四组记录区，每组记录区记录了该区段的起始与结束的柱面号码</strong>。若将硬盘以长条形来看，然后将柱面以柱形图来看，那么那 64 字节的记录区有点像下面的图：</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597797657815-3994b9f9-edf0-45ab-9d8a-e9e22c377252.png" alt="img"></p> <p>假设上面的硬盘设备文件名为 /dev/sda 时，那么这四个分区在 Linux 系统中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与该分区所在的位置有关。</p> <ul><li><p>P1:/dev/sda1</p></li> <li><p>P2:/dev/sda2</p></li> <li><p>P3:/dev/sda3</p></li> <li><p>P4:/dev/sda4</p></li></ul> <p>由于分区表就只有 64 字节而已，最多只能容纳四组分区记录，这四个分区的记录被称为主要（Primary）或扩展（Extended）分区。</p> <ul><li><p>其实所谓的分区只是针对那 64 字节的分区表进行设置而已</p></li> <li><p>硬盘默认的分区表仅能写入四组分区信息</p></li> <li><p>这四组划分信息我们称为主要或扩展分区</p></li> <li><p>分区的最小单位通常为柱面</p></li> <li><p>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行数据的处理</p></li></ul> <p>为什么要分区：</p> <ul><li>数据的安全性</li> <li>系统的性能考虑</li></ul> <p>既然分区表只有记录四组数据的空间，那么是否代表一块硬盘最多只能划分出四个分区呢？当然不是。你可以将一块硬盘划分成十个以上的分区。在 Windows 与 Linux 系统中，我们是通过扩展分区的方式来实现的。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597810060214-340a1a86-1460-4f22-ba76-ee9c26d334d3.png" alt="img"></p> <p>实际上，扩展分区并不是只占一个区块，而是会分布在每个分区的最前面几个扇区来记录分区信息。</p> <p>在上图中，我们知道硬盘的四个分区记录区仅使用到两个，P1 为主要分区，而 P2 则为扩展分区。<strong>扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化</strong>。我们可以通过扩展分区所指向的那个区块继续做分区的记录。</p> <p>如图右下方那个区块继续划分出五个分区，这五个由扩展分区继续切出来的分区，就被称为<strong>逻辑分区</strong>（logical partition）。由于逻辑分区是由扩展分区继续划分出来的，所以它可以使用的柱面范围就是扩展分区所设置的范围。</p> <ul><li><p>主要分区与扩展分区最多可以有 4 个（硬盘的限制）</p></li> <li><p>扩展分区最多只能有 1 个（操作系统的限制）</p></li> <li><p>逻辑分区是由扩展分区持续划分出来的分区</p></li> <li><p>能够被格式化后作为数据存取的分区是主要分区与逻辑分区，扩展分区无法格式化</p></li> <li><p>逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经突破 63 个以上的分区限制</p></li></ul> <p>MBR 分区表的限制：</p> <ul><li><p>操作系统无法使用 2.2 TB 以上的磁盘容量</p></li> <li><p>MBR 仅有一个区块，若被破坏后，经常无法或很难恢复</p></li> <li><p>MBR 内的存放启动引导程序的区块仅 446 字节，无法存储较多的程序代码</p></li></ul> <p>为了解决上述问题，后来就有 GPT 这个磁盘分区的格式出现。</p> <ol><li><strong>GPT（GUID partition table）磁盘分区表</strong></li></ol> <p>因为过去一个扇区大小就是 512 字节而已，不过目前已经有 4K 的扇区设计出现。为了兼容所有的磁盘，因此在扇区的定义上面，大多会使用所谓的逻辑区块地址（Logical Block Address，LBA）来处理。GPT 将磁盘所有区块以此 LBA（默认为 512 字节）来规划，而第一个 LBA 称为 LBA0（从 0 开始编号）。</p> <p>与 MBR 仅使用第一个 512 字节区块来记录不同，GPT 使用了 34 个 LBA 区块来记录分区信息。同时与过去 MBR 仅有一个区块，被干掉就死光光的情况不同，GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 34 个 LBA 也拿来作为另一个备份。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597844210755-4d70e548-8716-48e0-a628-9554e1655091.png" alt="img"></p> <p>上述图例的解释说明如下：</p> <ul><li><p>LBA0（MBR 兼容区块）</p></li> <li><p>LBA1（GPT 表头记录）</p></li> <li><p>LBA2-33（实际记录分区信息处）</p></li></ul> <p>现在 GPT 分区默认可以提供多达 128 组记录，而在 Linux 本身的内核设备记录中，针对单一磁盘来说，虽然过去最多只能到达 15 个分区，不过由于 Linux 内核通过 udev 等方式的处理，现在 Linux 也已经没有这个限制了。此外， GPT 分区已经没有所谓的主、扩展、逻辑分区的概念，既然每组记录都可以独立存在，当然每个都可以视为是主要分区，每一个分区都可以拿来格式化使用。</p> <h3 id="_2-2-3-启动流程中的-bios-与-uefi-启动检测程序"><a href="#_2-2-3-启动流程中的-bios-与-uefi-启动检测程序" class="header-anchor">#</a> 2.2.3 启动流程中的 BIOS 与 UEFI 启动检测程序</h3> <ol><li><strong>BIOS 搭配 MBR/GPT 的启动流程</strong></li></ol> <p>CMOS 是记录各项硬件参数且嵌入在主板上面的存储器，BIOS 则是一个写入到主板上的一个固件（写入到硬件上的一个软件程序）。<strong>这个 BIOS 就是在启动的时候，计算机系统会主动执行的第一个程序</strong>。</p> <p>简单地说，整个启动流程到操作系统之前的过程应该是：</p> <ol><li><p>BIOS：启动主动执行的固件，会认识第一个可启动的设备</p></li> <li><p>MBR：第一个可启动设备的第一个扇区内的主引导记录块，内含启动引导代码</p></li> <li><p>启动引导程序（boot loader）：一个可读取内核文件来执行的软件</p></li> <li><p>内核文件：开始启动操作系统</p></li></ol> <p>如果你的分区表为 GPT 格式的话，那么 BIOS 也能够从 LBA0 的 MBR 兼容区块读取一阶段的启动引导程序代码，如果你的启动引导程序能够支持 GPT 的话，那么使用 BIOS 同样可以读取到正确的操作系统内核。换句话说，如果启动引导程序不懂 GPT，例如 Windows XP 的环境，那自然就无法读取内核文件，就无法启动操作系统。</p> <p>BIOS 与 MBR 都是硬件本身会支持的功能，至于 Boot loader 则是操作系统安装在 MBR 上面的一个软件。这个 Boot loader 的主要任务如下：</p> <ul><li><p>提供选项：用户可以选择不同的启动选项，这也是多重引导的重要功能</p></li> <li><p>加载内核文件：直接指向可使用的程序区段来启动操作系统</p></li> <li><p>转交其他启动引导程序：将启动管理功能转交给其他启动引导程序负责</p></li></ul> <p><strong>启动引导程序除了可以安装在 MBR 之外，还可以安装在每个分区的启动扇区</strong>。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1597970798344-771b67a3-e59a-41f5-9a9e-39ef4e91c6d1.png" alt="img"></p> <ul><li><p>每个分区都拥有自己的启动扇区</p></li> <li><p>图中的系统分区为第一及第二分区</p></li> <li><p>实际可启动的内核文件是放置到各分区中的</p></li> <li><p>启动引导程序只会认识自己的系统分区内的可启动的内核文件，以及其他启动引导程序而已</p></li> <li><p>启动引导程序可直接指向或是间接将管理权转交给另一个管理程序</p></li></ul> <ol><li><strong>UEFI BIOS 搭配 GPT 启动的流程</strong></li></ol> <p>GPT 可以提供 64 位的寻址，然后也能够使用较大的区块来处理启动引导程序，但是 BIOS 其实不懂 GPT。还得要通过 GPT 提供兼容模式才能够读写这个磁盘设备，而且 BIOS 仅是 16 位的程序，在与现阶段新的操作系统接轨方面有点弱。为了解决这个问题，因此就有了 UEFI（Unified extensible Firmware Interface）这个统一可扩展固件接口的产生。</p> <table><thead><tr><th>比较项目</th> <th>传统 BIOS</th> <th>UEFI</th></tr></thead> <tbody><tr><td>使用程序语言</td> <td>汇编语言</td> <td>C 语言</td></tr> <tr><td>硬件资源控制</td> <td>使用中断（IRQ）管理不可变的内存存取不可变的输入/输出存取</td> <td>使用驱动程序与协议</td></tr> <tr><td>处理器运行环境</td> <td>16 位</td> <td>CPU 保护模式</td></tr> <tr><td>扩充方式</td> <td>通过 IRQ 连接</td> <td>直接加载驱动程序</td></tr> <tr><td>第三方厂商支持</td> <td>较差</td> <td>较佳且支持多平台</td></tr> <tr><td>图形能力</td> <td>较差</td> <td>较佳</td></tr> <tr><td>内置简化操作系统环境</td> <td>不支持</td> <td>支持</td></tr></tbody></table> <h3 id="_2-2-4-linux-安装模式下-磁盘分区的选择"><a href="#_2-2-4-linux-安装模式下-磁盘分区的选择" class="header-anchor">#</a> 2.2.4 Linux 安装模式下，磁盘分区的选择</h3> <ol><li><strong>目录树结构</strong></li></ol> <p>所谓的目录树架构就是以根目录为主，然后向下呈现为分支状的目录结构的一种文件架构。所以，<strong>整个目录树架构最重要的就是那个根目录，这个根目录的表示方法为一条斜线&quot;/&quot;</strong>，所有的文件都与目录树有关。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1598230413403-dcb8465f-34ea-4f2a-8822-7bc5d1f397aa.png" alt="img"></p> <p>整个 Linux 系统使用的是目录树架构，但是我们的文件数据其实是放置在磁盘分区当中，现在的问题是“如何结合目录树的架构与磁盘内的数据”？这个时候就牵扯到挂载（mount）的问题。</p> <ol><li><strong>文件系统与目录树的关系（挂载）</strong></li></ol> <p><strong>所谓的“挂载”就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区</strong>。这个操作我们称为“挂载”，那个进入点的目录我们称为“挂载点”。由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分区，至于其他的目录则可依用户自己的需求挂载到不同的分区。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1598230974664-9bfa0904-05f3-4fea-951e-c749db82c051.png" alt="img"></p> <ol><li><strong>发行版安装时，挂载点与磁盘分区的规划</strong></li></ol> <h2 id="_2-3-安装-linux-前的规划"><a href="#_2-3-安装-linux-前的规划" class="header-anchor">#</a> 2.3 安装 Linux 前的规划</h2> <h1 id="_3-安装-centos-7-x"><a href="#_3-安装-centos-7-x" class="header-anchor">#</a> 3 安装 CentOS 7.x</h1> <hr> <h1 id="_4-首次登录与在线求助"><a href="#_4-首次登录与在线求助" class="header-anchor">#</a> 4 首次登录与在线求助</h1> <hr> <p>由于 Linux 系统使用了异步的磁盘/内存数据传输模式，同时又是个多人多任务的环境，所以你不能随便地不正常关机，关机有一定的顺序，错误的关机方法可能会造成磁盘数据的损坏。</p> <h2 id="_4-1-首次登录系统"><a href="#_4-1-首次登录系统" class="header-anchor">#</a> 4.1 首次登录系统</h2> <h2 id="_4-2-命令行模式下命令的执行"><a href="#_4-2-命令行模式下命令的执行" class="header-anchor">#</a> 4.2 命令行模式下命令的执行</h2> <h3 id="_4-2-1-开始执行命令"><a href="#_4-2-1-开始执行命令" class="header-anchor">#</a> 4.2.1 开始执行命令</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">command</span> <span class="token punctuation">[</span>-options<span class="token punctuation">]</span> parameter1 parameter2 <span class="token punctuation">..</span>.
                  命令     选项       参数1      参数2
</code></pre></div><p>上述命令详细说明如下：</p> <ol><li><p>一行命令中第一个输入的部分绝对是命令（command）或可执行文件（例如 shell 脚本）；</p></li> <li><p>command 为命令的名称，例如变换工作目录的命令为 <code>cd</code> 等；</p></li> <li><p>中括号 <code>[]</code> 并不存在于实际的命令中，表示是可选的，而加入选项设置时，通常选项前会带 <code>-</code> 号，例如 <code>-h</code>；有时候会使用选项的完整全名，则选项前带有 <code>--</code> 符号，例如 <code>--help</code>；</p></li> <li><p>parameter1 parameter2 为依附在选项后面的参数，或是 command 的参数；</p></li> <li><p>命令、选项、参数等这几个东西中间以空格来区分，不论空几格 shell 都视为一格，所以空格是很重要的特殊字符；</p></li> <li><p>按下回车键后，该命令就立即执行，回车键代表着一行命令的开始启动；</p></li> <li><p>命令太长的时候，可以使用反斜杠（<code>\</code>）来转义回车键，使命令连续到下一行，注意，反斜杠后就立刻接着特殊字符才能转义；</p></li> <li><p>在 Linux 系统中，英文大小写字母是不一样的，举例来说，<code>cd</code> 与 <code>CD</code> 并不同。</p></li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 以 ls 这个命令列出【自己家目录】下的【所有隐藏文件与相关的文件属性】</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> -al ~
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">ls</span>       -al ~
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">ls</span> -a -l ~
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#显示目前所支持的语系</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ locale

<span class="token comment">#修改语系成为英语语系</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.utf8
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span>en_US.utf8
</code></pre></div><h3 id="_4-2-2-基础命令的操作"><a href="#_4-2-2-基础命令的操作" class="header-anchor">#</a> 4.2.2 基础命令的操作</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#显示日期与时间</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">date</span>

<span class="token comment">#显示日历</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">cal</span>

<span class="token comment">#计算器</span>
<span class="token punctuation">[</span>dmtsai@study ~<span class="token punctuation">]</span>$ <span class="token function">bc</span>
</code></pre></div><h3 id="_4-2-3-重要的几个热键-tab-、-ctrl-c、-ctrl-d"><a href="#_4-2-3-重要的几个热键-tab-、-ctrl-c、-ctrl-d" class="header-anchor">#</a> 4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d</h3> <p><strong>[Tab] 按键</strong></p> <p>它具有命令补全与文件补齐的功能。</p> <ul><li><p>[Tab] 接在一串命令的第一个字段后面，则为<strong>命令补全</strong>；</p></li> <li><p>[Tab] 接在一串命令的第二个字段后面，则为<strong>文件补齐</strong>；</p></li> <li><p>若安装了 Bash-completion 软件，则在某些命令后面使用 [Tab] 按键时，可以进行<strong>选项/参数的补齐</strong>功能。</p></li></ul> <p><strong>[Ctrl]-c 按键</strong></p> <p>中断目前程序。</p> <p><strong>[Ctrl]-d 按键</strong></p> <p>代表键盘输入结束（End Of File）。另外，它也可以用来取代 exit 的输入。例如想要直接离开命令行模式，可以直接按下 [Ctrl]-d 就能够直接离开（相当于输入 exit）。</p> <p><strong>[Shift]+{[Page UP]|[Page Down]}按键</strong></p> <p>如果在纯命令行的界面中执行某些命令，这个命令的输出信息相当长。所以导致前面的部分已经不在目前的屏幕中，可以用上述组合键实现上翻下翻。</p> <h3 id="_4-2-4-错误信息的查看"><a href="#_4-2-4-错误信息的查看" class="header-anchor">#</a> 4.2.4 错误信息的查看</h3> <h2 id="_4-3-linux-系统的在线求助-man-page-与-info-page"><a href="#_4-3-linux-系统的在线求助-man-page-与-info-page" class="header-anchor">#</a> 4.3 Linux 系统的在线求助 man page 与 info page</h2> <h2 id="_4-4-超简单的文本编辑器-nano"><a href="#_4-4-超简单的文本编辑器-nano" class="header-anchor">#</a> 4.4 超简单的文本编辑器：nano</h2> <h2 id="_4-5-正确的关机方法"><a href="#_4-5-正确的关机方法" class="header-anchor">#</a> 4.5 正确的关机方法</h2> <ul><li><p>数据同步写入磁盘：<code>sync</code></p></li> <li><p>常用的关机命令：<code>shutdown</code></p></li> <li><p>重新启动，关机：<code>reboot</code>、<code>halt</code>、<code>poweroff</code></p></li></ul> <h1 id="第二部分-linux-文件、目录与磁盘格式"><a href="#第二部分-linux-文件、目录与磁盘格式" class="header-anchor">#</a> 第二部分 Linux 文件、目录与磁盘格式</h1> <h1 id="_5-linux-的文件权限与目录配置"><a href="#_5-linux-的文件权限与目录配置" class="header-anchor">#</a> 5 Linux 的文件权限与目录配置</h1> <hr> <p>Linux 一般将文件可读写的身份分为三个类别，分别是拥有者（owner）、所属群组（group）、其他人（others），且三种身份各有读（read）、写（write）、执行（execute）等权限。</p> <h2 id="_5-1-用户与用户组"><a href="#_5-1-用户与用户组" class="header-anchor">#</a> 5.1 用户与用户组</h2> <p><strong>文件拥有者</strong></p> <p><strong>用户组概念</strong></p> <p>每个账号可以有多个用户组的支持。</p> <p><strong>其他人的概念</strong></p> <p>在 Linux 里面，任何一个文件都具有用户（User）、所属群组（Group）及其他人（Others）三种身份的个别权限。</p> <p>在 Linux 系统中，默认的情况下，所有的系统上的账号与一般身份用户，还有那个 root 的相关信息，都记录在 /etc/passwd 这个文件内，至于个人的密码则是记录在 /etc/shadow 这个文件内。此外，Linux 所有的组名都记录在 /etc/group 中。</p> <h2 id="_5-2-linux-文件权限概念"><a href="#_5-2-linux-文件权限概念" class="header-anchor">#</a> 5.2 Linux 文件权限概念</h2> <h3 id="_5-2-1-linux-文件属性"><a href="#_5-2-1-linux-文件属性" class="header-anchor">#</a> 5.2.1 Linux 文件属性</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599042836427-979b39e2-00f4-44e4-a7da-d244dab7d3da.png" alt="img"></p> <p>ls 是 list 的意思，重点在显示文件的文件名与相关属性，而选项 -al 则表示列出所有的文件详细的权限与属性（包含隐藏文件，就是文件名第一个字符为 . 的文件）。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599043001114-78539011-8085-448b-a813-ccbb7d2cab07.png" alt="img"></p> <p><strong>第一栏代表这个文件的类型与权限</strong></p> <ul><li><p>第一个字符代表这个文件是<strong>目录、文件或链接文件</strong>等。</p></li> <li><p>当为 [d] 则是目录，当为 [-] 则是文件，当为 [l] 则表示链接文件，若是 [b] 则表示为设备文件里面的可供存储的周边设备（可按块随机读写的设备），若是 [c] 则表示为设备文件里面的串行端口设备，例如键盘、鼠标（一次性读取设备）。</p></li> <li><p>接下来的字符，以三个为一组，且均为 [rwx] 的三个参数的组合。其中，[r] 代表可读、[w] 代表可写、[x] 代表可执行。要注意的是这三个权限的位置不会改变，如果没有权限，就会出现 [-] 减号而已。</p></li> <li><p>第一组为文件拥有者可具备的权限，第二组为加入此用户组之账号的权限，第三组为非本人且没有加入本用户组的其他账号的权限。</p></li></ul> <p><strong>第二栏表示有多少文件名链接到此节点（inode）</strong></p> <p>每个文件都会将它的权限与属性记录到文件系统的 inode 中，不过，我们使用的目录树却是使用文件名来记录，因此每个文件名就会链接到一个 inode，这个属性记录的就是有多少不同的文件名链接到相同的一个 inode 号码。</p> <p><strong>第三栏表示这个文件（或目录）的拥有者账号</strong></p> <p><strong>第四栏表示这个文件的所属用户组</strong></p> <p><strong>第五栏为这个文件的容量大小，默认单位为 Bytes</strong></p> <p><strong>第六栏为这个文件的创建日期或是最近的修改日期</strong></p> <p><strong>第七栏为这个文件名</strong></p> <p>如果文件名之前多一个【.】，则代表这个文件为隐藏文件。</p> <p><strong>Linux 文件权限的重要性</strong></p> <ul><li>系统保护的功能</li> <li>团队开发软件或数据共享的功能</li></ul> <h3 id="_5-2-2-如何修改文件属性与权限"><a href="#_5-2-2-如何修改文件属性与权限" class="header-anchor">#</a> 5.2.2 如何修改文件属性与权限</h3> <ul><li><p><code>chgrp</code> ：修改文件所属用户组</p></li> <li><p><code>chown</code> ：修改文件拥有者</p></li> <li><p><code>chmod</code> ：修改文件的权限</p></li></ul> <p>数字类型修改文件权限</p> <p>r：4</p> <p>w：2</p> <p>x：1</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">chmod</span> <span class="token number">664</span> .bashrc
</code></pre></div><p>符号类型修改文件权限</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">chmod</span> <span class="token assign-left variable">u</span><span class="token operator">=</span>rwx,go<span class="token operator">=</span>rx .bashrc
<span class="token function">chmod</span> a+w .bashrc
<span class="token function">chmod</span> a-x .bashrc
</code></pre></div><h3 id="_5-2-3-目录与文件的权限意义"><a href="#_5-2-3-目录与文件的权限意义" class="header-anchor">#</a> 5.2.3 目录与文件的权限意义</h3> <ol><li><strong>权限对文件的重要性</strong></li></ol> <p>文件是实际含有数据的地方，包括一般文本文件、数据库文件、二进制可执行文件等。因此，权限对于文件来说，它的意义是这样的：</p> <ul><li><p>r（read）：可读取此文件的实际内容</p></li> <li><p>w（write）：可以编辑、新增或是修改该文件的内容（但不包含删除该文件）</p></li> <li><p>x（eXecute）：该文件具有可以被系统执行的权限</p></li></ul> <p>在 Windows 下面，一个文件是否具有执行的能力是借由扩展名来判断的，在 Linux 下面，<strong>我们的文件是否能被执行，则是借由是否具有 [x] 这个权限来决定，跟文件名是没有绝对关系的</strong>。</p> <p>当一个文件具有 [w] 权限时，你可以具有写入、编辑、新增、修改文件内容的权限，<strong>但并不具备有删除该文件本身的权限</strong>。对于文件的 [rwx] 来说，主要都是针对文件的内容而言，与文件名的存在与否没有关系。</p> <ol><li><strong>权限对目录的重要性</strong></li></ol> <p>目录主要的内容在记录文件名列表，文件名与目录有强烈的关联。</p> <ul><li><p>r（read contents in directory）：表示具有读取目录结构列表的权限</p></li> <li><p>w（modify contents of directory）：表示具有改动该目录结构列表的权限</p></li> <li><p>x（access directory）：目录的 x 代表的是用户能否进入该目录成为工作目录</p></li></ul> <div class="language-shell extra-class"><pre class="language-shell"><code>drwxr--r-- <span class="token number">3</span> root root <span class="token number">4096</span> Jun <span class="token number">25</span> 08:35 .ssh
</code></pre></div><p>vbird 对此目录仅具有 r 的权限，因此 vbird 可以查询此目录下的文件名列表，因为 vbird 不具有 x 的权限，亦即 vbird 没有这个抽屉的钥匙，因此 vbird 并不能切换到此目录内。</p> <p><strong>如果你在某目录下不具有 x 的权限，那么你就无法切换到该目录下，也就无法执行该目录下的任何命令，即使你具有该目录的 r 或 w 的权限</strong>。</p> <h3 id="_5-2-4-linux-文件种类与扩展名"><a href="#_5-2-4-linux-文件种类与扩展名" class="header-anchor">#</a> 5.2.4 Linux 文件种类与扩展名</h3> <ol><li><strong>文件种类</strong></li></ol> <ol><li>常规文件 [-]</li></ol> <ul><li><p>纯文本文件</p></li> <li><p>二进制文件</p></li> <li><p>数据文件</p></li></ul> <ol start="2"><li><p>目录 [d]</p></li> <li><p>链接文件 [l]</p></li> <li><p>设备与设备文件</p></li></ol> <ul><li>区块设备文件 [b]</li> <li>字符设备文件 [c]</li></ul> <ol start="5"><li><p>数据接口文件 [s]</p></li> <li><p>数据输送文件 [p]</p></li></ol> <ol><li><strong>Linux 文件扩展名</strong></li></ol> <ul><li><p>*.sh：脚本或批处理文件</p></li> <li><p><em>.Z、</em>.tar、<em>.tar.gz、</em>.zip、*tgz：经过打包的压缩文件</p></li> <li><p><em>.html、</em>.php：网页相关文件</p></li></ul> <ol><li><strong>Linux 文件名长度限制</strong></li></ol> <p>单一文件或目录的最大容许文件名为 255 字节，以一个 ASCII 英文占用一个字节来说，则大约可达 255 个字符长度。若是以每个汉字占用 2 字节来说，最大文件名就是大约在 128 个汉字之间。</p> <ol><li><strong>Linux 文件名的限制</strong></li></ol> <p>由于 Linux 在命令行模式下的一些命令操作关系，一般来说，在设置 Linux 下面的文件名时，最好可以避免一些特殊字符比较好，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>* ? &gt; &lt; ; &amp; ! [ ] | \ ' &quot; ` ( ) { }
</code></pre></div><p>因为这些符号在命令行模式下，是有特殊意义。另外，文件名的开头为小数点【.】时，代表这个文件为隐藏文件。同时，由于命令执行当中，常常会使用到 <code>-option</code> 之类的选项，所以最好也避免将文件名的开头以 - 或 + 来命名。</p> <h2 id="_5-3-linux-目录配置"><a href="#_5-3-linux-目录配置" class="header-anchor">#</a> 5.3 Linux 目录配置</h2> <h3 id="_5-3-1-linux-目录配置的依据-fhs"><a href="#_5-3-1-linux-目录配置的依据-fhs" class="header-anchor">#</a> 5.3.1 Linux 目录配置的依据——FHS</h3> <table><thead><tr><th></th> <th>可分享（shareable）</th> <th>不可分享（unshareable）</th></tr></thead> <tbody><tr><td>不变（static）</td> <td>/usr（软件存放处）</td> <td>/etc（配置文件）</td></tr> <tr><td></td> <td>/opt（第三方辅助软件）</td> <td>/boot（启动与内核文件）</td></tr> <tr><td>可变动（variable）</td> <td>/var/mail（用户邮箱）</td> <td>/var/run（程序相关）</td></tr> <tr><td></td> <td>/var/spool/news（新闻组）</td> <td>/var/locak（程序相关）</td></tr></tbody></table> <ul><li><p>可分享：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录；</p></li> <li><p>不可分享：自己机器上面运行的设备文件或是与程序有关的 socket 文件等，由于仅与自身机器有关，所以当然就不适合分享给其他主机；</p></li> <li><p>不变：有些数据是不会经常变动的，跟随着发行版而不变动；</p></li> <li><p>可变动：经常修改的数据。</p></li></ul> <p>事实上，FHS 针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义：</p> <ul><li><p>/（root，根目录）：与启动系统有关</p></li> <li><p>/usr（unix software resource）：与软件安装/执行有关</p></li> <li><p>/var（variable）：与系统运行过程有关</p></li></ul> <ol><li><strong>根目录的意义与内容</strong></li></ol> <p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来，同时<strong>根目录也与启动、还原、系统修复等操作有关</strong>。</p> <p>FHS 建议：<strong>根目录（/）所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但性能较佳，根目录所在的文件系统也较不容易发生问题</strong>。</p> <table><thead><tr><th>目录</th> <th>应放置文件内容</th></tr></thead> <tbody><tr><td>第一部分：FHS 要求必须要存在的目录</td> <td></td></tr> <tr><td>/bin</td> <td>系统有很多存放执行文件的目录，但 /bin 比较特殊。因为 /bin 放置的是在单人维护模式下还能够被使用的命令。在 /bin 下面的命令可以被 root 与一般账号所使用，主要有：cat、chmod、chown、date、mv、mkdir、cp、bash 等常用的命令</td></tr> <tr><td>/boot</td> <td>这个目录主要在放置启动会使用到的文件，包括 Linux 内核文件以及启动选项与启动所需配置文件等。Linux 内核常用的文件名为：vmlinuz，如果使用的是 grub2 这个启动引导程序，则还会存在 /boot/grub2 这个目录</td></tr> <tr><td>/dev</td> <td>在 Linux 系统上，任何设备与接口设备都是以文件的形式存在于这个目录当中。你只要通过读写这个目录下面的某个文件，就等于读写某个设备，比较重要的文件有 /dev/null、/dev/zero、/dev/tty、/dev/loop*、/dev/sd* 等</td></tr> <tr><td>/etc</td> <td>系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、各种服务的启动文件等。一般来说，这个目录下的各文件属性是可以让一般用户查看的，但是只有 root 有权力修改。FHS 建议不要放置可执行文件在这个目录中。比较重要的文件有：/etc/modprobe.d、/etc/passwd、/etc/fstab、/etc/issue 等。另外 FHS 还规范几个重要的目录最好要存在 /etc 目录下：/etc/opt（必要）：这个目录在放置第三方辅助软件 /opt 的相关配置文件；/etc/X11（建议）：与 X Window 有关的各种配置文件都在这里；/etc/sgml（建议）：与 SGML 格式有关的各项配置文件；/etc/xml（建议）：与 XML 格式有关的各项配置文件</td></tr> <tr><td>/lib</td> <td>系统的函数库非常多，而 /lib 放置的则是在启动时会用到的函数库，以及在 /bin 或 /sbin 下面的命令会调用的函数库而已。FHS 要求下面的目录必须要存在：/lib/modules：这个目录主要放置可抽换式的内核相关模块（驱动程序）</td></tr> <tr><td>/media</td> <td>media 是媒体的英文，顾名思义，这个 /media 下面放置的就是可删除的设备，包括软盘、光盘、DVD 等设备都暂时挂载于此。</td></tr> <tr><td>/mnt</td> <td>如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。在早些时候，这个目录的用途与 /media 相同。只是有了 /media 之后，这个目录就暂时用来挂载</td></tr> <tr><td>/opt</td> <td>第三方辅助软件放置的目录。</td></tr> <tr><td>/run</td> <td>早期的 FHS 规定系统启动后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面，由于 /run 可以使用内存来模拟，因此性能上会好很多</td></tr> <tr><td>/sbin</td> <td>Linux 有非常多命令是用来设置系统环境的，这些命令只有 root 才能够用来设置系统，其他用户最多只能用来查询而已。放在 /sbin 下面的为启动过程中所需要的，里面包括了启动、修复、还原系统所需要的命令。常见的命令包括 fdisk、fsck、ifconfig、mkfs 等</td></tr> <tr><td>/srv</td> <td>srv 可视为 service 的缩写，是一些网络服务启动之后，这些服务所需要使用的数据目录。</td></tr> <tr><td>/tmp</td> <td>一般用户或是正在执行的程序暂时放置文件的地方。</td></tr> <tr><td>/usr</td> <td>与软件安装/执行有关</td></tr> <tr><td>/var</td> <td>与系统运行过程有关</td></tr> <tr><td>第二部分：FHS 建议可以存在的目录</td> <td></td></tr> <tr><td>/home</td> <td>这是系统默认的用户家目录。在你新增一个一般用户账号时，默认的用户家目录都会规范到这里来。</td></tr> <tr><td>/lib<qual></qual></td> <td>用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</td></tr> <tr><td>/root</td> <td>系统管理员（root）的家目录，之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的家目录，所以我们会希望 root 的家目录与根目录放置在同一个分区中</td></tr></tbody></table> <p>事实上 FHS 针对根目录所定义的标准就仅有上面的东西，不过我们的 Linux 下面还有许多目录也需要了解。</p> <table><thead><tr><th>目录</th> <th>应放置文件内容</th></tr></thead> <tbody><tr><td>/lost+found</td> <td>这个目录是使用标准的 ext2、ext3、ext4 文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时，将一些遗失的片段放置到这个目录下，不过如果使用的是 xfs 文件系统的话，就不会存在这个目录</td></tr> <tr><td>/proc</td> <td>这个目录本身是一个虚拟文件系统，它放置的数据都是在内存当中，例如系统内核、进程信息、外接设备的状态及网络状态等。因为这个目录下的数据都是在内存当中，所以本身不占任何硬盘空间</td></tr> <tr><td>/sys</td> <td>这个目录其实跟 /proc 非常相似，也是一个虚拟的文件系统，主要也是记录内核与系统硬件信息相关的内容。包括目前已加载的内核模块与内核检测到的硬件信息等，这个目录同样不占硬盘容量</td></tr></tbody></table> <ol><li><strong>/usr 的意义与内容</strong></li></ol> <table><thead><tr><th>目录</th> <th>应放置文件内容</th></tr></thead> <tbody><tr><td>第一部分：FHS 要求必须要存在的目录</td> <td></td></tr> <tr><td>/usr/bin</td> <td>所有一般用户能够使用的命令都放在这里。目前新的 CentOS 7 已经将全部的用户命令放置于此，而使用链接文件的方式将 /bin 链接至此。也就是说，/usr/bin 与 /bin 是一摸一样的。另外 FHS 要求在此目录下不应该有子目录</td></tr> <tr><td>/usr/lib</td> <td>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的</td></tr> <tr><td>/usr/local</td> <td>系统管理员在本机安装自己下载的软件，建议安装到此目录，这样会比较便于管理</td></tr> <tr><td>/usr/sbin</td> <td>非系统正常运行所需要的系统命令，最常见的就是某些网络服务器软件的服务命令。不过基本功能与 /sbin 也差不多，因此目前 /sbin 就是链接到此目录中的</td></tr> <tr><td>/usr/share</td> <td>主要放置只读的数据文件，当然也包括共享文件，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文本文件。在此目录下常见的还有这些子目录：/usr/share/man：在线帮助文件/usr/share/doc：软件的说明文档/usr/share/zoneinfo：与时区有关的时区文件</td></tr> <tr><td>第二部分：FHS 建议可以存在的目录</td> <td></td></tr> <tr><td>/usr/games</td> <td>与游戏比较相关的数据放置处</td></tr> <tr><td>/usr/include</td> <td>c/c++ 等程序语言的头文件（header）与包含文件（include）放置处，当我们以 Tarball 方式（*.tar.gz 的方式安装软件）安装某些程序时，会使用到里面的许多文件</td></tr> <tr><td>/usr/libexec</td> <td>某些不被一般用户常用的执行文件或脚本等，都会放置在此目录中。</td></tr> <tr><td>/usr/lib<qual></qual></td> <td>与 /lib<qual> 功能相同，因此目前 /lib<qual> 就是链接到此目录中</qual></qual></td></tr> <tr><td>/usr/src</td> <td>一般源代码建议放置到这里，至于内核源代码则建议放置到 /usr/src/Linux 目录下</td></tr></tbody></table> <ol><li><strong>/var 的意义与内容</strong></li></ol> <table><thead><tr><th>目录</th> <th>应放置文件内容</th></tr></thead> <tbody><tr><td>第一部分：FHS 要求必须要存在的目录</td> <td></td></tr> <tr><td>/var/cache</td> <td>应用程序本身运行过程中会产生的一些缓存</td></tr> <tr><td>/var/lib</td> <td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。</td></tr> <tr><td>/var/lock</td> <td>某些设备或是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁，以确保该设备只会给单一软件所使用。</td></tr> <tr><td>/var/log</td> <td>这是日志文件放置的目录，里面比较重要的文件有 /var/log/messages、/var/log/wtmp（记录登录信息）等</td></tr> <tr><td>/var/mail</td> <td>放置个人电子邮箱的目录，不过这个目录也被放置到 /var/spool/mail 目录中，通常这两个目录是互为链接文件</td></tr> <tr><td>/var/run</td> <td>某些程序或是服务启动后，会将他们的 PID 放置在这个目录下，与 /run 相同，这个目录链接到 /run 目录</td></tr> <tr><td>/var/spool</td> <td>这个目录通常放置一些队列数据，所谓的队列就是排队等待其他程序使用的数据，这些数据被使用后通常都会被删除。</td></tr></tbody></table> <h3 id="_5-3-2-目录树"><a href="#_5-3-2-目录树" class="header-anchor">#</a> 5.3.2 目录树</h3> <p>目录树的特性有：</p> <ul><li><p>目录树的起始点为根目录</p></li> <li><p>每一个目录不只能使用本地分区的文件系统，也可以使用网络上的文件系统</p></li> <li><p>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599308114164-776ac584-572b-4cb2-808f-6c7fe48ce67a.png" alt="img"></p> <h3 id="_5-3-3-绝对路径与相对路径"><a href="#_5-3-3-绝对路径与相对路径" class="header-anchor">#</a> 5.3.3 绝对路径与相对路径</h3> <ul><li><p>绝对路径：由根目录（/）开始写起的文件名或目录名称</p></li> <li><p>相对路径：相对于目前路径的文件名写法</p></li> <li><p>.：代表当前的目录，也可以使用 ./ 来表示</p></li> <li><p>..：代表上一层目录，也可以使用 ../ 来代表</p></li></ul> <h3 id="_5-3-4-centos-的观察"><a href="#_5-3-4-centos-的观察" class="header-anchor">#</a> 5.3.4 CentOS 的观察</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 通过 uname 检查 Linux 内核与操作系统加构版本</span>
<span class="token function">uname</span> -r <span class="token comment"># 查看内核版本</span>
<span class="token function">uname</span> -m <span class="token comment"># 查看操作系统的架构版本</span>
</code></pre></div><h1 id="_6-linux-文件与目录管理"><a href="#_6-linux-文件与目录管理" class="header-anchor">#</a> 6 Linux 文件与目录管理</h1> <hr> <h2 id="_6-1-目录与路径"><a href="#_6-1-目录与路径" class="header-anchor">#</a> 6.1 目录与路径</h2> <h3 id="_6-1-1-相对路径与绝对路径"><a href="#_6-1-1-相对路径与绝对路径" class="header-anchor">#</a> 6.1.1 相对路径与绝对路径</h3> <h3 id="_6-1-2-目录的相关操作"><a href="#_6-1-2-目录的相关操作" class="header-anchor">#</a> 6.1.2 目录的相关操作</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token builtin class-name">.</span>        代表此层目录
<span class="token punctuation">..</span>       代表上一层目录
-        代表前一个工作目录
~        代表目前使用者身份所在
~account 代表 account 这个使用者的家目录（account 是个账号名称）
</code></pre></div><p>需要特别注意的是：**在所有目录下面都会存在的两个目录，分别是“.”与“..”**分别代表此层与上层目录的意思。</p> <p>若使用“ls -al /”去查询，可以看到根目录下确实存在 . 与 .. 两个目录，再仔细查看，可发现这两个目录的属性与权限完全一致，这代表<strong>根目录的上一层与根目录自己是同一个目录</strong>。</p> <ul><li><p>cd：切换目录</p></li> <li><p>pwd：显示当前目录</p></li> <li><p>mkdir：建立一个新目录</p></li> <li><p>rmdir：删除一个空目录</p></li></ul> <h3 id="_6-1-3-关于执行文件路径的变量-path"><a href="#_6-1-3-关于执行文件路径的变量-path" class="header-anchor">#</a> 6.1.3 关于执行文件路径的变量：$PATH</h3> <p>当我们执行一个命令的时候，例如 ls，系统会依照 PATH 的设置去每个 PATH 定义的目录下查找文件名为 ls 的可执行文件，如果在 PATH 定义的目录中含有多个文件名为 ls 的可执行文件，那么先查到的同名命令先被执行。</p> <ul><li><p>不同身份用户默认的 PATH 不同，默认能够随意执行的命令也不同</p></li> <li><p>PATH 是可以修改的</p></li> <li><p>使用绝对路径或相对路径直接指定某个命令的文件名来执行，会比查找 PATH 来的正确</p></li> <li><p>命令应该要放置到正确的目录下，执行才会比较方便</p></li> <li><p>本目录（.）最好不要放到 PATH 当中</p></li></ul> <h2 id="_6-2-文件与目录管理"><a href="#_6-2-文件与目录管理" class="header-anchor">#</a> 6.2 文件与目录管理</h2> <h3 id="_6-2-1-文件与目录的查看-ls"><a href="#_6-2-1-文件与目录的查看-ls" class="header-anchor">#</a> 6.2.1 文件与目录的查看：ls</h3> <h3 id="_6-2-2-复制、删除与移动-cp、rm、mv"><a href="#_6-2-2-复制、删除与移动-cp、rm、mv" class="header-anchor">#</a> 6.2.2 复制、删除与移动：cp、rm、mv</h3> <p>在默认的条件中，cp 的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作者本身。由于具有这个特性，因此当我们在进行备份的时候，某些需要特别注意的特殊权限文件，就不能直接以 cp 来复制，而必须要加上 -a 或是 -p 等可以完整复制文件权限的选项才行。</p> <h3 id="_6-2-3-获取路径的文件名与目录名称"><a href="#_6-2-3-获取路径的文件名与目录名称" class="header-anchor">#</a> 6.2.3 获取路径的文件名与目录名称</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># basename /etc/sysconfig/network</span>
network
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># dirname /etc/sysconfig/network</span>
/etc/sysconfig
</code></pre></div><h2 id="_6-3-文件内容查看"><a href="#_6-3-文件内容查看" class="header-anchor">#</a> 6.3 文件内容查看</h2> <ul><li><p>cat 由第一行开始显示文件内容</p></li> <li><p>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写</p></li> <li><p>nl 显示的时候，同时输出行号</p></li> <li><p>more 一页一页地显示文件内容</p></li> <li><p>less 与 more 类似，但是比 more 更好的是，它可以往前翻页</p></li> <li><p>head 只看前面几行</p></li> <li><p>tail 只看后面几行</p></li> <li><p>od 以二进制的方式读取文件内容</p></li></ul> <h3 id="_6-3-1-直接查看文件内容"><a href="#_6-3-1-直接查看文件内容" class="header-anchor">#</a> 6.3.1 直接查看文件内容</h3> <p>直接查看一个文件的内容可以使用 cat / tac / nl 这几个命令。</p> <h3 id="_6-3-2-可翻页查看"><a href="#_6-3-2-可翻页查看" class="header-anchor">#</a> 6.3.2 可翻页查看</h3> <ol><li>more</li></ol> <ul><li><p>空格键：代表向下翻一页</p></li> <li><p>Enter：代表向下翻一行</p></li> <li><p>/字符串：代表在这个显示的内容当中，向下查找字符串这个关键词</p></li> <li><p>:f：立刻显示出文件名以及目前显示的行数</p></li> <li><p>q：代表立刻离开 more，不再显示该文件内容</p></li> <li><p>b 或 [ctrl]-b：代表往回翻页，不过这操作只对文件有用，对管道无用</p></li></ul> <ol><li>less</li></ol> <ul><li><p>空格键：向下翻动一页</p></li> <li><p>[pagedown]：向下翻动一页</p></li> <li><p>[pageup]：向上翻动一页</p></li> <li><p>/字符串：向下查找字符串的功能</p></li> <li><p>?字符串：向上查找字符串的功能</p></li> <li><p>n：重复前一个查找（与 / 或 ? 有关）</p></li> <li><p>N：反向的重复前一个查找（与 / 或 ? 有关）</p></li> <li><p>g：前进到这个数据的第一行</p></li> <li><p>G：前进到这个数据的最后一行</p></li> <li><p>q：离开 less 这个程序</p></li></ul> <h3 id="_6-3-3-数据截取"><a href="#_6-3-3-数据截取" class="header-anchor">#</a> 6.3.3 数据截取</h3> <p>我们可以将输出的数据做一个简单的截取，那就是取出文件前面几行（head）或取出后面几行（tail）文字的功能。不过，要注意的是 head 与 tail 都是以“行”为单位来进行数据截取的。</p> <ol><li>head</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># head [-n number] 文件</span>
选项与参数：
-n：后面接数字，代表显示几行的意思。

<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># head /etc/man_db.conf</span>
<span class="token comment">#默认的情况中，显示前面十行，若要显示前20行，如下所示。</span>
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># head -n 20 /etc/man_db.conf</span>

范例：如果后面100行的数据都不打印，只打印/etc/man_db.conf的前面几行
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># head -n -100 /etc/man_db.conf</span>
</code></pre></div><ol><li>tail</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># tail [-n number] 文件</span>
选项与参数：
-n：后面接数字，代表显示几行的意思。
-f：表示持续刷新显示后面所接文件中的内容，要等到按下<span class="token punctuation">[</span>ctrl<span class="token punctuation">]</span>-c才会结束。

<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># tail /etc/man_db.conf</span>
<span class="token comment">#默认的情况中，显示最后的十行，若要显示最后的20行，如下所示。</span>
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># tail -n 20 /etc/man_db.conf</span>

范例一：如果不知道/etc/man_db.conf有几行，却只想列出100行以后的数据时
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># tail -n +100 /etc/man_db.conf</span>

范例二：持续监测/var/log/messages的内容
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># tail -f /var/log/messages</span>
</code></pre></div><p>假如想要显示 /etc/man_db.conf 的第 11 行到第 20 行？</p> <p>答：head -n 20 /etc/man_db.conf | tail -n 10。这两个命令中间有个管道（|）的符号存在，这个管道的意思是：前面的命令所输出的信息，通过管道交由后续的命令继续使用。</p> <h3 id="_6-3-4-非纯文本文件-od"><a href="#_6-3-4-非纯文本文件-od" class="header-anchor">#</a> 6.3.4 非纯文本文件：od</h3> <h3 id="_6-3-5-修改文件时间或创建新文件-touch"><a href="#_6-3-5-修改文件时间或创建新文件-touch" class="header-anchor">#</a> 6.3.5 修改文件时间或创建新文件：touch</h3> <p>我们在介绍 ls 这个命令时，提到每个文件在 Linux 下面都会记录许多的时间参数，其实是有三个主要的变动时间：</p> <ul><li><p>修改时间（modification time，mtime）：当该文件的【内容数据】变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。</p></li> <li><p>状态时间（status time，ctime）：当该文件的【状态】改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。</p></li> <li><p>读取时间（access time，atime）：当该文件的【内容被读取】时，就会更新这个读取时间。</p></li></ul> <p>touch 这个命令最常被使用的情况是：</p> <ul><li>建立一个空文件；</li> <li>将某个文件日期自定义为目前（mtime 与 atime）。</li></ul> <h2 id="_6-4-文件与目录的默认权限与隐藏权限"><a href="#_6-4-文件与目录的默认权限与隐藏权限" class="header-anchor">#</a> 6.4 文件与目录的默认权限与隐藏权限</h2> <h3 id="_6-4-1-文件默认权限-umask"><a href="#_6-4-1-文件默认权限-umask" class="header-anchor">#</a> 6.4.1 文件默认权限：umask</h3> <p>umask 是指定<strong>目前用户在建立文件或目录时候的权限默认值</strong>。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># umask</span>
0022    <span class="token operator">&lt;=</span><span class="token operator">=</span>与一般权限有关的是后面三个数字。
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># umask -S</span>
<span class="token assign-left variable">u</span><span class="token operator">=</span>rwx,g<span class="token operator">=</span>rx,o<span class="token operator">=</span>rx
</code></pre></div><p>查看的方式有两种，一种可以直接输入 umask，就可以看到数字类型的权限设置值，一种则是加入 -S（Symbolic）这个选项，就会以符号类型的方式来显示出权限了。</p> <p>在默认权限的属性上，目录与文件是不一样的，x 权限对于目录是非常重要的，但是一般文件的建立则不应该有执行的权限，因为一般文件通常是用于数据的记录。因此，默认的情况如下：</p> <ul><li>若用户建立为文件则默认没有可执行（x）权限，即只有 rw 这两个项目，也就是最大为 666，默认权限如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>-rw-rw-rw-
</code></pre></div><ul><li>若用户建立为目录，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，即 777，默认权限如下：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>drwxrwxrwx
</code></pre></div><p>要注意的是，umask 的数字指的是<strong>该默认值需要减掉的权限</strong>。</p> <p>在默认的情况中，root 的 umask 会拿掉比较多的属性，root 的 umask 默认是 022，这是基于安全的考虑，至于一般身份用户，通常他们的 umask 为 002，即保留同用户组的写入权力。</p> <h3 id="_6-4-2-文件隐藏属性"><a href="#_6-4-2-文件隐藏属性" class="header-anchor">#</a> 6.4.2 文件隐藏属性</h3> <ul><li>chattr（配置文件隐藏属性）</li> <li>lsattr（显示文件隐藏属性）</li></ul> <h3 id="_6-4-3-文件特殊权限-suid、sgid、sbit"><a href="#_6-4-3-文件特殊权限-suid、sgid、sbit" class="header-anchor">#</a> 6.4.3 文件特殊权限：SUID、SGID、SBIT</h3> <ol><li><strong>Set UID</strong></li></ol> <p>当 s 这个标志出现在文件拥有者的 x 权限上时，例如 /usr/bin/passwd 这个文件的权限状态：【-rwsr-xr-x】，此时就被称为 Set UID，简称为 SUID 的特殊权限。基本上 SUID 有这样的限制与功能：</p> <ul><li><p>SUID权限仅对二进制文件有效</p></li> <li><p>执行者对于该程序需要具有 x 的可执行权限</p></li> <li><p>本权限仅在执行该程序的过程中有效</p></li> <li><p>执行者将具有该程序拥有者的权限</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599486833112-eeb181db-824c-4d0f-8728-592a21a26b6c.png" alt="img"></p> <p><strong>SUID 仅可用在二进制程序上，不能够用在 shell 脚本上面</strong>。这是因为 shell 脚本只是将很多的二进制执行文件调用而已。所以 SUID 的权限部分，还是要看 shell 脚本调用进来的程序的设置，而不是 shell 脚本本身。当然，SUID 对于目录来说也是无效的，这点要特别留意。</p> <ol><li><strong>Set GID</strong></li></ol> <p>当 s 标志在文件拥有者的 x 项为 SUID，那 s 在用户组的 x 时则称为 Set GID（SGID）。</p> <p>与 SUID 不同的是，SGID 可以针对文件或目录来设置。如果是对文件来说，SGID 有如下的功能：</p> <ul><li><p>SGID 对二进制程序有用</p></li> <li><p>程序执行者对该程序来说，需具备 x 的权限</p></li> <li><p>执行者在执行的过程中将会获得该程序用户组的支持</p></li></ul> <p>当一个目录设置了 SGID 的权限之后，他将具有如下的功能：</p> <ul><li><p>用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录</p></li> <li><p>用户在此目录下的有效用户组将会变成该目录的用户组</p></li> <li><p>用途：若用户在此目录下具有 w 的权限（可以新建文件），则用户所建立的新文件，该新文件的用户组与此目录的用户组相同</p></li></ul> <ol><li><strong>Sticky Bit</strong></li></ol> <p>Sticky Bit（SBIT）目前只针对目录有效，对于文件已经没有效果了，SBIT 对于目录的作用是：</p> <ul><li>当用户对于此目录具有 w、x权限，即具有写入的权限</li> <li>当用户在该目录下建立文件或目录时，仅有自己与 root 才有权力删除该文件</li></ul> <ol><li><strong>SUID/SGID/SBIT 权限设置</strong></li></ol> <ul><li><p>4 为 SUID</p></li> <li><p>2 为 SGID</p></li> <li><p>1 为 SBIT</p></li></ul> <p>假设要将一个文件权限改为【-rwsr-xr-x】时，由于 s 在用户权限中，所以是 SUID，因此，在原先的 755 之前还要加上 4，也就是【chmod 4755 filename】来设置。</p> <h3 id="_6-4-4-观察文件类型-file"><a href="#_6-4-4-观察文件类型-file" class="header-anchor">#</a> 6.4.4 观察文件类型：file</h3> <h2 id="_6-5-命令与文件的查找"><a href="#_6-5-命令与文件的查找" class="header-anchor">#</a> 6.5 命令与文件的查找</h2> <h3 id="_6-5-1-脚本文件的查找"><a href="#_6-5-1-脚本文件的查找" class="header-anchor">#</a> 6.5.1 脚本文件的查找</h3> <ul><li><strong>which（查找【执行文件】）</strong></li></ul> <p>这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。</p> <h3 id="_6-5-2-文件的查找"><a href="#_6-5-2-文件的查找" class="header-anchor">#</a> 6.5.2 文件的查找</h3> <p>通常 find 不很常用，除速度慢之外，也影响硬盘性能。一般我们都是先使用 whereis 或是 locate 来检查，如果真的找不到了，才以 find 来查找。因为 whereis 只找系统中某些特定目录下面的文件而已，locate 则是利用数据库来查找文件名。</p> <ol><li><p><strong>whereis（由一些特定的目录中查找文件）</strong></p></li> <li><p><strong>locate/updatedb</strong></p></li></ol> <ul><li>updatedb：根据 /etc/updatedb.conf 的设置去查找系统硬盘内的文件，并更新 /var/lib/mlocate 内的数据库文件</li> <li>locate：依据 /var/lib/mlocate 内的数据库记录，找出用户所输入关键词的文件名</li></ul> <ol><li><strong>find</strong></li></ol> <h1 id="_7-linux-磁盘与文件系统管理"><a href="#_7-linux-磁盘与文件系统管理" class="header-anchor">#</a> 7 Linux 磁盘与文件系统管理</h1> <hr> <h2 id="_7-1-认识-linux-文件系统"><a href="#_7-1-认识-linux-文件系统" class="header-anchor">#</a> 7.1 认识 Linux 文件系统</h2> <h3 id="_7-1-1-磁盘组成与分区的复习"><a href="#_7-1-1-磁盘组成与分区的复习" class="header-anchor">#</a> 7.1.1 磁盘组成与分区的复习</h3> <p>整块磁盘的物理组成主要有：</p> <ul><li><p>圆形的碟片（主要记录数据的部分）</p></li> <li><p>机械手臂，与在机械手臂上的磁头（可擦写碟片上的数据）</p></li> <li><p>主轴马达，可以转动碟片，让机械手臂的磁头在碟片上读写数据</p></li></ul> <p>从上面我们知道数据存储与读取的重点在于碟片，而碟片上的物理组成则为（假设磁盘为单盘片）：</p> <ul><li><p>扇区为最小的物理存储单位，且依据磁盘设计的不同，目前主要有 512B 与 4KB 两种格式</p></li> <li><p>将扇区组成一个圆，那就是柱面</p></li> <li><p>早期的分区主要以柱面为最小分区单位，现在的分区通常使用扇区为最小分区单位</p></li> <li><p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表</p></li> <li><p>MBR 分区表中，第一个扇区最重要，里面有：主引导记录及分区表，其中 MBR 占有 446B，而分区表则占有 64B</p></li> <li><p>GPT 分区表除了分区数量扩充较多之外，支持的磁盘容量也可以超过 2TB</p></li> <li><p>/dev/sd[a-p][1-128]：为物理磁盘的文件名</p></li> <li><p>/dev/vd[a-d][1-128]：为虚拟磁盘的文件名</p></li></ul> <h3 id="_7-1-2-文件系统特性"><a href="#_7-1-2-文件系统特性" class="header-anchor">#</a> 7.1.2 文件系统特性</h3> <p>我们都知道磁盘分区完毕后还需要进行格式化，之后操作系统才能够使用这个文件系统。为什么需要进行格式化？这是因为每种操作系统所设置的文件属性/权限并不相同，为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式。</p> <p>由此我们也能够知道，每种操作系统能够使用的文件系统并不相同。举例来说，Windows 98 以前的微软操作系统主要使用的文件系统是 FAT（或 FAT16），Windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 ext2（Linux second Extended file system, ext2fs）。此外，在默认的情况下，Windows 操作系统不支持 Linux 的 ext2 文件系统。</p> <p>传统的磁盘与文件系统应用中，一个分区就只能够被格式化成为一个文件系统，所以我们可以说一个文件系统就是一个硬盘分区。但是由于新技术的利用，例如我们常听到的 LVM 与软件磁盘阵列，这些技术可以将一个分区格式化为多个文件系统，也能够将多个分区合成一个文件系统。所以说，目前我们在格式化时已经不再说成针对硬盘分区来格式化了，通常我们可以称呼<strong>一个可被挂载的数据为一个文件系统而不是一个分区</strong>。</p> <p>较新的操作系统的文件除了文件实际内容外，通常含有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、用户组、时间参数等）。<strong>文件系统通常会将文件权限与文件属性这两部分的数据放置到 inode 中，至于实际数据则放置到数据区块中</strong>。另外，还有一个超级区块会记录整个文件系统的整体信息，包括 inode 与数据区块的总量、使用量、剩余量等。</p> <ul><li><p>超级区块：记录此文件系统的整体信息，包括 inode 与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息等</p></li> <li><p>inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的区块号码</p></li> <li><p>数据区块：实际记录文件的内容，若文件太大时，会占用多个区块</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599570700225-8f803701-2dc0-4a1f-8f31-db26a61b6845.png" alt="img"></p> <p>inode/block 数据存取示意图</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599570857639-a796d448-53af-4839-9836-0542a8b66bb2.png" alt="img"></p> <p>FAT 文件系统数据存取示意图</p> <p><strong>需要碎片整理的原因就是文件写入的区块太过于离散，此时文件读取的性能就会变得很差。这个时候可以通过碎片整理将同一个文件所属的区块集合在一起，这样数据的读取会比较容易</strong>。</p> <h3 id="_7-1-3-linux-的-ext2-文件系统-inode"><a href="#_7-1-3-linux-的-ext2-文件系统-inode" class="header-anchor">#</a> 7.1.3 Linux 的 ext2 文件系统（inode）</h3> <p><strong>文件系统一开始就将 inode 与数据区块规划好了，除非重新格式化（或利用 resize2fs 等命令修改其大小），否则 inode 与数据区块固定后就不再变动</strong>。但是如果仔细考虑一下，如果我的文件系统高达数百 GB 时，那么将所有的 inode 与数据区块通通放置在一起将是很不明智的决定，因为 inode 与数据区块的数量太庞大，不容易管理。</p> <p>因此，ext2 文件系统格式化的时候基本上是区分为多个区块群组（block group），每个区块群组都有独立的 inode、数据区块、超级区块系统。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599571697214-225d2e9a-9563-4971-b40e-244274d4f74e.png" alt="img"></p> <p>在整体的规划当中，<strong>文件系统最前面有一个启动扇区，这个启动扇区可以安装启动引导程序</strong>，这是个非常重要的设计，因为如此一来我们就能够将不同的启动引导程序安装到别的文件系统最前端，而不用覆盖整块磁盘唯一的 MBR，这样也才能够制作出多重引导的环境。</p> <p>区块群组的六个主要内容如下：</p> <ol><li><strong>数据区块（data block）</strong></li></ol> <p>数据区块是用来放置文件数据的地方，<strong>在 ext2 文件系统中所支持的区块大小有 1K、2K 及 4K三种</strong>。在格式化时区块的大小就固定了，且每个区块都有编号，以方便 inode 的记录。不过要注意的是，区块大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量并不相同，因为区块大小而产生的 ext2 文件系统限制如下：</p> <table><thead><tr><th>Block 大小</th> <th>1KB</th> <th>2KB</th> <th>4KB</th></tr></thead> <tbody><tr><td>最大单一文件限制</td> <td>16GB</td> <td>256GB</td> <td>2TB</td></tr> <tr><td>最大文件系统总容量</td> <td>2TB</td> <td>8TB</td> <td>16TB</td></tr></tbody></table> <p>除此之外，ext2 文件系统还有如下限制：</p> <ul><li><p>原则上，区块的大小与数量在格式化完就不能够再修改（除非重新格式化）</p></li> <li><p>每个区块内最多只能够放置一个文件的数据</p></li> <li><p>承上，如果文件大于区块的大小，则一个文件会占用多个区块数量</p></li> <li><p>承上，若文件小于区块，则该区块的剩余容量就不能够再被使用了（磁盘空间会浪费）</p></li></ul> <ol><li><strong>inode table（inode 表）</strong></li></ol> <p>inode 记录的数据至少有下面这些：</p> <ul><li><p>该文件的读写属性（read、write、execute）</p></li> <li><p>该文件的拥有者与用户组（owner、group）</p></li> <li><p>该文件的大小</p></li> <li><p>该文件建立或状态改变的时间（ctime）</p></li> <li><p>最近一次的读取时间（atime）</p></li> <li><p>最近修改的时间（mtime）</p></li> <li><p>定义文件特性的标识（flag），如 SetUID</p></li> <li><p>该文件真正内容的指向（pointer）</p></li></ul> <p>inode 的数量与大小也是在格式化时就已经固定了，除此之外，inode 还有以下特点：</p> <ul><li><p>每个 inode 大小均固定为 128B（新的 ext4 与 xfs 可设置到 256B）</p></li> <li><p>每个文件都仅会占用一个 inode 而已</p></li> <li><p>承上，因此文件系统能够建立的文件数量与 inode 的数量有关</p></li> <li><p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够读取区块的内容</p></li></ul> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599573504041-c1fc2979-3453-4b4f-923b-f1008dd67183.png" alt="img"></p> <ol><li><strong>Superblock（超级区块）</strong></li></ol> <p>超级区块是记录整个文件系统相关信息的地方，没有超级区块，就没有这个文件系统，它记录的信息主要有：</p> <ul><li><p>数据区块与 inode 的总量</p></li> <li><p>未使用与已使用的 inode 与数据区块数量</p></li> <li><p>数据区块与 inode 的大小（block 为1、2、4K，inode 为 128B 或 256B）</p></li> <li><p>文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等文件系统的相关信息</p></li> <li><p>一个有效位数值，若此文件系统已被挂载，则有效位为 0，若未被挂载，则有效位为 1</p></li></ul> <ol><li><strong>Filesystem Description（文件系统描述说明）</strong></li></ol> <p>这个区段可以描述每个区块群组的开始与结束的区块，以及说明每个区块（超级区块、对照表、inode 对照表、数据区块）分别介于哪一个区块之间。</p> <ol><li><strong>区块对照表（block bitmap）</strong></li></ol> <p>从区块对照表中可以知道哪些区块是空的，因此我们的系统就能够很快速地找到可使用的空间来处理文件。同样，如果你删除某些文件时，那么那些文件原本占用的区块号码就要释放出来，此时在区块对照表当中对应到该区块号码的标志就要修改成为【未使用中】，这就是对照表的功能。</p> <ol><li><strong>inode 对照表</strong></li></ol> <h3 id="_7-1-4-与目录树的关系"><a href="#_7-1-4-与目录树的关系" class="header-anchor">#</a> 7.1.4 与目录树的关系</h3> <ol><li><strong>目录</strong></li></ol> <p>当我们在 Linux 下的文件系统建立一个目录时，<strong>文件系统会分配一个 inode 与至少一块区块给该目录</strong>。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块区块号码，而区块则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599612632908-396f97cd-cc3d-4158-bbca-86c9c3fa3d95.png" alt="img"></p> <p>目录下面的文件数如果太多而导致一个区块无法记录得下所有的文件名与 inode 对照表时，Linux 会多给该目录一个区块来继续记录相关的数据。</p> <ol><li><strong>文件</strong></li></ol> <p>当我们在 Linux 下的 ext2 建立一个一般文件时，ext2 会分配一个 inode 与相对于该文件大小的区块数量给该文件。</p> <ol><li><strong>目录树读取</strong></li></ol> <h3 id="_7-1-5-ext2-ext3-ext4-文件的存取与日志式文件系统的功能"><a href="#_7-1-5-ext2-ext3-ext4-文件的存取与日志式文件系统的功能" class="header-anchor">#</a> 7.1.5 ext2/ext3/ext4 文件的存取与日志式文件系统的功能</h3> <p>假设我们想要新增一个文件，此时文件系统的操作是：</p> <ol><li><p>先确定用户对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增</p></li> <li><p>根据 inode 对照表找到没有使用的 inode 号码，并将新文件的权限/属性写入</p></li> <li><p>根据区块对照表找到没有使用中的区块号码，并将实际的数据写入区块中，且更新 inode 的区块指向数据</p></li> <li><p>将刚刚写入的 inode 与区块数据同步更新 inode 对照表与区块对照表，并更新超级区块的内容</p></li></ol> <p>一般来说，我们将 inode 与数据区块称为数据存放区域，至于其他例如超级区块、区块对照表与 inode 对照表等区段就被称为元数据，因为<strong>超级区块、inode 对照表及区块对照表的数据是经常变动的，每次新增、删除、编辑时都可能会影响到这三个部分的数据，因此才被称为元数据</strong>。</p> <ol><li><p><strong>数据的不一致状态</strong></p></li> <li><p><strong>日志式文件系统</strong></p></li></ol> <ol><li><p>预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的信息</p></li> <li><p>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据</p></li> <li><p>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的记录</p></li></ol> <p>在这样的程序当中，万一数据的记录过程当中发生了问题，那么我们的系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整个文件系统进行检查，这样就可以达到快速修复文件系统的目的，这就是日志式文件最基础的功能。</p> <h3 id="_7-1-6-linux-文件系统的运行"><a href="#_7-1-6-linux-文件系统的运行" class="header-anchor">#</a> 7.1.6 Linux 文件系统的运行</h3> <p>所有的数据要加载到内存后 CPU 才能够进行处理，想一想，如果常常编辑一个好大的文件，在编辑的过程中又频繁地要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多，因此会常常耗在等待磁盘的读写上。为了解决这个效率的问题，Linux 使用一个称为异步处理（asynchronously）的方式。</p> <p>所谓的异步处理是这样的：</p> <p>当系统加载一个文件到内存后，如果该文件没有被修改过，则在内存区段的文件数据会被设置为【干净（clean）】。<strong>但如果内存中的文件数据被更改过了，此时该内存中的数据会被设置为【脏的（Dirty）】，此时所有的操作都还在内存中执行，并没有写入到磁盘中</strong>。系统会不定时的将内存中设置为【Dirty】的数据写回磁盘，以保持磁盘与内存数据的一致性。</p> <p>Linux 系统上面的文件系统与内存有非常大的关系：</p> <ol><li><p>系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读写操作</p></li> <li><p>承上，因此 Linux 的物理内存最后都会被用光，这是正常的情况，可加速系统性能</p></li> <li><p>你可以手动使用 sync 来强制内存中设置为 Dirty 的文件回写到磁盘中</p></li> <li><p>若正常关机时，关机命令会主动调用 sync 来将内存的数据回写入磁盘内</p></li> <li><p>但若不正常关机（如断电、宕机或其他不明原因），由于数据尚未回写到磁盘内，因此重新启动后可能会花很多时间在进行磁盘校验，甚至可能导致文件系统的损坏（非磁盘损坏）</p></li></ol> <h3 id="_7-1-7-挂载点的意义"><a href="#_7-1-7-挂载点的意义" class="header-anchor">#</a> 7.1.7 挂载点的意义</h3> <p>每个文件系统都有独立的 inode、区块、超级区块等信息，这个文件系统要能够链接到目录树才能被我们使用。将文件系统与目录树结合的操作我们称为【挂载】。<strong>挂载点一定是目录，该目录为进入该文件系统的入口</strong>。因此并不是你有任何文件系统都能使用，必须要挂载到目录树的某个目录后，才能够使用该文件系统。</p> <h3 id="_7-1-8-其他-linux-支持的文件系统与-vfs"><a href="#_7-1-8-其他-linux-支持的文件系统与-vfs" class="header-anchor">#</a> 7.1.8 其他 Linux 支持的文件系统与 VFS</h3> <p>常见的支持文件系统有：</p> <ul><li><p>传统文件系统：ext2、minix、FAT（用 vfat 模块）、iso9660（光盘）等</p></li> <li><p>日志式文件系统：ext3、ext4、ReiserFS、Windows' NTFS 、IBM's JFS、SGI's XFS、ZFS</p></li> <li><p>网络文件系统：NFS、SMBFS</p></li></ul> <p><strong>Linux VFS</strong></p> <p>Linux 系统是通过一个名为 Virtual Filesystem Switch 的内核功能去读取文件系统。也就是说，整个 Linux 识别的文件系统其实多是 VFS 在进行管理，我们用户并不需要知道每个硬盘分区上面的文件系统是什么，VFS 会主动帮我们做好读取的操作。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599783947484-8ca39c18-ec4e-4b01-b68c-ed504f4d58fc.png" alt="img"></p> <h3 id="_7-1-9-xfs-文件系统简介"><a href="#_7-1-9-xfs-文件系统简介" class="header-anchor">#</a> 7.1.9 XFS 文件系统简介</h3> <p>CentOS 7 开始，默认的文件系统已经由原本的 ext4 变成了 xfs 文件系统，为啥 CentOS 要舍弃对 Linux 支持度最完整的 ext 系列而改用 xfs 呢？这是有一些原因存在的。</p> <ol><li><p><strong>ext 系列当前较伤脑筋的地方：支持度最广，但格式化超慢</strong></p></li> <li><p><strong>XFS 文件系统的配置</strong></p></li></ol> <p>基本上 xfs 就是一个日志式文件系统，而 CentOS 7.x 拿它当默认的文件系统，自然就是因为最早之前，这个 xfs 就是被开发来用于高容量磁盘以及高性能文件系统之用，因此，相当适合现在的系统环境。此外，几乎所有的 ext4 文件系统有的功能，xfs 都可以具备。</p> <p>xfs 文件系统在数据的分布上，主要规划为三个部分，一个数据区、一个文件系统活动登录区以及一个实时运行区。</p> <p><strong>数据区</strong>：包括 inode、数据区块、超级区块等数据。</p> <p><strong>文件系统活动登录区</strong>：主要被用来记录文件系统的变化，其实有点像是日志区。文件的变化会在这里记录下来，直到该变化完整地写入到数据区后，该条记录才会被结束。</p> <p><strong>实时运行区</strong>：当有文件要被建立时，xfs 会在这个区段里面找一个到数个的 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到 data section 的 inode 与区块中。</p> <ol><li><strong>XFS 文件系统的描述数据观察</strong></li></ol> <h2 id="_7-2-文件系统的简单操作"><a href="#_7-2-文件系统的简单操作" class="header-anchor">#</a> 7.2 文件系统的简单操作</h2> <h3 id="_7-2-1-磁盘与目录的容量"><a href="#_7-2-1-磁盘与目录的容量" class="header-anchor">#</a> 7.2.1 磁盘与目录的容量</h3> <p>磁盘的整体数据是在超级区块中，但是每个文件的容量则在 inode 当中记载。</p> <ul><li>df：列出文件系统的整体磁盘使用量</li> <li>du：查看文件系统的磁盘使用量（常用在查看目录所占磁盘空间）</li></ul> <p>由于 df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在超级区块内的信息，所以这个命令显示结果的速度非常快。</p> <h3 id="_7-2-2-硬链接与符号链接-ln"><a href="#_7-2-2-硬链接与符号链接-ln" class="header-anchor">#</a> 7.2.2 硬链接与符号链接：ln</h3> <p>在 Linux 下面的链接文件有两种，一种是类似 Windows 的快捷方式功能的文件，可以让你快速地链接到目标文件（或目录）；另一种则是通过文件系统的 inode 链接来产生新文件名，而不是产生新文件，这种称为硬链接。</p> <ol><li><strong>硬链接</strong></li></ol> <ul><li>每个文件都会占用一个 inode，文件内容由 inode 的记录来指向</li> <li>想要读取该文件，必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取</li></ul> <p>也就是说，其实文件名只与目录有关，但是文件内容则与 inode 有关。</p> <p><strong>硬链接只是在某个目录下新增一条文件名链接到某 inode 号码的关联记录而已</strong>。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599796593003-1b63cd30-d953-4aa7-865f-9a235a9d4628.png" alt="img"></p> <p>硬链接的好处：安全。<strong>如果你将任何一个文件名删除，其实 inode 与区块都还是存在的</strong>。此时你可以通过另一个文件名来读取到正确的文件数据。此外，不论你使用哪个文件名来编辑，最终的结果都会写入到相同的 inode 与区块中，因此均能进行数据的修改。</p> <p>硬链接的限制：</p> <ul><li>不能跨文件系统</li> <li>不能链接目录</li></ul> <ol><li><strong>符号链接</strong></li></ol> <p><strong>符号链接就是建立一个独立的文件，而这个文件会让数据的读取指向它链接的那个文件的文件名</strong>。由于只是利用文件来做为指向的操作，所以，<strong>当源文件被删除之后，符号链接的文件会【打不开了】</strong>，会一直说【无法打开某文件】，实际上就是找不到原始文件名而已。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1599803257348-b987e032-c604-4407-8e88-9cc5e4708714.png" alt="img"></p> <p>由 1 号 inode 读取到链接文件的内容仅有文件名，根据文件名链接到正确的目录去取得目标文件的 inode，最终就能够读取到正确的数据了。你可以发现的是，如果目标文件（/etc/crontab）被删除了，那么整个环节就会无法继续进行下去，所以就会发生无法通过链接文件读取的问题。</p> <p><strong>符号链接与 Windows 的快捷方式可以划上等号，由符号链接所建立的文件为一个独立的新的文件，所以会占用 inode 与区块</strong>。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#要制作链接文件就必须要使用 ln 这个命令</span>
<span class="token punctuation">[</span>root@study ~<span class="token punctuation">]</span><span class="token comment"># ln [-sf] 源文件 目标文件</span>
选项与参数：
-s：如果不加任何参数就进行链接，那就是硬链接，至于 -s 就是符号链接；
-f：如果目标文件存在时，就主动的将目标文件直接删除后再建立。
</code></pre></div><ol><li><strong>关于目录的链接数量</strong></li></ol> <p>当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：</p> <ul><li><p>/tmp/testing</p></li> <li><p>/tmp/testing/.</p></li> <li><p>/tmp/testing/..</p></li></ul> <p>而其中 /tmp/testing 与 /tmp/testing/. 其实是一样的。都代表该目录，而 /tmp/testing/.. 则代表 /tmp 这个目录，所以说，当我们建立一个新的目录时，<strong>新的目录的链接数为 2，而上层目录的链接数则会增加 1</strong>。</p> <h2 id="_7-3-磁盘的分区、格式化、检验与挂载"><a href="#_7-3-磁盘的分区、格式化、检验与挂载" class="header-anchor">#</a> 7.3 磁盘的分区、格式化、检验与挂载</h2> <p>如果想要在系统里新增一块磁盘时，应该有哪些操作需要做：</p> <ol><li><p>对磁盘进行划分，以建立可用的硬盘分区</p></li> <li><p>对该硬盘分区进行格式化，以建立系统可用的文件系统</p></li> <li><p>若想要仔细一点，则可对刚刚建立好的文件系统进行检验</p></li> <li><p>在 Linux 系统上，需要建立挂载点（亦即是目录），并将它挂载上来</p></li></ol> <h3 id="_7-3-1-观察磁盘分区状态"><a href="#_7-3-1-观察磁盘分区状态" class="header-anchor">#</a> 7.3.1 观察磁盘分区状态</h3> <ul><li><p>lsblk 列出系统上的所有磁盘列表</p></li> <li><p>blkid 列出设备的 UUID 等参数</p></li> <li><p>parted 列出磁盘的分区表类型与分区信息</p></li></ul> <h3 id="_7-3-2-磁盘分区-gdisk-fdisk"><a href="#_7-3-2-磁盘分区-gdisk-fdisk" class="header-anchor">#</a> 7.3.2 磁盘分区：gdisk/fdisk</h3> <ol><li><strong>gdisk</strong></li></ol> <p><strong>MBR 分区表使用 fdisk 分区，GPT 分区表使用 gdisk 分区</strong>。</p> <p>应该要通过 lsblk 或 blkid 先找到磁盘，再用 parted /dev/xxx print 来找出内部的分区表类型，之后才用 gdisk 或 fdisk 来操作系统。</p> <p>不管进行了什么操作，只要离开 gdisk 时按下【q】，那么所有的操作都不会生效，相反，按下【w】就是写入、操作生效的意思。</p> <p><strong>使用的设备文件名请不要加上数字，因为磁盘分区是针对整个磁盘设备而不是某个分区</strong>。</p> <ol><li><p><strong>用 gdisk 新增分区</strong></p></li> <li><p><strong>partprobe 更新 Linux 内核的分区表信息</strong></p></li> <li><p><strong>用 gdisk 删除一个分区</strong></p></li> <li><p><strong>fdisk</strong></p></li></ol> <h3 id="_7-3-3-磁盘格式化-创建文件系统"><a href="#_7-3-3-磁盘格式化-创建文件系统" class="header-anchor">#</a> 7.3.3 磁盘格式化（创建文件系统）</h3> <p>格式化的命令非常简单，那就是【make filesystem，mkfs】这个命令。这个命令其实是个综合命令，它会去调用正确的文件系统格式化工具软件。</p> <ol><li><strong>XFS 文件系统 mkfs.xfs</strong></li></ol> <p>我们常听到的格式化其实应该称为创建文件系统（make filesystem）才合适，所以使用的命令是 mkfs。那我们要创建的其实是 xfs 文件系统，因此使用的是 mkfs.xfs 这个命令才对。</p> <ol><li><p><strong>XFS 文件系统 for RAID 性能优化</strong></p></li> <li><p><strong>ext4 文件系统 mkfs.ext4</strong></p></li> <li><p><strong>其他文件系统 mkfs</strong></p></li></ol> <p>mkfs 其实是个综合命令而已，当我们使用 mkfs -t xfs 时，它就会跑去找 mkfs.xfs 相关的参数给我们使用。如果想要知道系统还支持哪种文件系统的格式化功能，直接按 [tab] 就很清楚了。</p> <h3 id="_7-3-4-文件系统检验"><a href="#_7-3-4-文件系统检验" class="header-anchor">#</a> 7.3.4 文件系统检验</h3> <ul><li>xfs_repair 处理 XFS 文件系统</li> <li>fsck.ext4 处理 ext4 文件系统</li></ul> <p>无论是 xfs_repair 或 fsck.ext4，这都是用来检查与修正文件系统错误的命令。注意：<strong>通常只有身为 root 且你的文件系统有问题的时候才能使用这个命令，否则在正常状况下使用此命令，可能会造成对系统的危害</strong>。通常使用这个命令的场合都是在系统出现极大的问题，导致你在 Linux 启动的时候得进入单人单机模式下进行维护的操作时，才必须使用此命令。</p> <p>另外，如果你怀疑刚刚格式化成功的磁盘有问题的时候，也可以使用 xfs_repair 与 fsck.ext4 来检查磁盘。此外，由于 xfs_repair 与 fsck.ext4 在扫描磁盘的时候，可能会造成部分文件系统的改变，所以执行xfs_repair 与 fsck.ext4 时，<strong>被检查的硬盘分区务必不可挂载到系统上，即需要在卸载的状态</strong>。</p> <h3 id="_7-3-5-文件系统挂载与卸载"><a href="#_7-3-5-文件系统挂载与卸载" class="header-anchor">#</a> 7.3.5 文件系统挂载与卸载</h3> <p>我们在本章一开始时的挂载点的意义当中提过挂载点是目录，而这个目录是进入磁盘分区（其实是文件系统）的入口。不过要进行挂载前，你最好先确定几件事：</p> <ul><li><p>单一文件系统不应该被重复挂载在不同的挂载点（目录）中；</p></li> <li><p>单一目录不应该重复挂载多个文件系统；</p></li> <li><p>要做为挂载点的目录，理论上应该都是空目录才行</p></li></ul> <p>如果要用来挂载的目录里面并不是空的，<strong>那么挂载了文件系统之后，原目录下的东西就会暂时地消失</strong>。</p> <p>挂载命令：mount</p> <p>卸载命令：umount</p> <h3 id="_7-3-6-磁盘-文件系统参数自定义"><a href="#_7-3-6-磁盘-文件系统参数自定义" class="header-anchor">#</a> 7.3.6 磁盘/文件系统参数自定义</h3> <ul><li>mknod</li> <li>xfs_admin 修改 XFS 文件系统的 UUID 与 Label name</li></ul> <h2 id="_7-4-设置启动挂载"><a href="#_7-4-设置启动挂载" class="header-anchor">#</a> 7.4 设置启动挂载</h2> <h3 id="_7-4-1-启动挂载-etc-fstab-及-etc-mtab"><a href="#_7-4-1-启动挂载-etc-fstab-及-etc-mtab" class="header-anchor">#</a> 7.4.1 启动挂载 /etc/fstab 及 /etc/mtab</h3> <ul><li><p>根目录 / 是必须挂载的，而且一定要先于其他挂载点被挂载起来</p></li> <li><p>其他挂载点必须为已建立的目录，可任意指定，但一定要遵守必须的系统目录架构原则</p></li> <li><p>所有挂载点在同一时间之内，只能挂载一次</p></li> <li><p>所有硬盘分区在同一时间之内，只能挂载一次</p></li> <li><p>如若进行卸载，必须先将工作目录移到挂载点（及其子目录）之外</p></li></ul> <h3 id="_7-4-2-特殊设备-loop-挂载"><a href="#_7-4-2-特殊设备-loop-挂载" class="header-anchor">#</a> 7.4.2 特殊设备 loop 挂载</h3> <h2 id="_7-5-内存交换分区-swap-创建"><a href="#_7-5-内存交换分区-swap-创建" class="header-anchor">#</a> 7.5 内存交换分区（swap）创建</h2> <h3 id="_7-5-1-使用物理分区创建内存交换分区"><a href="#_7-5-1-使用物理分区创建内存交换分区" class="header-anchor">#</a> 7.5.1 使用物理分区创建内存交换分区</h3> <p>建立内存交换分区的方式也是非常的简单，通过下面几个步骤就搞定：</p> <ol><li><p>分区：先使用 gdisk 在你的磁盘中划分出一个分区给系统作为交换分区，由于 Linux 的 gdisk 默认会将分区的 ID 设置为 Linux 的文件系统，所以你可能还得要设置一下 system ID</p></li> <li><p>格式化：利用建立内存交换分区格式的【mkswap 设备文件名】就能够格式化该分区成为内存交换分区格式</p></li> <li><p>使用：最后将该 swap 设备启动，方法为【swapon 设备文件名】</p></li> <li><p>观察：最终通过 free 与 swapon -s 这个命令来观察一下内存的使用量</p></li></ol> <h3 id="_7-5-2-使用文件创建内存交换文件"><a href="#_7-5-2-使用文件创建内存交换文件" class="header-anchor">#</a> 7.5.2 使用文件创建内存交换文件</h3> <h2 id="_7-6-文件系统的特殊观察与操作"><a href="#_7-6-文件系统的特殊观察与操作" class="header-anchor">#</a> 7.6 文件系统的特殊观察与操作</h2> <h1 id="_8-文件与文件系统的压缩"><a href="#_8-文件与文件系统的压缩" class="header-anchor">#</a> 8 文件与文件系统的压缩</h1> <hr> <h2 id="_8-1-压缩文件的用途与技术"><a href="#_8-1-压缩文件的用途与技术" class="header-anchor">#</a> 8.1 压缩文件的用途与技术</h2> <p>其实文件里面有相当多的空间存在，并不是完全填满的，而压缩的技术就是将这些空间填满，以让整个文件占用的容量下降。不过，这些压缩过的文件无法直接被我们的操作系统所使用，因此，若要使用这些被压缩过的文件数据，则必须将它还原回来未压缩前的模样，那就是所谓的解压缩。而至于压缩后与压缩的文件所占用的磁盘空间大小，就可以被称为是压缩比。</p> <h2 id="_8-2-linux-系统常见的压缩命令"><a href="#_8-2-linux-系统常见的压缩命令" class="header-anchor">#</a> 8.2 Linux 系统常见的压缩命令</h2> <p>在 Linux 的环境中，压缩文件的扩展名大多是：<em>.tar、</em>.tar.gz、<em>.tgz、</em>.gz、<em>.Z、</em>.bz2、*.xz。</p> <h3 id="_8-2-1-gzip-zcat-zmore-zless-zgrep"><a href="#_8-2-1-gzip-zcat-zmore-zless-zgrep" class="header-anchor">#</a> 8.2.1 gzip，zcat/zmore/zless/zgrep</h3> <p>gzip 可以说是应用最广的压缩命令了，目前 gzip 可以解开 compress、zip 与 gzip 等软件所压缩的文件。</p> <p>当使用 gzip 进行压缩时，在默认的状态下原本的文件会被压缩成为 .gz 后缀的文件，源文件就不再存在。</p> <p>cat/more/less 可以使用不同的方式来读取纯文本文件，那个 zcat/zmore/zless 则可以对应于 cat/more/less 的方式来读取纯文本文件被压缩后的压缩文件，由于 gzip 这个压缩命令主要想要用来替换 compress，所以不但 compress 的压缩文件可以使用 gzip 来解开，同时 zcat 这个命令可以同时读取 compress 与 gzip 的压缩文件。</p> <p>另外，如果你还想要从文字压缩文件当中找数据的话，可以通过 egrep 来查找关键词，而不需要将压缩文件解开才以 grep 进行，这对查询备份中的文本文件数据相当有用。</p> <h3 id="_8-2-2-bzip2-bzcat-bzmore-bzless-bzgrep"><a href="#_8-2-2-bzip2-bzcat-bzmore-bzless-bzgrep" class="header-anchor">#</a> 8.2.2 bzip2，bzcat/bzmore/bzless/bzgrep</h3> <p>若说 gzip 是为了替换 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了替换 gzip 并提供更佳的压缩比而来。</p> <h3 id="_8-2-3-xz-xzcat-xzmore-xzless-xzgrep"><a href="#_8-2-3-xz-xzcat-xzmore-xzless-xzgrep" class="header-anchor">#</a> 8.2.3 xz，xzcat/xzmore/xzless/xzgrep</h3> <p>虽然 bzip2 已经具有很棒的压缩比，不过显然某些自由软件开发者还不满足，因此后来还推出了 xz 这个压缩比更高的软件。</p> <h2 id="_8-3-打包命令-tar"><a href="#_8-3-打包命令-tar" class="header-anchor">#</a> 8.3 打包命令：tar</h2> <p>之前谈到的命令大多仅能针对单一文件来进行压缩，虽然 gzip、bzip2、xz 也能够针对目录来进行压缩，不过，这两个命令对目录的压缩指的是将目录内的所有文件【分别】进行压缩操作。</p> <h2 id="_8-4-xfs-文件系统的备份与还原"><a href="#_8-4-xfs-文件系统的备份与还原" class="header-anchor">#</a> 8.4 XFS 文件系统的备份与还原</h2> <ul><li>XFS 文件系统备份 xfsdump</li> <li>XFS 文件系统还原 xfsrestore</li></ul> <h2 id="_8-5-光盘写入工具"><a href="#_8-5-光盘写入工具" class="header-anchor">#</a> 8.5 光盘写入工具</h2> <ul><li>mkisofs：建立镜像文件</li> <li>cdrecord：光盘刻录工具</li></ul> <h2 id="_8-6-其他常见的压缩与备份工具"><a href="#_8-6-其他常见的压缩与备份工具" class="header-anchor">#</a> 8.6 其他常见的压缩与备份工具</h2> <ul><li>dd</li> <li>cpio</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./coding-base/linux/Linux大数据框架命令.html" class="prev">
        Linux大数据框架命令
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.dbe5dc78.js" defer></script><script src="./assets/js/2.fa5f1a4a.js" defer></script><script src="./assets/js/64.abb48239.js" defer></script>
  </body>
</html>
