<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>《Java核心技术》 | 大数据技术文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="./favicon.ico">
    <meta name="description" content="从入门到入土">
    
    <link rel="preload" href="./assets/css/0.styles.2c6e287f.css" as="style"><link rel="preload" href="./assets/js/app.9ce0d262.js" as="script"><link rel="preload" href="./assets/js/2.fa5f1a4a.js" as="script"><link rel="preload" href="./assets/js/71.c8bafdac.js" as="script"><link rel="prefetch" href="./assets/js/10.6940d239.js"><link rel="prefetch" href="./assets/js/100.22cf6913.js"><link rel="prefetch" href="./assets/js/101.8a31dcdc.js"><link rel="prefetch" href="./assets/js/102.147ef11e.js"><link rel="prefetch" href="./assets/js/103.cc281f62.js"><link rel="prefetch" href="./assets/js/104.2e0465e5.js"><link rel="prefetch" href="./assets/js/105.910aa23c.js"><link rel="prefetch" href="./assets/js/106.5466141f.js"><link rel="prefetch" href="./assets/js/107.a92bd18e.js"><link rel="prefetch" href="./assets/js/108.51fca30a.js"><link rel="prefetch" href="./assets/js/109.6119ffd0.js"><link rel="prefetch" href="./assets/js/11.bd53d768.js"><link rel="prefetch" href="./assets/js/110.eda784ab.js"><link rel="prefetch" href="./assets/js/111.12c174e7.js"><link rel="prefetch" href="./assets/js/112.8f45d1d2.js"><link rel="prefetch" href="./assets/js/113.e0bb8777.js"><link rel="prefetch" href="./assets/js/114.2ffc5abc.js"><link rel="prefetch" href="./assets/js/115.264d88bb.js"><link rel="prefetch" href="./assets/js/116.43a8b13e.js"><link rel="prefetch" href="./assets/js/117.03317ae7.js"><link rel="prefetch" href="./assets/js/118.dee53adb.js"><link rel="prefetch" href="./assets/js/119.662a11fb.js"><link rel="prefetch" href="./assets/js/12.b25bd03a.js"><link rel="prefetch" href="./assets/js/120.8d1c0658.js"><link rel="prefetch" href="./assets/js/121.c866d980.js"><link rel="prefetch" href="./assets/js/122.141777da.js"><link rel="prefetch" href="./assets/js/123.64bf1df0.js"><link rel="prefetch" href="./assets/js/124.0f402852.js"><link rel="prefetch" href="./assets/js/125.adf420b6.js"><link rel="prefetch" href="./assets/js/126.5ac52ff6.js"><link rel="prefetch" href="./assets/js/127.31a2c0b9.js"><link rel="prefetch" href="./assets/js/128.ee1158fc.js"><link rel="prefetch" href="./assets/js/129.ea47f41d.js"><link rel="prefetch" href="./assets/js/13.127a8756.js"><link rel="prefetch" href="./assets/js/130.169a1c91.js"><link rel="prefetch" href="./assets/js/131.25141855.js"><link rel="prefetch" href="./assets/js/132.1961433f.js"><link rel="prefetch" href="./assets/js/133.4a4b3148.js"><link rel="prefetch" href="./assets/js/134.3cf3137b.js"><link rel="prefetch" href="./assets/js/135.25c96955.js"><link rel="prefetch" href="./assets/js/136.34bc078a.js"><link rel="prefetch" href="./assets/js/137.0d68c97e.js"><link rel="prefetch" href="./assets/js/138.06820a54.js"><link rel="prefetch" href="./assets/js/139.25951593.js"><link rel="prefetch" href="./assets/js/14.ee4f6d75.js"><link rel="prefetch" href="./assets/js/140.9631a9a0.js"><link rel="prefetch" href="./assets/js/141.7e3c7d7b.js"><link rel="prefetch" href="./assets/js/142.fc0ba6d0.js"><link rel="prefetch" href="./assets/js/143.a87cd9f4.js"><link rel="prefetch" href="./assets/js/144.b8153695.js"><link rel="prefetch" href="./assets/js/145.5bb910bf.js"><link rel="prefetch" href="./assets/js/146.48346688.js"><link rel="prefetch" href="./assets/js/147.14fdd265.js"><link rel="prefetch" href="./assets/js/148.910c7bb0.js"><link rel="prefetch" href="./assets/js/149.17e89273.js"><link rel="prefetch" href="./assets/js/15.4c07895d.js"><link rel="prefetch" href="./assets/js/150.c09b3d84.js"><link rel="prefetch" href="./assets/js/151.1c6f270e.js"><link rel="prefetch" href="./assets/js/152.14fbeaa5.js"><link rel="prefetch" href="./assets/js/153.2452da0e.js"><link rel="prefetch" href="./assets/js/154.b4df1979.js"><link rel="prefetch" href="./assets/js/155.22d7abd8.js"><link rel="prefetch" href="./assets/js/156.2f9a9ccc.js"><link rel="prefetch" href="./assets/js/157.969faec2.js"><link rel="prefetch" href="./assets/js/158.3500ec52.js"><link rel="prefetch" href="./assets/js/159.e527d9a4.js"><link rel="prefetch" href="./assets/js/16.c4323435.js"><link rel="prefetch" href="./assets/js/160.e9019d68.js"><link rel="prefetch" href="./assets/js/161.85c34333.js"><link rel="prefetch" href="./assets/js/162.a46ae7b7.js"><link rel="prefetch" href="./assets/js/163.7be9bd8c.js"><link rel="prefetch" href="./assets/js/164.0c6811d8.js"><link rel="prefetch" href="./assets/js/165.57bd5bac.js"><link rel="prefetch" href="./assets/js/166.afa88f4a.js"><link rel="prefetch" href="./assets/js/167.29d4d5ce.js"><link rel="prefetch" href="./assets/js/168.e653cd83.js"><link rel="prefetch" href="./assets/js/169.e6f17762.js"><link rel="prefetch" href="./assets/js/17.505c5524.js"><link rel="prefetch" href="./assets/js/170.ef23a402.js"><link rel="prefetch" href="./assets/js/171.cad09bfd.js"><link rel="prefetch" href="./assets/js/172.70b28875.js"><link rel="prefetch" href="./assets/js/173.bd26a56b.js"><link rel="prefetch" href="./assets/js/174.eb342099.js"><link rel="prefetch" href="./assets/js/175.e65fe97d.js"><link rel="prefetch" href="./assets/js/176.991a568d.js"><link rel="prefetch" href="./assets/js/177.14728a0e.js"><link rel="prefetch" href="./assets/js/178.dd08b87f.js"><link rel="prefetch" href="./assets/js/179.35f52dd6.js"><link rel="prefetch" href="./assets/js/18.a3c1984e.js"><link rel="prefetch" href="./assets/js/180.fce6e839.js"><link rel="prefetch" href="./assets/js/181.344642d1.js"><link rel="prefetch" href="./assets/js/182.cb6d50af.js"><link rel="prefetch" href="./assets/js/183.18ccb5d5.js"><link rel="prefetch" href="./assets/js/184.7a48514f.js"><link rel="prefetch" href="./assets/js/19.e0fa9e47.js"><link rel="prefetch" href="./assets/js/20.da04fed8.js"><link rel="prefetch" href="./assets/js/21.039b78b5.js"><link rel="prefetch" href="./assets/js/22.91b1dd94.js"><link rel="prefetch" href="./assets/js/23.f70b01e1.js"><link rel="prefetch" href="./assets/js/24.bf935b15.js"><link rel="prefetch" href="./assets/js/25.740be3c8.js"><link rel="prefetch" href="./assets/js/26.f310e9df.js"><link rel="prefetch" href="./assets/js/27.0650d6da.js"><link rel="prefetch" href="./assets/js/28.30bd72ee.js"><link rel="prefetch" href="./assets/js/29.765dccf5.js"><link rel="prefetch" href="./assets/js/3.aa27e9f3.js"><link rel="prefetch" href="./assets/js/30.0484ae09.js"><link rel="prefetch" href="./assets/js/31.e09e1f25.js"><link rel="prefetch" href="./assets/js/32.9048892a.js"><link rel="prefetch" href="./assets/js/33.47a85736.js"><link rel="prefetch" href="./assets/js/34.162be571.js"><link rel="prefetch" href="./assets/js/35.27a56cfa.js"><link rel="prefetch" href="./assets/js/36.e2b24ea4.js"><link rel="prefetch" href="./assets/js/37.660e2ae2.js"><link rel="prefetch" href="./assets/js/38.e115bc82.js"><link rel="prefetch" href="./assets/js/39.786d0e1f.js"><link rel="prefetch" href="./assets/js/4.dac57b37.js"><link rel="prefetch" href="./assets/js/40.1034d892.js"><link rel="prefetch" href="./assets/js/41.2952b19a.js"><link rel="prefetch" href="./assets/js/42.75753f7b.js"><link rel="prefetch" href="./assets/js/43.af07ba27.js"><link rel="prefetch" href="./assets/js/44.c64a1c19.js"><link rel="prefetch" href="./assets/js/45.a3f07fbe.js"><link rel="prefetch" href="./assets/js/46.cde01b57.js"><link rel="prefetch" href="./assets/js/47.ca2de71c.js"><link rel="prefetch" href="./assets/js/48.264c1471.js"><link rel="prefetch" href="./assets/js/49.733bd546.js"><link rel="prefetch" href="./assets/js/5.6ca2ea8d.js"><link rel="prefetch" href="./assets/js/50.7b9d16c8.js"><link rel="prefetch" href="./assets/js/51.f427baa6.js"><link rel="prefetch" href="./assets/js/52.112ba3d3.js"><link rel="prefetch" href="./assets/js/53.bc7a9bfd.js"><link rel="prefetch" href="./assets/js/54.258fa5ae.js"><link rel="prefetch" href="./assets/js/55.00d67ca6.js"><link rel="prefetch" href="./assets/js/56.ea8c85f2.js"><link rel="prefetch" href="./assets/js/57.8263a106.js"><link rel="prefetch" href="./assets/js/58.e0b33df6.js"><link rel="prefetch" href="./assets/js/59.4d5f847f.js"><link rel="prefetch" href="./assets/js/6.a67b19a4.js"><link rel="prefetch" href="./assets/js/60.d3638a19.js"><link rel="prefetch" href="./assets/js/61.33bd82a8.js"><link rel="prefetch" href="./assets/js/62.6287fa56.js"><link rel="prefetch" href="./assets/js/63.f043aec3.js"><link rel="prefetch" href="./assets/js/64.fd61b3bb.js"><link rel="prefetch" href="./assets/js/65.088db422.js"><link rel="prefetch" href="./assets/js/66.fa850071.js"><link rel="prefetch" href="./assets/js/67.6f9263db.js"><link rel="prefetch" href="./assets/js/68.a40fea6a.js"><link rel="prefetch" href="./assets/js/69.82a38b9c.js"><link rel="prefetch" href="./assets/js/7.130b2290.js"><link rel="prefetch" href="./assets/js/70.78387c60.js"><link rel="prefetch" href="./assets/js/72.f6af738e.js"><link rel="prefetch" href="./assets/js/73.483631aa.js"><link rel="prefetch" href="./assets/js/74.7a295ce2.js"><link rel="prefetch" href="./assets/js/75.4ee52419.js"><link rel="prefetch" href="./assets/js/76.bfa2477e.js"><link rel="prefetch" href="./assets/js/77.36dbbf31.js"><link rel="prefetch" href="./assets/js/78.99a9055a.js"><link rel="prefetch" href="./assets/js/79.cf91068c.js"><link rel="prefetch" href="./assets/js/8.e81bc496.js"><link rel="prefetch" href="./assets/js/80.5091cf53.js"><link rel="prefetch" href="./assets/js/81.1ab1ac83.js"><link rel="prefetch" href="./assets/js/82.075a98b9.js"><link rel="prefetch" href="./assets/js/83.f6479725.js"><link rel="prefetch" href="./assets/js/84.36b72a58.js"><link rel="prefetch" href="./assets/js/85.5a115a90.js"><link rel="prefetch" href="./assets/js/86.e2e2bc5e.js"><link rel="prefetch" href="./assets/js/87.7498c4d7.js"><link rel="prefetch" href="./assets/js/88.424c69e2.js"><link rel="prefetch" href="./assets/js/89.5997766e.js"><link rel="prefetch" href="./assets/js/9.7d490254.js"><link rel="prefetch" href="./assets/js/90.ba4d2a78.js"><link rel="prefetch" href="./assets/js/91.920a9ee1.js"><link rel="prefetch" href="./assets/js/92.7903dbd3.js"><link rel="prefetch" href="./assets/js/93.e120bbac.js"><link rel="prefetch" href="./assets/js/94.cddc34d7.js"><link rel="prefetch" href="./assets/js/95.0a7a80fe.js"><link rel="prefetch" href="./assets/js/96.26590fe7.js"><link rel="prefetch" href="./assets/js/97.91bdc308.js"><link rel="prefetch" href="./assets/js/98.9a1146d2.js"><link rel="prefetch" href="./assets/js/99.d5e87370.js">
    <link rel="stylesheet" href="./assets/css/0.styles.2c6e287f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">大数据技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/sqoop/Sqoop入门.html" class="nav-link">
  Sqoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/presto/Presto入门.html" class="nav-link">
  Presto
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kylin/" class="nav-link">
  Kylin
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/Druid/Druid入门.html" class="nav-link">
  Druid
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/elasticsearch/ElasticSearch入门.html" class="nav-link">
  ElasticSearch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><span class="title">编程基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程基础" class="mobile-dropdown-title"><span class="title">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java基础语法/" class="nav-link">
  Java基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java基础实战
</a></li></ul></li><li class="dropdown-item"><h4>
          Java进阶(选学)
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/java并发编程/java并发编程.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/" class="nav-link router-link-active">
  Java网络编程
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java集合/Java集合（永盛）.html" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/./coding-base/java虚拟机/" class="nav-link">
  Java虚拟机
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机基础
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-subitem"><a href="/./coding-base/数据结构与算法/" class="nav-link">
  数据结构（重要）
</a></li><li class="dropdown-subitem"><a href="/./coding-base/计算机网络/计算机网络（双祥）.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/./coding-base/操作系统/" class="nav-link">
  操作系统
</a></li></ul></li><li class="dropdown-item"><h4>
          Python（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/Python/python基础/" class="nav-link">
  Python基础语法
</a></li><li class="dropdown-subitem"><a href="/./coding-base/Python/python库/" class="nav-link">
  Python数据科学库
</a></li></ul></li><li class="dropdown-item"><h4>
          框架（选学）
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/./coding-base/框架/sprin系列/" class="nav-link">
  Spring系列
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/flask/falsk.html" class="nav-link">
  Flask
</a></li><li class="dropdown-subitem"><a href="/./coding-base/框架/vue/flask.html" class="nav-link">
  Vue
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./database/mysql/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/./database/hbase/" class="nav-link">
  HBase
</a></li><li class="dropdown-item"><!----> <a href="/./database/tidb/" class="nav-link">
  TiDB
</a></li><li class="dropdown-item"><!----> <a href="/./database/clickhouse/" class="nav-link">
  ClickHouse
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据仓库" class="dropdown-title"><span class="title">数据仓库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据仓库" class="mobile-dropdown-title"><span class="title">数据仓库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./datahouse/sql/" class="nav-link">
  SQL
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/大数据基础/bigdata-base.html" class="nav-link">
  大数据基础
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/离线数仓/" class="nav-link">
  离线数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/实时数仓/" class="nav-link">
  实时数仓
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/商业化技术/" class="nav-link">
  商业化技术
</a></li><li class="dropdown-item"><!----> <a href="/./datahouse/电商业务/" class="nav-link">
  电商业务
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据框架及组件" class="dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据框架及组件" class="mobile-dropdown-title"><span class="title">大数据框架及组件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./bigdata/hadoop/" class="nav-link">
  Hadoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/hive/" class="nav-link">
  Hive
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/zookeeper/" class="nav-link">
  Zookeeper
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kafka/" class="nav-link">
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/spark/" class="nav-link">
  Spark
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/flink/" class="nav-link">
  Flink
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/sqoop/Sqoop入门.html" class="nav-link">
  Sqoop
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/presto/Presto入门.html" class="nav-link">
  Presto
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/kylin/" class="nav-link">
  Kylin
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/Druid/Druid入门.html" class="nav-link">
  Druid
</a></li><li class="dropdown-item"><!----> <a href="/./bigdata/elasticsearch/ElasticSearch入门.html" class="nav-link">
  ElasticSearch
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/./other/面经/" class="nav-link">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/./other/机器学习/" class="nav-link">
  机器学习
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>java基础语法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./coding-base/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/./coding-base/java基础语法/Java基础（永盛）.html" class="sidebar-link">Java基础</a></li><li><a href="/./coding-base/java基础语法/《Java核心技术 卷I》阅读笔记.html" class="sidebar-link">《Java核心技术 卷I》阅读笔记</a></li><li><a href="/./coding-base/java基础语法/《Java核心技术》.html" class="active sidebar-link">《Java核心技术》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-1-一个简单的java应用程序" class="sidebar-link">1.1 一个简单的Java应用程序</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-2-注释" class="sidebar-link">1.2 注释</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-3-数据类型" class="sidebar-link">1.3 数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-3-1-整型" class="sidebar-link">1.3.1 整型</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-3-2-浮点类型" class="sidebar-link">1.3.2 浮点类型</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-3-3-char类型" class="sidebar-link">1.3.3 char类型</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-3-4-boolean类型" class="sidebar-link">1.3.4 boolean类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-4-变量" class="sidebar-link">1.4 变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-4-1-变量初始化" class="sidebar-link">1.4.1 变量初始化</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-4-2-常量" class="sidebar-link">1.4.2 常量</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-运算符" class="sidebar-link">1.5 运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-1-数学函数与常量" class="sidebar-link">1.5.1 数学函数与常量</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-2-数值类型之间的转换" class="sidebar-link">1.5.2 数值类型之间的转换</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-3-结合赋值和运算符" class="sidebar-link">1.5.3 结合赋值和运算符</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-4-自增与自减运算符" class="sidebar-link">1.5.4 自增与自减运算符</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-5-关系和boolean运算符" class="sidebar-link">1.5.5 关系和boolean运算符</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-5-6-位运算符" class="sidebar-link">1.5.6 位运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-字符串" class="sidebar-link">1.6 字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-1-子串" class="sidebar-link">1.6.1 子串</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-2-拼接" class="sidebar-link">1.6.2 拼接</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-3-不可变字符串" class="sidebar-link">1.6.3 不可变字符串</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-4-检测字符串是否相等" class="sidebar-link">1.6.4 检测字符串是否相等</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-5-空串与null串" class="sidebar-link">1.6.5 空串与Null串</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-6-6-构建字符串" class="sidebar-link">1.6.6 构建字符串</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-7-输入输出" class="sidebar-link">1.7 输入输出</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-7-1-读取输入" class="sidebar-link">1.7.1 读取输入</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-7-2-格式化输出" class="sidebar-link">1.7.2 格式化输出</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-7-3-文件输入与输出" class="sidebar-link">1.7.3 文件输入与输出</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-控制流程" class="sidebar-link">1.8 控制流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-1-块作用域" class="sidebar-link">1.8.1 块作用域</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-2-条件语句" class="sidebar-link">1.8.2 条件语句</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-3-循环" class="sidebar-link">1.8.3 循环</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-4-确定循环" class="sidebar-link">1.8.4 确定循环</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-5-多重选择-switch-语句" class="sidebar-link">1.8.5 多重选择：switch 语句</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-8-6-中断控制流程语句" class="sidebar-link">1.8.6 中断控制流程语句</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-9-大数值" class="sidebar-link">1.9 大数值</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-数组" class="sidebar-link">1.10 数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-1-for-each-循环" class="sidebar-link">1.10.1 for each 循环</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-2-数组初始化以及匿名数组" class="sidebar-link">1.10.2 数组初始化以及匿名数组</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-3-数组拷贝" class="sidebar-link">1.10.3 数组拷贝</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-4-命令行参数" class="sidebar-link">1.10.4 命令行参数</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-5-数组排序" class="sidebar-link">1.10.5 数组排序</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-6-多维数组" class="sidebar-link">1.10.6 多维数组</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_1-10-7-不规则数组" class="sidebar-link">1.10.7 不规则数组</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-1-面向对象程序设计概述" class="sidebar-link">2.1 面向对象程序设计概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-1-1-类" class="sidebar-link">2.1.1 类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-1-2-对象" class="sidebar-link">2.1.2 对象</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-1-3-类之间的关系" class="sidebar-link">2.1.3 类之间的关系</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-2-使用预定义类" class="sidebar-link">2.2 使用预定义类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-2-1-对象与对象变量" class="sidebar-link">2.2.1 对象与对象变量</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-2-2-更改器方法与访问器方法" class="sidebar-link">2.2.2 更改器方法与访问器方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-3-用户自定义类" class="sidebar-link">2.3 用户自定义类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-3-1-构造器" class="sidebar-link">2.3.1 构造器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-3-2-隐式参数与显式参数" class="sidebar-link">2.3.2 隐式参数与显式参数</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-3-3-final-实例域" class="sidebar-link">2.3.3 final 实例域</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-静态域与静态方法" class="sidebar-link">2.4 静态域与静态方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-1-静态域" class="sidebar-link">2.4.1 静态域</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-2-静态常量" class="sidebar-link">2.4.2 静态常量</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-3-静态方法" class="sidebar-link">2.4.3 静态方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-4-工厂方法" class="sidebar-link">2.4.4 工厂方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-4-5-main-方法" class="sidebar-link">2.4.5 main 方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-5-方法参数" class="sidebar-link">2.5 方法参数</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-对象构造" class="sidebar-link">2.6 对象构造</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-1-重载" class="sidebar-link">2.6.1 重载</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-2-默认域初始化" class="sidebar-link">2.6.2 默认域初始化</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-3-无参数的构造器" class="sidebar-link">2.6.3 无参数的构造器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-4-显式域初始化" class="sidebar-link">2.6.4 显式域初始化</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-5-调用另一个构造器" class="sidebar-link">2.6.5 调用另一个构造器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-6-6-初始化块" class="sidebar-link">2.6.6 初始化块</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-7-包" class="sidebar-link">2.7 包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-7-1-类的导入" class="sidebar-link">2.7.1 类的导入</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-7-2-将类放入包中" class="sidebar-link">2.7.2 将类放入包中</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-7-3-包作用域" class="sidebar-link">2.7.3 包作用域</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-8-类路径" class="sidebar-link">2.8 类路径</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-9-文档注释" class="sidebar-link">2.9 文档注释</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_2-10-类设计技巧" class="sidebar-link">2.10 类设计技巧</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-类、父类和子类" class="sidebar-link">3.1 类、父类和子类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-1-定义子类" class="sidebar-link">3.1.1 定义子类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-2-重写方法" class="sidebar-link">3.1.2 重写方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-3-子类的构造器" class="sidebar-link">3.1.3 子类的构造器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-4-多态" class="sidebar-link">3.1.4 多态</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-5-理解方法调用" class="sidebar-link">3.1.5 理解方法调用</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-6-阻止继承-final-类和方法" class="sidebar-link">3.1.6 阻止继承：final 类和方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-7-强制类型转换" class="sidebar-link">3.1.7 强制类型转换</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-8-抽象类" class="sidebar-link">3.1.8 抽象类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-1-9-受保护访问" class="sidebar-link">3.1.9 受保护访问</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-2-object-所有类的父类" class="sidebar-link">3.2 Object：所有类的父类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-2-1-equals-方法" class="sidebar-link">3.2.1 equals 方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-2-2-hashcode-方法" class="sidebar-link">3.2.2 hashCode 方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-2-3-tostring-方法" class="sidebar-link">3.2.3 toString 方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-3-泛型数组列表" class="sidebar-link">3.3 泛型数组列表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-3-1-访问数组列表元素" class="sidebar-link">3.3.1 访问数组列表元素</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-3-2-类型化与原始数组列表的兼容性" class="sidebar-link">3.3.2 类型化与原始数组列表的兼容性</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-4-对象包装器与自动装箱" class="sidebar-link">3.4 对象包装器与自动装箱</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-5-枚举类" class="sidebar-link">3.5 枚举类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-反射" class="sidebar-link">3.6 反射</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-1-class-类" class="sidebar-link">3.6.1 Class 类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-2-捕获异常" class="sidebar-link">3.6.2 捕获异常</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-3-利用反射分析类的能力" class="sidebar-link">3.6.3 利用反射分析类的能力</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-4-在运行时使用反射分析对象" class="sidebar-link">3.6.4 在运行时使用反射分析对象</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-6-5-调用任意方法" class="sidebar-link">3.6.5 调用任意方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_3-7-继承的设计技巧" class="sidebar-link">3.7 继承的设计技巧</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-接口" class="sidebar-link">4.1 接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-1-接口概念" class="sidebar-link">4.1.1 接口概念</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-2-接口的特性" class="sidebar-link">4.1.2 接口的特性</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-3-接口与抽象类" class="sidebar-link">4.1.3 接口与抽象类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-4-静态方法" class="sidebar-link">4.1.4 静态方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-5-默认方法" class="sidebar-link">4.1.5 默认方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-1-6-解决默认方法冲突" class="sidebar-link">4.1.6 解决默认方法冲突</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-2-接口示例" class="sidebar-link">4.2 接口示例</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-2-1-接口与回调" class="sidebar-link">4.2.1 接口与回调</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-2-2-comparator-接口" class="sidebar-link">4.2.2 Comparator 接口</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-2-3-对象克隆" class="sidebar-link">4.2.3 对象克隆</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-lambda-表达式" class="sidebar-link">4.3 lambda 表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-1-为什么引用-lambda-表达式" class="sidebar-link">4.3.1 为什么引用 lambda 表达式</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-2-lambda-表达式的语法" class="sidebar-link">4.3.2 lambda 表达式的语法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-3-函数式接口" class="sidebar-link">4.3.3 函数式接口</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-4-方法引用" class="sidebar-link">4.3.4 方法引用</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-5-构造器引用" class="sidebar-link">4.3.5 构造器引用</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-6-变量作用域" class="sidebar-link">4.3.6 变量作用域</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-3-7-处理-lambda-表达式" class="sidebar-link">4.3.7 处理 lambda 表达式</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-内部类" class="sidebar-link">4.4 内部类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-1-使用内部类访问对象状态" class="sidebar-link">4.4.1 使用内部类访问对象状态</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-2-内部类的特殊语法规则" class="sidebar-link">4.4.2 内部类的特殊语法规则</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-3-内部类是否有用、必要和安全" class="sidebar-link">4.4.3 内部类是否有用、必要和安全</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-4-局部内部类" class="sidebar-link">4.4.4 局部内部类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-5-由外部方法访问变量" class="sidebar-link">4.4.5 由外部方法访问变量</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-6-匿名内部类" class="sidebar-link">4.4.6 匿名内部类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_4-4-7-静态内部类" class="sidebar-link">4.4.7 静态内部类</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-1-处理错误" class="sidebar-link">5.1 处理错误</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-1-1-异常分类" class="sidebar-link">5.1.1 异常分类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-1-2-声明检查异常" class="sidebar-link">5.1.2 声明检查异常</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-1-3-如何抛出异常" class="sidebar-link">5.1.3 如何抛出异常</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-1-4-创建异常类" class="sidebar-link">5.1.4 创建异常类</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-捕获异常" class="sidebar-link">5.2 捕获异常</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-1-捕获异常" class="sidebar-link">5.2.1 捕获异常</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-2-捕获多个异常" class="sidebar-link">5.2.2 捕获多个异常</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-3-再次抛出异常与异常链" class="sidebar-link">5.2.3 再次抛出异常与异常链</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-4-finally-子句" class="sidebar-link">5.2.4 finally 子句</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-2-5-分析堆栈轨迹元素" class="sidebar-link">5.2.5 分析堆栈轨迹元素</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-3-使用异常机制的技巧" class="sidebar-link">5.3 使用异常机制的技巧</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-4-使用断言" class="sidebar-link">5.4 使用断言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-4-1-断言的概念" class="sidebar-link">5.4.1 断言的概念</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-4-2-启用和禁用断言" class="sidebar-link">5.4.2 启用和禁用断言</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_5-5-记录日志" class="sidebar-link">5.5 记录日志</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-1-为什么要使用泛型程序设计" class="sidebar-link">6.1 为什么要使用泛型程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-1-1-类型参数的好处" class="sidebar-link">6.1.1 类型参数的好处</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-1-2-谁想成为泛型程序员" class="sidebar-link">6.1.2 谁想成为泛型程序员</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-2-定义简单泛型类" class="sidebar-link">6.2 定义简单泛型类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-3-泛型方法" class="sidebar-link">6.3 泛型方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-4-类型变量的限定" class="sidebar-link">6.4 类型变量的限定</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-5-泛型代码和虚拟机" class="sidebar-link">6.5 泛型代码和虚拟机</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-5-1-类型擦除" class="sidebar-link">6.5.1 类型擦除</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-5-2-翻译泛型表达式" class="sidebar-link">6.5.2 翻译泛型表达式</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-5-3-翻译泛型方法" class="sidebar-link">6.5.3 翻译泛型方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-5-4-调用遗留代码" class="sidebar-link">6.5.4 调用遗留代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-6-约束与局限性" class="sidebar-link">6.6 约束与局限性</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-7-泛型类型的继承规则" class="sidebar-link">6.7 泛型类型的继承规则</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-8-通配符类型" class="sidebar-link">6.8 通配符类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-8-1-通配符概念" class="sidebar-link">6.8.1 通配符概念</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-8-2-通配符的超类型限定" class="sidebar-link">6.8.2 通配符的超类型限定</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-8-3-无限定通配符" class="sidebar-link">6.8.3 无限定通配符</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-8-4-通配符捕获" class="sidebar-link">6.8.4 通配符捕获</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-9-反射和泛型" class="sidebar-link">6.9 反射和泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-9-1-泛型-class-类" class="sidebar-link">6.9.1 泛型 Class 类</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-9-2-使用-class-参数进行类型匹配" class="sidebar-link">6.9.2 使用 Class 参数进行类型匹配</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_6-9-3-虚拟机中的泛型类型信息" class="sidebar-link">6.9.3 虚拟机中的泛型类型信息</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-java-集合框架" class="sidebar-link">7.1 Java 集合框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-1-将集合的接口与实现分离" class="sidebar-link">7.1.1 将集合的接口与实现分离</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-2-collection-接口" class="sidebar-link">7.1.2 Collection 接口</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-3-迭代器" class="sidebar-link">7.1.3 迭代器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-4-泛型实用方法" class="sidebar-link">7.1.4 泛型实用方法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-1-5-集合框架中的接口" class="sidebar-link">7.1.5 集合框架中的接口</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-具体的集合" class="sidebar-link">7.2 具体的集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-1-链表" class="sidebar-link">7.2.1 链表</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-2-数组列表" class="sidebar-link">7.2.2 数组列表</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-3-散列集" class="sidebar-link">7.2.3 散列集</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-4-树集" class="sidebar-link">7.2.4 树集</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-5-队列与双端队列" class="sidebar-link">7.2.5 队列与双端队列</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-2-6-优先级队列" class="sidebar-link">7.2.6 优先级队列</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-映射" class="sidebar-link">7.3 映射</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-1-基本映射操作" class="sidebar-link">7.3.1 基本映射操作</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-2-更新映射项" class="sidebar-link">7.3.2 更新映射项</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-3-映射视图" class="sidebar-link">7.3.3 映射视图</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-4-弱散列映射" class="sidebar-link">7.3.4 弱散列映射</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-5-链接散列集与映射" class="sidebar-link">7.3.5 链接散列集与映射</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-6-枚举集与映射" class="sidebar-link">7.3.6 枚举集与映射</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-3-7-标识散列映射" class="sidebar-link">7.3.7 标识散列映射</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-视图与包装器" class="sidebar-link">7.4 视图与包装器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-1-轻量级集合包装器" class="sidebar-link">7.4.1 轻量级集合包装器</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-2-子范围" class="sidebar-link">7.4.2 子范围</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-3-不可修改的视图" class="sidebar-link">7.4.3 不可修改的视图</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-4-同步视图" class="sidebar-link">7.4.4 同步视图</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-4-5-受查视图" class="sidebar-link">7.4.5 受查视图</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-算法" class="sidebar-link">7.5 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-1-排序与混排" class="sidebar-link">7.5.1 排序与混排</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-2-二分查找" class="sidebar-link">7.5.2 二分查找</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-3-简单算法" class="sidebar-link">7.5.3 简单算法</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-4-批操作" class="sidebar-link">7.5.4 批操作</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-5-5-集合与数组的转换" class="sidebar-link">7.5.5 集合与数组的转换</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_7-6-遗留的集合" class="sidebar-link">7.6 遗留的集合</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-jar-文件" class="sidebar-link">8.1 JAR 文件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-1-创建-jar-文件" class="sidebar-link">8.1.1 创建 JAR 文件</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-2-清单文件" class="sidebar-link">8.1.2 清单文件</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-3-可执行-jar-文件" class="sidebar-link">8.1.3 可执行 JAR 文件</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-4-资源" class="sidebar-link">8.1.4 资源</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-1-5-密封" class="sidebar-link">8.1.5 密封</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-2-应用首选项的存储" class="sidebar-link">8.2 应用首选项的存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-2-1-属性映射" class="sidebar-link">8.2.1 属性映射</a></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-2-2-首选项-api" class="sidebar-link">8.2.2 首选项 API</a></li></ul></li><li class="sidebar-sub-header"><a href="/./coding-base/java基础语法/《Java核心技术》.html#_8-3-服务加载器" class="sidebar-link">8.3 服务加载器</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="《java核心技术》"><a href="#《java核心技术》" class="header-anchor">#</a> 《Java核心技术》</h1> <blockquote><p>原文链接：https://www.yuque.com/beimingyouyu-9woka/computer/po6psi</p></blockquote> <h1 id="_1-java的基本程序设计结构"><a href="#_1-java的基本程序设计结构" class="header-anchor">#</a> 1 Java的基本程序设计结构</h1> <hr> <h2 id="_1-1-一个简单的java应用程序"><a href="#_1-1-一个简单的java应用程序" class="header-anchor">#</a> 1.1 一个简单的Java应用程序</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstSample</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li><p>Java 区分大小写。</p></li> <li><p>关键字 <code>public</code> 称为访问修饰符，这些修饰符用于控制程序的其他部分对这段代码的访问级别。</p></li> <li><p>关键字 <code>class</code> 表明 Java 程序中的全部内容都包含在类中。这里，只需要将类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。Java 应用程序中的全部内容都必须放置在类中。</p></li> <li><p>关键字 <code>class</code> 后面紧跟类名。</p></li></ol> <p>4.1) 类名必须以字母开头，长度基本没有限制，但不能使用 Java 保留字作为类名。</p> <p>4.2) 标准的命名规范为：类名是以大写字母开头的名词，如果名字由多个单词组成，每个单词的第一个字母都应该大写。</p> <p>4.3) 源代码的文件名必须与公共类的名字相同。</p> <ol start="5"><li>每个Java程序都必须有一个 <code>main</code> 方法。</li></ol> <h2 id="_1-2-注释"><a href="#_1-2-注释" class="header-anchor">#</a> 1.2 注释</h2> <p>3种注释方式：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 第一种，其注释内容从//开始到本行结尾。</span>

<span class="token comment">/*
 第二种，适用于长篇注释。
 */</span>

<span class="token comment">/**
 * 第三种，可以用来自动地生成文档。
 */</span>
</code></pre></div><h2 id="_1-3-数据类型"><a href="#_1-3-数据类型" class="header-anchor">#</a> 1.3 数据类型</h2> <p>Java 是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在 Java 中，一共有 8 种基本类型，其中有 4 种整型、2 种浮点类型、1 种用于表示 Unicode 编码的字符单元的字符类型 char 和 1 种用于表示真值的 boolean 类型。</p> <h3 id="_1-3-1-整型"><a href="#_1-3-1-整型" class="header-anchor">#</a> 1.3.1 整型</h3> <p>整型用于表示没有小数部分的数值，它允许是负数。Java 提供了4种整型，见表。</p> <table><thead><tr><th>类型</th> <th>存储需求</th> <th>取值范围</th></tr></thead> <tbody><tr><td>byte</td> <td>1字节</td> <td>-128~127</td></tr> <tr><td>short</td> <td>2字节</td> <td>-32768~32767</td></tr> <tr><td>int</td> <td>4字节</td> <td>-2147483648~2147483647</td></tr> <tr><td>long</td> <td>8字节</td> <td>-9223372036854775808~9223372036854775807</td></tr></tbody></table> <p>十六进制数值有一个前缀 <code>0x</code> 或 <code>0X</code> 。</p> <p>八进制有一个前缀 <code>0</code>。</p> <p>从 Java7 开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数。</p> <h3 id="_1-3-2-浮点类型"><a href="#_1-3-2-浮点类型" class="header-anchor">#</a> 1.3.2 浮点类型</h3> <p>浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型，见表。</p> <table><thead><tr><th>类型</th> <th>存储需求</th> <th>取值范围</th></tr></thead> <tbody><tr><td>float</td> <td>4字节</td> <td>大约±3.40282347E+38F</td></tr> <tr><td>double</td> <td>8字节</td> <td>大约±1.79769313486231570E+308</td></tr></tbody></table> <h3 id="_1-3-3-char类型"><a href="#_1-3-3-char类型" class="header-anchor">#</a> 1.3.3 char类型</h3> <p><code>char</code> 类型的字面量值要用单引号括起来。</p> <h3 id="_1-3-4-boolean类型"><a href="#_1-3-4-boolean类型" class="header-anchor">#</a> 1.3.4 boolean类型</h3> <p><code>boolean</code> 类型有两个值：<code>true</code> 和 <code>false</code>，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。</p> <h2 id="_1-4-变量"><a href="#_1-4-变量" class="header-anchor">#</a> 1.4 变量</h2> <p>变量名必须是一个以字母开头并由字母或数字构成的序列。需要注意，与大多数程序设计语言相比，Java 中“字母”和“数字”的范围更大。字母包括 <code>'A'~'Z'</code>、<code>'a'~'z'</code>、<code>'_'</code>、<code>'$'</code>或在某种语言中表示字母的任何Unicode字符。变量名大小写敏感，长度基本没有限制。</p> <h3 id="_1-4-1-变量初始化"><a href="#_1-4-1-变量初始化" class="header-anchor">#</a> 1.4.1 变量初始化</h3> <p>声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span>
vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-4-2-常量"><a href="#_1-4-2-常量" class="header-anchor">#</a> 1.4.2 常量</h3> <p>在 Java 中，利用关键字 <code>final</code> 指示常量。关键字 <code>final</code> 表示这个变量只能被赋值一次，一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。</p> <h2 id="_1-5-运算符"><a href="#_1-5-运算符" class="header-anchor">#</a> 1.5 运算符</h2> <p>在 Java 中，使用算术运算符 <code>+</code> 、 <code>-</code> 、<code>*</code> 、 <code>/</code> 表示加、减、乘、除运算。当参与 <code>/</code> 运算的两个操作数都是整数时，表示整数除法；否则，表示浮点除法。整数的求余操作用 <code>%</code> 表示。</p> <h3 id="_1-5-1-数学函数与常量"><a href="#_1-5-1-数学函数与常量" class="header-anchor">#</a> 1.5.1 数学函数与常量</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//平方根</span>
<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//幂运算，x的a次幂</span>
</code></pre></div><h3 id="_1-5-2-数值类型之间的转换"><a href="#_1-5-2-数值类型之间的转换" class="header-anchor">#</a> 1.5.2 数值类型之间的转换</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1542472/1591275619367-4448e3be-fcf4-417a-a930-9ccccccf5ff5.jpeg" alt="img"></p> <p>实心箭头表示无信息丢失的转换，虚箭头表示可能有精度损失的转换。</p> <p>当两个类型不同的数值进行二元操作时，先要将两个操作数转换为同一种类型，然后再进行计算。</p> <h3 id="_1-5-3-结合赋值和运算符"><a href="#_1-5-3-结合赋值和运算符" class="header-anchor">#</a> 1.5.3 结合赋值和运算符</h3> <div class="language-java extra-class"><pre class="language-java"><code>x <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-5-4-自增与自减运算符"><a href="#_1-5-4-自增与自减运算符" class="header-anchor">#</a> 1.5.4 自增与自减运算符</h3> <div class="language-java extra-class"><pre class="language-java"><code>n<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//使用变量原来的值，再做加一操作</span>
<span class="token operator">++</span>n<span class="token punctuation">;</span> <span class="token comment">//先完成加一，再使用变量的值</span>
</code></pre></div><h3 id="_1-5-5-关系和boolean运算符"><a href="#_1-5-5-关系和boolean运算符" class="header-anchor">#</a> 1.5.5 关系和boolean运算符</h3> <p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 运算符。</p> <p><code>&amp;&amp;</code> 表示逻辑“与”运算符，<code>||</code> 表示逻辑“或”运算符，<code>!</code> 逻辑“非”运算符。</p> <p><code>&amp;&amp;</code> 和 <code>||</code> 运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p> <div class="language- extra-class"><pre class="language-text"><code>condition ? expression1 : expression2
</code></pre></div><h3 id="_1-5-6-位运算符"><a href="#_1-5-6-位运算符" class="header-anchor">#</a> 1.5.6 位运算符</h3> <p>处理整型类型时，可以直接对组成整型数值的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。</p> <p>位运算符包括：<code>&amp;（“and”）</code>、<code>|（“or”）</code>、<code>^（“xor”）</code>、<code>~（“not”）</code>。</p> <p>另外，还有 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 运算符将位模式左移或右移。</p> <p>最后，<code>&gt;&gt;&gt;</code> 运算符会用 0 填充高位，不存在 <code>&lt;&lt;&lt;</code> 运算符。</p> <h2 id="_1-6-字符串"><a href="#_1-6-字符串" class="header-anchor">#</a> 1.6 字符串</h2> <p>从概念上讲，Java 字符串就是 Unicode 字符序列。</p> <h3 id="_1-6-1-子串"><a href="#_1-6-1-子串" class="header-anchor">#</a> 1.6.1 子串</h3> <p><code>String</code> 类的 <code>substring</code> 方法可以从一个较大的字符串提取出一个子串。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> greeting<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从0开始计数，直到3为止，但不包含3。</span>
</code></pre></div><h3 id="_1-6-2-拼接"><a href="#_1-6-2-拼接" class="header-anchor">#</a> 1.6.2 拼接</h3> <p>与绝大多数的程序设计语言一样，Java 语言允许使用 <code>+</code> 号连接（拼接）两个字符串。</p> <p>将一个字符串与非字符串的值进行拼接时，后者被转换成字符串。</p> <p>如果需要把多个字符串放在一起，用一个定界符分隔，可以使用静态 <code>join</code> 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> all <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; / &quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;S&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;L&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;XL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-6-3-不可变字符串"><a href="#_1-6-3-不可变字符串" class="header-anchor">#</a> 1.6.3 不可变字符串</h3> <p>由于不能修改 Java 字符串中的字符，所以在 Java 文档中将 <code>String</code> 类对象称为不可变字符串。</p> <p>不可变字符串的优点：编译器可以让字符串共享。</p> <h3 id="_1-6-4-检测字符串是否相等"><a href="#_1-6-4-检测字符串是否相等" class="header-anchor">#</a> 1.6.4 检测字符串是否相等</h3> <div class="language-java extra-class"><pre class="language-java"><code>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测两个字符串是否相等</span>
<span class="token string">&quot;Hello&quot;</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不区分大小写</span>
</code></pre></div><p>不能使用 <code>==</code> 运算符检测两个字符串是否相等！这个运算符只能确定两个字符串是否放置在同一个位置上。</p> <p>== 和 equals() 的区别：</p> <ol><li><p>== 是运算符，equals() 是方法</p></li> <li><p>== 是直接比较的两个对象的堆内存地址，如果相等，则说明这两个引用实际是指向同一个对象地址的；equals 可以重写，比较两个对象的内容</p></li> <li><p>对于基本数据类型来说，他们是作为常量在方法区中的常量池里面以 HashSet 策略存起来的，对于字符串常量 &quot;123&quot;、&quot;Hello&quot; 也是相同的道理，在常量池中，一个常量只会对应一个地址，所有他们的引用都是指向的同一个地址，因此基本数据类型和 String 常量是可以直接通过 == 来判断是否相等</p></li> <li><p>对于基本数据的包装类型，除了 Float 和 Double 外，其他的六种都实现了常量池，因此我们也可以直接通过 == 来判断是否相等</p></li></ol> <h3 id="_1-6-5-空串与null串"><a href="#_1-6-5-空串与null串" class="header-anchor">#</a> 1.6.5 空串与Null串</h3> <p>空串 <code>&quot;&quot;</code> 是长度为0的字符串。<code>Null</code> 表示目前没有任何对象与该变量关联。</p> <h3 id="_1-6-6-构建字符串"><a href="#_1-6-6-构建字符串" class="header-anchor">#</a> 1.6.6 构建字符串</h3> <p>有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串，都会构建一个新的 <code>String</code> 对象，既耗时，又浪费空间。使用 <code>StringBuilder</code> 类就可以避免这个问题的发生。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> completedString <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在 JDK5.0 中引入 <code>StringBuilder</code> 类，这个类的前身是 <code>StringBuffer</code> ，其效率稍微有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑，则应该用 <code>StringBuilder</code> 替代它。</p> <h2 id="_1-7-输入输出"><a href="#_1-7-输入输出" class="header-anchor">#</a> 1.7 输入输出</h2> <h3 id="_1-7-1-读取输入"><a href="#_1-7-1-读取输入" class="header-anchor">#</a> 1.7.1 读取输入</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> name <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取一行</span>
<span class="token class-name">String</span> firstName <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取一个单词，以空白符作为分隔符</span>
<span class="token keyword">int</span> age <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取一个整数</span>
</code></pre></div><h3 id="_1-7-2-格式化输出"><a href="#_1-7-2-格式化输出" class="header-anchor">#</a> 1.7.2 格式化输出</h3> <h3 id="_1-7-3-文件输入与输出"><a href="#_1-7-3-文件输入与输出" class="header-anchor">#</a> 1.7.3 文件输入与输出</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;myfile.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取文件</span>
<span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token string">&quot;myfile.txt&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//写入文件</span>
</code></pre></div><h2 id="_1-8-控制流程"><a href="#_1-8-控制流程" class="header-anchor">#</a> 1.8 控制流程</h2> <p>与任何程序设计语言一样，Java 使用条件语句和循环结构确定控制流程。</p> <h3 id="_1-8-1-块作用域"><a href="#_1-8-1-块作用域" class="header-anchor">#</a> 1.8.1 块作用域</h3> <p>块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句。块确定了变量的作用域。一个块可以嵌套在另一个块中。但是不能在嵌套的两个块中声明同名的变量。</p> <h3 id="_1-8-2-条件语句"><a href="#_1-8-2-条件语句" class="header-anchor">#</a> 1.8.2 条件语句</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-8-3-循环"><a href="#_1-8-3-循环" class="header-anchor">#</a> 1.8.3 循环</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">do</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-8-4-确定循环"><a href="#_1-8-4-确定循环" class="header-anchor">#</a> 1.8.4 确定循环</h3> <p><code>for</code> 循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或类似的变量来控制迭代次数。</p> <p><code>for</code> 语句的第一部分通常用于对计数器初始化；第二部分给出每次新一轮循环执行前要检测的循环条件；第三部分指示如何更新计数器。</p> <ol><li><p>当 <code>for</code> 语句的第一部分中声明了一个变量之后，这个变量的作用域就为 <code>for</code> 循环的整个循环体。</p></li> <li><p>如果在 <code>for</code> 语句内部定义一个变量，这个变量就不能在循环体之外使用。因此，如果希望在 <code>for</code> 循环体之外使用循环计数器的最终值，就要确保这个变量在循环语句的前面且在外部声明！</p></li> <li><p>可以在各自独立的不同 <code>for</code> 循环中定义同名的变量。</p></li></ol> <h3 id="_1-8-5-多重选择-switch-语句"><a href="#_1-8-5-多重选择-switch-语句" class="header-anchor">#</a> 1.8.5 多重选择：switch 语句</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>choice<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>        
<span class="token punctuation">}</span>
</code></pre></div><p><code>switch</code> 语句将从与选项值相匹配的 <code>case</code> 标签处开始执行直到遇到 <code>break</code> 语句，或者执行到 <code>switch</code> 语句的结束处为止。如果没有相匹配的 <code>case</code> 标签，而有 <code>default</code> 子句，就执行这个子句。</p> <p><code>case</code> 标签可以是：</p> <p>类型为 <code>char</code>、<code>byte</code>、<code>short</code> 或 <code>int</code> 的常量表达式。</p> <ul><li>枚举常量。</li> <li>从 Java SE 7 开始，<code>case</code> 标签还可以是字符串字面量。</li></ul> <h3 id="_1-8-6-中断控制流程语句"><a href="#_1-8-6-中断控制流程语句" class="header-anchor">#</a> 1.8.6 中断控制流程语句</h3> <p><code>break</code> 退出循环语句。</p> <p><code>continue</code> 将控制转移到最内层循环的首部。</p> <h2 id="_1-9-大数值"><a href="#_1-9-大数值" class="header-anchor">#</a> 1.9 大数值</h2> <p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用 <code>java.math</code> 包中的两个很有用的类：<code>BigInteger</code> 和 <code>BigDecimal</code>。这两个类可以处理包含任意长度数字序列的数值。<code>BigInteger</code> 实现了任意精度的整数运算，<code>BigDecimal</code> 实现了任意精度的浮点数运算。</p> <p>使用静态的 <code>valueOf</code> 方法可以将普通的数值转换为大数值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token class-name">BigInteger</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不能使用算术运算符（如：<code>+</code> 和 <code>*</code>）处理大数值。而需要使用大数值类中的 <code>add</code> 和 <code>multiply</code> 方法。</p> <h2 id="_1-10-数组"><a href="#_1-10-数组" class="header-anchor">#</a> 1.10 数组</h2> <p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p> <p>在声明数组变量时，需要指出数组类型和数组变量的名字。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span> <span class="token comment">//声明数组</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//声明数组并初始化</span>
</code></pre></div><p>创建一个数字数组时，所有元素都初始化为 0。<code>boolean</code> 数组的元素会初始化为 <code>false</code>。对象数组的元素则初始化为 <code>null</code>。</p> <p>一旦创建了数组，就不能再改变它的大小。</p> <h3 id="_1-10-1-for-each-循环"><a href="#_1-10-1-for-each-循环" class="header-anchor">#</a> 1.10.1 for each 循环</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>variable <span class="token operator">:</span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有个更加简单的方式打印数组中的所有值，即利用 <code>Arrays</code> 类的 <code>toString</code> 方法。调用 <code>Arrays.toString(a)</code>，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔，例如，<code>&quot;[2, 3, 5, 7, 11, 13]&quot;</code>。</p> <h3 id="_1-10-2-数组初始化以及匿名数组"><a href="#_1-10-2-数组初始化以及匿名数组" class="header-anchor">#</a> 1.10.2 数组初始化以及匿名数组</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> smallPrimes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//创建数组并初始化</span>
smallPrimes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//初始化一个匿名数组</span>
</code></pre></div><p>在 Java 中，允许数组长度为 <code>0</code>。在编写一个结果为数组的方法时，如果碰巧结果为空，此时可以创建一个长度为 <code>0</code> 的数组：</p> <div class="language- extra-class"><pre class="language-text"><code>new elementType[0]
</code></pre></div><p>注意，数组长度为 <code>0</code> 与 <code>null</code> 不同。</p> <h3 id="_1-10-3-数组拷贝"><a href="#_1-10-3-数组拷贝" class="header-anchor">#</a> 1.10.3 数组拷贝</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> luckyNumbers <span class="token operator">=</span> smallPrimes<span class="token punctuation">;</span> <span class="token comment">//两个变量引用同一个数组</span>
<span class="token comment">// 将一个数组的所有值拷贝到新数组中</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copiedLuckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 增加数组的大小</span>
luckyNumbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>luckyNumbers<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> luckyNumbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_1-10-4-命令行参数"><a href="#_1-10-4-命令行参数" class="header-anchor">#</a> 1.10.4 命令行参数</h3> <p>举例：</p> <div class="language- extra-class"><pre class="language-text"><code>java Message -g cruel world arg[0] : &quot;-g&quot; arg[1] : &quot;cruel&quot; arg[2] : &quot;world&quot;
</code></pre></div><h3 id="_1-10-5-数组排序"><a href="#_1-10-5-数组排序" class="header-anchor">#</a> 1.10.5 数组排序</h3> <p>要想对数值型数组进行排序，可以使用 <code>Arrays</code> 类中的 <code>sort</code> 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个方法使用了优化的快速排序算法。</p> <h3 id="_1-10-6-多维数组"><a href="#_1-10-6-多维数组" class="header-anchor">#</a> 1.10.6 多维数组</h3> <h3 id="_1-10-7-不规则数组"><a href="#_1-10-7-不规则数组" class="header-anchor">#</a> 1.10.7 不规则数组</h3> <h1 id="_2-对象与类"><a href="#_2-对象与类" class="header-anchor">#</a> 2 对象与类</h1> <hr> <h2 id="_2-1-面向对象程序设计概述"><a href="#_2-1-面向对象程序设计概述" class="header-anchor">#</a> 2.1 面向对象程序设计概述</h2> <p>面向对象程序设计（简称 OOP ）是当今主流的程序设计范型，面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。</p> <p>面向过程程序设计首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而 OOP 却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。</p> <h3 id="_2-1-1-类"><a href="#_2-1-1-类" class="header-anchor">#</a> 2.1.1 类</h3> <p>类（class）是构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例（instance）。</p> <p>封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。</p> <p>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。</p> <p>OOP的另一个原则就是可以通过扩展一个类来建立另外一个新的类。事实上，在 Java 中，所有的类都源自于一个父类 Object。</p> <p>在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为继承（inheritance）。</p> <h3 id="_2-1-2-对象"><a href="#_2-1-2-对象" class="header-anchor">#</a> 2.1.2 对象</h3> <p>对象的三个主要特性：</p> <ul><li><p>对象的行为</p></li> <li><p>对象的状态</p></li> <li><p>对象标识</p></li></ul> <p>每个对象都保存着描述当前特征的信息，这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的，必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）。</p> <h3 id="_2-1-3-类之间的关系"><a href="#_2-1-3-类之间的关系" class="header-anchor">#</a> 2.1.3 类之间的关系</h3> <p>在类之间，最常见的关系有：</p> <ul><li><p>依赖：一个类的方法操纵另一个类的对象</p></li> <li><p>聚合：一个类的对象包含另一个类的对象</p></li> <li><p>继承：一个类继承另一个类</p></li></ul> <h2 id="_2-2-使用预定义类"><a href="#_2-2-使用预定义类" class="header-anchor">#</a> 2.2 使用预定义类</h2> <h3 id="_2-2-1-对象与对象变量"><a href="#_2-2-1-对象与对象变量" class="header-anchor">#</a> 2.2.1 对象与对象变量</h3> <p>要想使用对象，就必须首先构造对象，并指定其初始状态。然后，对对象应用方法。</p> <p>在 Java 中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。</p> <p>构造器的名字应该与类名相同，要想构造一个对象，需要在构造器前面加上 <code>new</code> 操作符。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对象</span>
<span class="token class-name">Date</span> deadline<span class="token punctuation">;</span> <span class="token comment">//对象变量</span>
</code></pre></div><p>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在 Java 中，任何对象变量的值都是对存储在另外一个地方额一个对象的引用，<code>new</code> 操作符的返回值也是一个引用。</p> <p>局部变量不会自动地初始化为 <code>null</code>，而必须通过调用 <code>new</code> 或将它们设置为 <code>null</code> 进行初始化。</p> <h3 id="_2-2-2-更改器方法与访问器方法"><a href="#_2-2-2-更改器方法与访问器方法" class="header-anchor">#</a> 2.2.2 更改器方法与访问器方法</h3> <h2 id="_2-3-用户自定义类"><a href="#_2-3-用户自定义类" class="header-anchor">#</a> 2.3 用户自定义类</h2> <p>在一个源文件中，文件名必须与 <code>public</code> 类的名字相匹配，只能有一个公有类，但可以有任意数目的非公有类。</p> <p>关键字 <code>public</code> 意味着任何类的任何方法都可以调用这些方法。关键字 <code>private</code> 确保只有类自身的方法能够访问这些实例域，而其他的类的方法不能够读写这些域。</p> <h3 id="_2-3-1-构造器"><a href="#_2-3-1-构造器" class="header-anchor">#</a> 2.3.1 构造器</h3> <p>构造器总是伴随着 <code>new</code> 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。</p> <ul><li><p>构造器与类同名</p></li> <li><p>每个类可以有一个以上的构造器</p></li> <li><p>构造器可以有 0 个、1 个或多个参数</p></li> <li><p>构造器没有返回值</p></li> <li><p>构造器总是伴随着 <code>new</code> 操作一起调用</p></li></ul> <p>注意：不要在构造器中定义与实例域重名的局部变量。</p> <h3 id="_2-3-2-隐式参数与显式参数"><a href="#_2-3-2-隐式参数与显式参数" class="header-anchor">#</a> 2.3.2 隐式参数与显式参数</h3> <p>方法用于操作对象以及存取它们的实例域。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span> byPercent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">double</span> raise <span class="token operator">=</span> salary <span class="token operator">*</span> byPercent <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
    salary <span class="token operator">+=</span> raise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

number007<span class="token punctuation">.</span><span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述方法的调用将执行下列命令：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">double</span> raise <span class="token operator">=</span> number007<span class="token punctuation">.</span>salary <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
number007<span class="token punctuation">.</span>salary <span class="token operator">+=</span> raise<span class="token punctuation">;</span>
</code></pre></div><p><code>raiseSalary</code> 方法有两个参数。第一个参数称为隐式参数，是出现在方法名前的对象。第二个参数位于方法名后面括号中的数值，这是一个显式参数。</p> <p>关键词 <code>this</code> 表示隐式参数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token keyword">double</span> byPercent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">double</span> raise <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">*</span> byPercent <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>salary <span class="token operator">+=</span> raise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-3-3-final-实例域"><a href="#_2-3-3-final-实例域" class="header-anchor">#</a> 2.3.3 final 实例域</h3> <p>可以将实例域定义为 <code>final</code>。构建对象时必须初始化这样的域。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。</p> <h2 id="_2-4-静态域与静态方法"><a href="#_2-4-静态域与静态方法" class="header-anchor">#</a> 2.4 静态域与静态方法</h2> <h3 id="_2-4-1-静态域"><a href="#_2-4-1-静态域" class="header-anchor">#</a> 2.4.1 静态域</h3> <p>如果将域定义为 <code>static</code>，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</p> <p>即使没有对象，静态域也存在，它属于类，而不属于任何独立的对象。</p> <h3 id="_2-4-2-静态常量"><a href="#_2-4-2-静态常量" class="header-anchor">#</a> 2.4.2 静态常量</h3> <h3 id="_2-4-3-静态方法"><a href="#_2-4-3-静态方法" class="header-anchor">#</a> 2.4.3 静态方法</h3> <p>静态方法是一种不能向对象实施操作的方法，可以认为，静态方法是没有隐式参数（<code>this</code>）的方法。</p> <p>在下面两种情况下使用静态方法：</p> <ul><li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供</li> <li>一个方法只需要访问类的静态域</li></ul> <h3 id="_2-4-4-工厂方法"><a href="#_2-4-4-工厂方法" class="header-anchor">#</a> 2.4.4 工厂方法</h3> <h3 id="_2-4-5-main-方法"><a href="#_2-4-5-main-方法" class="header-anchor">#</a> 2.4.5 main 方法</h3> <p><code>main</code> 方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 <code>main</code> 方法将执行并创建程序所需要的对象。</p> <h2 id="_2-5-方法参数"><a href="#_2-5-方法参数" class="header-anchor">#</a> 2.5 方法参数</h2> <p>按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。</p> <p>Java 程序设计语言总是按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。</p> <ul><li><p>一个方法不能修改一个基本数据类型的参数。</p></li> <li><p>一个方法可以改变一个对象参数的状态。</p></li> <li><p>一个方法不能让对象参数引用一个新的对象。</p></li></ul> <h2 id="_2-6-对象构造"><a href="#_2-6-对象构造" class="header-anchor">#</a> 2.6 对象构造</h2> <h3 id="_2-6-1-重载"><a href="#_2-6-1-重载" class="header-anchor">#</a> 2.6.1 重载</h3> <p>如果多个方法有相同的名字、不同的参数，便产生了重载。</p> <p>重载解析：编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出具体执行哪个方法。如果编译器找不到匹配的参数，就会产生编译时错误。</p> <p>Java 允许重载任何方法，而不只是构造器方法。因此要完整的描述一个方法，需要指出方法名以及参数类型，这叫做方法的签名。返回类型不是方法签名的一部分，也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p> <h3 id="_2-6-2-默认域初始化"><a href="#_2-6-2-默认域初始化" class="header-anchor">#</a> 2.6.2 默认域初始化</h3> <p>如果在构造器中没有显式地给域赋予初值，那么就会被自动的赋为默认值：数值为 <code>0</code>、布尔型为 <code>false</code>、对象引用为 <code>null</code>。</p> <p>这是域与局部变量的主要不同点。必须明确的初始化方法中的局部变量。但是，如果没有初始化类中的域，将会被自动初始化为默认值。</p> <h3 id="_2-6-3-无参数的构造器"><a href="#_2-6-3-无参数的构造器" class="header-anchor">#</a> 2.6.3 无参数的构造器</h3> <p>如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。</p> <p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p> <h3 id="_2-6-4-显式域初始化"><a href="#_2-6-4-显式域初始化" class="header-anchor">#</a> 2.6.4 显式域初始化</h3> <p>在执行构造器之前，先执行赋值操作。</p> <h3 id="_2-6-5-调用另一个构造器"><a href="#_2-6-5-调用另一个构造器" class="header-anchor">#</a> 2.6.5 调用另一个构造器</h3> <p>如果构造器的第一个语句形如 <code>this(...)</code>，这个构造器将调用同一个类的另一个构造器。</p> <h3 id="_2-6-6-初始化块"><a href="#_2-6-6-初始化块" class="header-anchor">#</a> 2.6.6 初始化块</h3> <p>初始化数据域的方法：</p> <ul><li><p>在构造器中设置值</p></li> <li><p>在声明中赋值</p></li> <li><p>初始化块</p></li></ul> <p>调用构造器的具体处理步骤：</p> <ul><li><p>所有数据域被初始化为默认值（<code>0</code>、<code>false</code> 或 <code>null</code>）</p></li> <li><p>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</p></li> <li><p>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</p></li> <li><p>执行这个构造器的主体</p></li></ul> <p>初始化块要比构造器先执行。</p> <h2 id="_2-7-包"><a href="#_2-7-包" class="header-anchor">#</a> 2.7 包</h2> <p>Java 允许使用包（package）将类组织起来，使用包的主要原因是确保类名的唯一性。</p> <h3 id="_2-7-1-类的导入"><a href="#_2-7-1-类的导入" class="header-anchor">#</a> 2.7.1 类的导入</h3> <p>一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 访问另一个包中的公有类</span>

<span class="token comment">// 方式一</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span> today <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 方式二</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> today <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 方式三</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalDate</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 如果两个包中有同名的类，并且在代码中都使用</span>

<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span> deadline <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span> today <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span>Date</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_2-7-2-将类放入包中"><a href="#_2-7-2-将类放入包中" class="header-anchor">#</a> 2.7.2 将类放入包中</h3> <p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>horstmann<span class="token punctuation">.</span>corejava</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包。</p> <div class="language- extra-class"><pre class="language-text"><code>javac com/mycompany/PayrollApp.java
java com.mycompany.PayrollApp
</code></pre></div><h3 id="_2-7-3-包作用域"><a href="#_2-7-3-包作用域" class="header-anchor">#</a> 2.7.3 包作用域</h3> <p>标记为 <code>public</code> 的部分可以被任意的类使用</p> <p>标记为 <code>private</code> 的部分只能被定义它们的类使用</p> <p>如果没有指定 <code>public</code> 或 <code>private</code> ，这个部分（类、方法或变量）可以被同一个包中的所有方法访问</p> <h2 id="_2-8-类路径"><a href="#_2-8-类路径" class="header-anchor">#</a> 2.8 类路径</h2> <h2 id="_2-9-文档注释"><a href="#_2-9-文档注释" class="header-anchor">#</a> 2.9 文档注释</h2> <h2 id="_2-10-类设计技巧"><a href="#_2-10-类设计技巧" class="header-anchor">#</a> 2.10 类设计技巧</h2> <ol><li><p>一定要保证数据私有</p></li> <li><p>一定要对数据初始化</p></li> <li><p>不要在类中使用过多的基本类型</p></li> <li><p>不是所有的域都需要独立的域访问器和域更改器</p></li> <li><p>将职责过多的类进行分解</p></li> <li><p>类名和方法名要能够体现它们的职责</p></li> <li><p>优先使用不可变的类</p></li></ol> <h1 id="_3-继承"><a href="#_3-继承" class="header-anchor">#</a> 3 继承</h1> <hr> <h2 id="_3-1-类、父类和子类"><a href="#_3-1-类、父类和子类" class="header-anchor">#</a> 3.1 类、父类和子类</h2> <h3 id="_3-1-1-定义子类"><a href="#_3-1-1-定义子类" class="header-anchor">#</a> 3.1.1 定义子类</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关键字 <code>extends</code> 表明正在构造的新类派生于一个已存在的类。已存在的类称为父类（parent class），新类称为子类（subclass）。</p> <p>子类继承父类后，自动的继承父类的域和方法，在设计类的时候，应该将通用的方法放在父类中，而将具有特殊用途的方法放在子类中。</p> <p>子类继承父类的私有域和私有方法，但没有访问权限。</p> <h3 id="_3-1-2-重写方法"><a href="#_3-1-2-重写方法" class="header-anchor">#</a> 3.1.2 重写方法</h3> <p>父类中的有些方法对子类并不一定适用，为此，需要提供一个新的方法来重写（override）父类的方法。</p> <p>注意：子类不能直接访问父类的私有域。在子类中可以增加域、增加方法或重写父类的方法，然而绝对不能删除继承的任何域和方法。</p> <h3 id="_3-1-3-子类的构造器"><a href="#_3-1-3-子类的构造器" class="header-anchor">#</a> 3.1.3 子类的构造器</h3> <p>子类可以通过 <code>super</code> 实现对父类构造器的调用，使用 <code>super</code> 调用构造器的语句必须是子类构造器的第一条语句。</p> <p>如果子类的构造器没有显式地调用父类的构造器，则将自动地调用父类默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类中的构造器中又没有显式地调用父类的其他构造器，则 Java 编译器将报告错误。</p> <h3 id="_3-1-4-多态"><a href="#_3-1-4-多态" class="header-anchor">#</a> 3.1.4 多态</h3> <p>有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是父类的对象。</p> <p>“is-a”规则的另一种表述法是置换法则。它表明程序中出现父类对象的任何地方都可以用子类对象置换。</p> <p>一个对象变量可以指示多种实际类型的现象称为多态。在 Java 程序设计语言中，对象变量是多态的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span> staff <span class="token operator">=</span> boss<span class="token punctuation">;</span>
</code></pre></div><p>在这个例子中，变量 <code>staff</code> 和 <code>boss</code> 引用同一个对象，但编译器将 <code>staff</code> 看成 <code>Employee</code> 对象。这意味着，可以这样调用：</p> <div class="language- extra-class"><pre class="language-text"><code>boss.setBonus(5000);
</code></pre></div><p>但不能这样调用：</p> <div class="language- extra-class"><pre class="language-text"><code>staff.setBonus(5000);
</code></pre></div><p>这是因为 <code>staff</code>声明的类型是 <code>Employee</code>，而 <code>setBonus</code> 不是 <code>Employee</code> 类的方法。</p> <h3 id="_3-1-5-理解方法调用"><a href="#_3-1-5-理解方法调用" class="header-anchor">#</a> 3.1.5 理解方法调用</h3> <p>假设要调用 <code>x.f(args)</code>，隐式参数 <code>x</code>声明为类 <code>C</code> 的一个对象。</p> <ol><li><p>编译器查看对象的声明类型和方法名。假设调用 <code>x.f(param)</code>，且隐式参数 <code>x</code> 声明为 <code>C</code> 类的对象。需要注意的是：有可能存在多个名字为 <code>f</code>，但参数类型不一样的方法。编译器将会一一列举所有 <code>C</code> 类中名为 <code>f</code> 的方法和其父类中访问属性为 <code>public</code> 且名为 <code>f</code> 的方法（父类的私有方法不可访问）。</p> <p>至此，编译器已获得所有可能被调用的候选方法。</p></li> <li><p>编译器将查看调用方法时提供的参数类型。如果在所有名为 <code>f</code> 的方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法。这个过程被称为重载解析（overloading resolution）。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</p> <p>至此，编译器已获得需要调用的方法名字和参数类型。</p></li> <li><p>如果是 <code>private</code> 方法、<code>static</code> 方法、<code>final</code> 方法或者构造器，那么编译器将可以准确的知道应该调用哪个方法，我们称这种调用方式为静态绑定（static binding）。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。</p></li> <li><p>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 <code>x</code> 所引用对象的实际类型最合适的那个类的方法。假设 <code>x</code> 的实际类型是 <code>D</code>，它是 <code>C</code> 的子类，如果 <code>D</code> 类定义了方法 <code>f(param)</code>，就直接调用它；否则，将在 <code>D</code> 类的父类中寻找。</p></li></ol> <p>每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。</p> <p>**警告：**在重写一个方法的时候，子类方法不能低于父类方法的可见性。特别是，如果父类方法是 <code>public</code>，子类方法一定要声明为 <code>public</code>。</p> <h3 id="_3-1-6-阻止继承-final-类和方法"><a href="#_3-1-6-阻止继承-final-类和方法" class="header-anchor">#</a> 3.1.6 阻止继承：final 类和方法</h3> <p>不允许扩展的类被称为 <code>final</code> 类。如果在定义类的时候使用了 <code>final</code> 修饰符就表明这个类是 <code>final</code> 类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Executive</span> <span class="token keyword">extends</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类中的特定方法也可以被声明为 <code>final</code>。如果这样做，子类就不能重写这个方法（<code>final</code> 类中的所有方法自动地成为 <code>final</code> 方法）。</p> <p>**注意：**如果将一个类声明为 <code>final</code> ，只有其中的方法自动地成为 <code>final</code>，而不包括域。</p> <p>在早期的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 <code>final</code> 关键字。如果一个方法没有被重写并且很短，编译器就能够对他进行优化处理，这个过程称为内联（inlining）。例如，内联调用 <code>e.getName()</code> 将被替换为访问 <code>e.name</code> 域。</p> <h3 id="_3-1-7-强制类型转换"><a href="#_3-1-7-强制类型转换" class="header-anchor">#</a> 3.1.7 强制类型转换</h3> <p>将一个值存入变量时，编译器将检查是否允许该操作。将一个子类的引用赋给一个父类的变量，编译器是允许的。但将一个父类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</p> <ul><li>只能在继承层次内进行类型转换</li> <li>在将父类转换成子类之前，应该使用 <code>instanceof</code> 进行检查</li></ul> <h3 id="_3-1-8-抽象类"><a href="#_3-1-8-抽象类" class="header-anchor">#</a> 3.1.8 抽象类</h3> <ul><li><p>包括一个或多个抽象方法的类本身必须被声明为抽象的</p></li> <li><p>除了抽象方法外，抽象类也可以包含具体数据和具体方法</p></li> <li><p>抽象方法充当着占位的角色，它们的具体实现在子类中</p></li> <li><p>类即使不含抽象方法，也可以将类声明为抽象类</p></li> <li><p>抽象类不能被实例化</p></li> <li><p>可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象</p></li></ul> <h3 id="_3-1-9-受保护访问"><a href="#_3-1-9-受保护访问" class="header-anchor">#</a> 3.1.9 受保护访问</h3> <ul><li><p>private——仅对本类可见</p></li> <li><p>public——对所有类可见</p></li> <li><p>protected——对本包和所有子类可见</p></li> <li><p>默认——对本包可见</p></li></ul> <h2 id="_3-2-object-所有类的父类"><a href="#_3-2-object-所有类的父类" class="header-anchor">#</a> 3.2 Object：所有类的父类</h2> <p>Object 类是 Java 中所有类的始祖，在 Java 中每个类都是由它扩展而来的。如果没有明确地指出父类，Object 类就被认为是这个类的父类。</p> <p>可以使用 Object 类型的变量引用任何类型的对象：</p> <div class="language- extra-class"><pre class="language-text"><code>Object obj = new Employee(&quot;Harry Hacker&quot;, 35000);
</code></pre></div><p>当然，Object 类型的变量只能用于作为各种值的通用持有者，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换：</p> <div class="language- extra-class"><pre class="language-text"><code>Employee e = (Employee) obj;
</code></pre></div><h3 id="_3-2-1-equals-方法"><a href="#_3-2-1-equals-方法" class="header-anchor">#</a> 3.2.1 equals 方法</h3> <p>Object 类中的 <code>equals</code> 方法用于检测一个对象是否等于另外一个对象。在 Object 类中这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同的引用，它们一定是相等的。</p> <p>在子类中定义 <code>equals</code> 方法时，首先调用父类的 <code>equals</code>。如果检测失败，对象就不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</p> <p>Java 语言规范要求 <code>equals</code> 方法具有下面的特征：</p> <ol><li><p>自反性：对于任何非空引用 <code>x</code>，<code>x.equals(x)</code> 应该返回 <code>true</code>。</p></li> <li><p>对称性：对于任何引用 <code>x</code> 和 <code>y</code>，当且仅当 <code>y.equals(x)</code> 返回 <code>true</code>，<code>x.equals(y)</code> 也应该返回 <code>true</code>。</p></li> <li><p>传递性：对于任何引用 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，<code>y.equals(z)</code> 返回 <code>true</code>，<code>x.equals(z)</code> 也应该返回 <code>true</code>。</p></li> <li><p>一致性：如果 <code>x</code> 和 <code>y</code> 引用的对象没有发生变化，反复调用 <code>x.equals(y)</code> 应该返回同样的结果。</p></li> <li><p>对于任意非空引用 <code>x</code>，<code>x.equals(null)</code> 返回 <code>false</code>。</p></li></ol> <h3 id="_3-2-2-hashcode-方法"><a href="#_3-2-2-hashcode-方法" class="header-anchor">#</a> 3.2.2 hashCode 方法</h3> <p>散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的，如果 <code>x</code> 和 <code>y</code> 是两个不同的对象，<code>x.hashCode()</code> 与 <code>y.hashCode()</code> 基本上不会相同。</p> <p>由于 <code>hashCode</code> 方法定义在 Object 类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。</p> <p><code>Equals</code> 与 <code>hashCode</code> 的定义必须一致：如果 <code>x.eqauls(y)</code> 返回 <code>true</code>，那么 <code>x.hashCode()</code> 就必须与 <code>y.hashCode()</code> 具有相同的值。</p> <h3 id="_3-2-3-tostring-方法"><a href="#_3-2-3-tostring-方法" class="header-anchor">#</a> 3.2.3 toString 方法</h3> <p>Object 类定义了 <code>toString</code> 方法，用来打印输出对象所属的类名和散列码。</p> <h2 id="_3-3-泛型数组列表"><a href="#_3-3-泛型数组列表" class="header-anchor">#</a> 3.3 泛型数组列表</h2> <p>在许多程序设计语言中，特别是在 C++ 语言中，必须在编译时就确定整个数组的大小。在 Java 中，情况就好多了，它允许在运行时确定数组的大小。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> actualSize <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span>actualSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>但是，一旦确定了数组的大小，改变它就不太容易了。在 Java 中，解决这个问题最简单的方法是使用 Java 中另外一个被称为 <code>ArrayList</code> 的类。它使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能。</p> <p><code>ArrayList</code> 是一个采用类型参数的泛型类，为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如，<code>ArrayList&lt;Employee&gt;</code>。</p> <p>如果调用 <code>add</code> 且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。</p> <p>一旦能过够确认数组列表的大小不再发生变化，就可以调用 <code>trimToSize</code> 方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。</p> <h3 id="_3-3-1-访问数组列表元素"><a href="#_3-3-1-访问数组列表元素" class="header-anchor">#</a> 3.3.1 访问数组列表元素</h3> <p>数组列表要设置第 i 个元素，可以使用 <code>staff.set(i, harry);</code>。它等价于对数组 <code>a</code> 的元素赋值 <code>a[i] = harry;</code>。</p> <p>**警告：**使用 <code>add</code> 方法为数组添加新元素，而不要使用 <code>set</code> 方法，它只能替换数组中已经存在的元素内容。</p> <p>数组列表要获取第 i 个元素，可以使用 <code>Employee e = staff.get(i);</code>。它等价于 <code>Employee e = a[i];</code>。</p> <p>没有泛型类时，原始的 ArrayList 类提供的 <code>get</code> 方法别无选择只能返回 <code>Object</code>，因此，<code>get</code> 方法的调用者必须对返回值进行类型转换。</p> <p>除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 <code>add</code> 方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> n <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
staff<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为了插入一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果插入新元素后，数组列表的大小超过了容量，数组列表就会被重新分配存储空间。</p> <p>同样的，可以从数组列表中间删除一个元素。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>位于这个位置之后的所有元素都向前移动一个位置，并且数组的大小减1。</p> <p>对数组实施插入和删除元素的操作其效率比较低。对于小型数组来说，这一点不必担心。但如果数组存储的元素数比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用链表了。</p> <h3 id="_3-3-2-类型化与原始数组列表的兼容性"><a href="#_3-3-2-类型化与原始数组列表的兼容性" class="header-anchor">#</a> 3.3.2 类型化与原始数组列表的兼容性</h3> <h2 id="_3-4-对象包装器与自动装箱"><a href="#_3-4-对象包装器与自动装箱" class="header-anchor">#</a> 3.4 对象包装器与自动装箱</h2> <p>所有的基本类型都有一个与之对应的类，通常，这些类称为包装器。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是 <code>final</code>，因此不能定义它们的子类。</p> <p>假设想定义一个整型数组列表，而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成 <code>ArrayList&lt;int&gt;</code>。这里就用到了 <code>Integer</code> 对象包装类。我们可以声明一个 <code>Integer</code> 对象的数组列表。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 自动装箱</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 自动拆箱</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>由于包装器类引用可以为 <code>null</code>，所以自动装箱有可能会抛出一个 <code>NullPointerException</code> 异常。</p></li> <li><p>如果在一个条件表达式中混合使用 <code>Integer</code> 和 <code>Double</code> 类型，<code>Integer</code> 值就会拆箱，提升为 <code>double</code>，再装箱为 <code>Double</code>。</p></li> <li><p>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</p></li></ul> <h2 id="_3-5-枚举类"><a href="#_3-5-枚举类" class="header-anchor">#</a> 3.5 枚举类</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，在此尽量不要构造新对象。</p> <p>因此，在比较两个枚举类型的值时，永远不需要调用 <code>equals</code>，而直接使用 <code>==</code> 就可以了。</p> <h2 id="_3-6-反射"><a href="#_3-6-反射" class="header-anchor">#</a> 3.6 反射</h2> <p>能够分析类能力的程序称为反射（reflective）。反射机制的功能极其强大，在下面可以看到，反射机制可以用来：</p> <ul><li><p>在运行时分析类的能力</p></li> <li><p>在运行时查看对象</p></li> <li><p>实现通用的数组操作代码</p></li> <li><p>利用 <code>Method</code> 对象</p></li></ul> <h3 id="_3-6-1-class-类"><a href="#_3-6-1-class-类" class="header-anchor">#</a> 3.6.1 Class 类</h3> <p>在程序运行期间，Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类，虚拟机利用运行时类型信息选择相应的方法执行。</p> <p>然而，可以通过专门的 Java 类访问这些信息，保存这些信息的类被称为 Class，Object 类中的 <code>getClass()</code> 方法将会返回一个 Class 类型的实例。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
<span class="token class-name">Class</span> <span class="token keyword">class</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">&quot;java.util.Random&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Class</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>虚拟机为每个类型管理一个 Class 对象，因此可以利用 <code>==</code> 运算符实现两个类对象比较的操作。</p> <p><code>newInstance()</code> 方法可以用来动态的创建一个类的实例。</p> <div class="language-java extra-class"><pre class="language-java"><code>e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>创建了一个与 <code>e</code> 具有相同类类型的实例，<code>newInstance()</code> 方法调用默认的构造器（没有参数的构造器）初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常。</p> <h3 id="_3-6-2-捕获异常"><a href="#_3-6-2-捕获异常" class="header-anchor">#</a> 3.6.2 捕获异常</h3> <p>异常有两种类型：未检查异常和已检查异常。</p> <p>对于已检查异常，编译器将会检查是否提供了“捕获异常”的处理器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    statement that might <span class="token keyword">throw</span> exceptions
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    handler action
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-6-3-利用反射分析类的能力"><a href="#_3-6-3-利用反射分析类的能力" class="header-anchor">#</a> 3.6.3 利用反射分析类的能力</h3> <h3 id="_3-6-4-在运行时使用反射分析对象"><a href="#_3-6-4-在运行时使用反射分析对象" class="header-anchor">#</a> 3.6.4 在运行时使用反射分析对象</h3> <h3 id="_3-6-5-调用任意方法"><a href="#_3-6-5-调用任意方法" class="header-anchor">#</a> 3.6.5 调用任意方法</h3> <h2 id="_3-7-继承的设计技巧"><a href="#_3-7-继承的设计技巧" class="header-anchor">#</a> 3.7 继承的设计技巧</h2> <ol><li><p>将公共操作和域放在父类</p></li> <li><p>不要使用受保护的域</p></li> <li><p>使用继承实现“is-a”关系</p></li> <li><p>除非所有继承的方法都有意义，否则不要使用继承</p></li> <li><p>在覆盖方法时，不要改变预期的行为</p></li> <li><p>使用多态，而非类型信息</p></li> <li><p>不要过多的使用反射</p></li></ol> <h1 id="_4-接口、lambda表达式与内部类"><a href="#_4-接口、lambda表达式与内部类" class="header-anchor">#</a> 4 接口、lambda表达式与内部类</h1> <hr> <h2 id="_4-1-接口"><a href="#_4-1-接口" class="header-anchor">#</a> 4.1 接口</h2> <h3 id="_4-1-1-接口概念"><a href="#_4-1-1-接口概念" class="header-anchor">#</a> 4.1.1 接口概念</h3> <p>在 Java 程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p> <ul><li><p>接口中的所有方法自动地属于 <code>public</code>。因此，在接口中声明方法时，不必提供关键字 <code>public</code>。</p></li> <li><p>接口中可以定义常量。</p></li> <li><p>接口绝不能含有实例域。</p></li> <li><p>在 Java SE 8 之前，不能在接口中实现方法。</p></li> <li><p>提供实例域和方法实现的任务应该由实现接口的那个类来完成。</p></li></ul> <h3 id="_4-1-2-接口的特性"><a href="#_4-1-2-接口的特性" class="header-anchor">#</a> 4.1.2 接口的特性</h3> <ul><li><p>接口不是类，尤其不能使用 <code>new</code> 运算符实例化一个接口。</p></li> <li><p>尽管不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象。</p></li> <li><p>可以使用 <code>instanceof</code> 检查一个对象是否实现了某个特定的接口。</p></li> <li><p>与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。</p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>虽然在接口中不能包含实例域或静态方法，但却可以包含常量。</li> <li>接口中的域将被自动设为 <code>public static final</code>。</li></ul> <h3 id="_4-1-3-接口与抽象类"><a href="#_4-1-3-接口与抽象类" class="header-anchor">#</a> 4.1.3 接口与抽象类</h3> <h3 id="_4-1-4-静态方法"><a href="#_4-1-4-静态方法" class="header-anchor">#</a> 4.1.4 静态方法</h3> <p>在 Java SE 8 中，允许在接口中增加静态方法。</p> <h3 id="_4-1-5-默认方法"><a href="#_4-1-5-默认方法" class="header-anchor">#</a> 4.1.5 默认方法</h3> <p>可以为接口方法提供一个默认实现，必须用 <code>default</code> 修饰符标记这样一个方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_4-1-6-解决默认方法冲突"><a href="#_4-1-6-解决默认方法冲突" class="header-anchor">#</a> 4.1.6 解决默认方法冲突</h3> <ol><li>父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li> <li>接口冲突。如果一个父接口提供了一个默认方法，另外一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须重写这个方法来解决冲突。</li></ol> <h2 id="_4-2-接口示例"><a href="#_4-2-接口示例" class="header-anchor">#</a> 4.2 接口示例</h2> <h3 id="_4-2-1-接口与回调"><a href="#_4-2-1-接口与回调" class="header-anchor">#</a> 4.2.1 接口与回调</h3> <p>回调（callback）是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p> <h3 id="_4-2-2-comparator-接口"><a href="#_4-2-2-comparator-接口" class="header-anchor">#</a> 4.2.2 Comparator 接口</h3> <h3 id="_4-2-3-对象克隆"><a href="#_4-2-3-对象克隆" class="header-anchor">#</a> 4.2.3 对象克隆</h3> <h2 id="_4-3-lambda-表达式"><a href="#_4-3-lambda-表达式" class="header-anchor">#</a> 4.3 lambda 表达式</h2> <h3 id="_4-3-1-为什么引用-lambda-表达式"><a href="#_4-3-1-为什么引用-lambda-表达式" class="header-anchor">#</a> 4.3.1 为什么引用 lambda 表达式</h3> <p>lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。</p> <h3 id="_4-3-2-lambda-表达式的语法"><a href="#_4-3-2-lambda-表达式的语法" class="header-anchor">#</a> 4.3.2 lambda 表达式的语法</h3> <p>参数，箭头以及一个表达式。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>即使 lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。</p> <p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至可以省略小括号。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_4-3-3-函数式接口"><a href="#_4-3-3-函数式接口" class="header-anchor">#</a> 4.3.3 函数式接口</h3> <p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为函数式接口。</p> <h3 id="_4-3-4-方法引用"><a href="#_4-3-4-方法引用" class="header-anchor">#</a> 4.3.4 方法引用</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>表达式 <code>System.out::println</code> 是一个方法引用，它等价于 lambda 表达式 <code>x -&gt; System.out.println(x)</code>。</p> <h3 id="_4-3-5-构造器引用"><a href="#_4-3-5-构造器引用" class="header-anchor">#</a> 4.3.5 构造器引用</h3> <p>构造器引用与方法引用很类似，只不过方法名为 <code>new</code>。例如，<code>Person::new</code> 是 Person 构造器的一个引用。</p> <h3 id="_4-3-6-变量作用域"><a href="#_4-3-6-变量作用域" class="header-anchor">#</a> 4.3.6 变量作用域</h3> <p>lambda 表达式可以捕获外围作用域中变量的值，并且只能引用值不会改变的变量。</p> <h3 id="_4-3-7-处理-lambda-表达式"><a href="#_4-3-7-处理-lambda-表达式" class="header-anchor">#</a> 4.3.7 处理 lambda 表达式</h3> <h2 id="_4-4-内部类"><a href="#_4-4-内部类" class="header-anchor">#</a> 4.4 内部类</h2> <p>内部类是定义在另一个类中的类。</p> <p>为什么需要使用内部类呢？其主要原因主要有以下三点：</p> <ul><li><p>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</p></li> <li><p>内部类可以对同一个包中的其他类隐藏起来。</p></li> <li><p>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</p></li></ul> <h3 id="_4-4-1-使用内部类访问对象状态"><a href="#_4-4-1-使用内部类访问对象状态" class="header-anchor">#</a> 4.4.1 使用内部类访问对象状态</h3> <p>内部类既可以访问自身的数据域，也可以访问创建它的外部类对象的数据域。</p> <p>内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。</p> <p>注：TimePrinter 为 TalkingClock 的内部类。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1592299001521-66b01d3e-f946-4a6a-b876-5c47cda115c2.png" alt="img"></p> <p>外部类的引用在构造器中设置，编译器修改了所有的内部类的构造器，添加一个外部类引用的参数。</p> <p>只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。</p> <h3 id="_4-4-2-内部类的特殊语法规则"><a href="#_4-4-2-内部类的特殊语法规则" class="header-anchor">#</a> 4.4.2 内部类的特殊语法规则</h3> <p><code>OuterClass.this</code> 表示外部类引用。</p> <p>如果内部类是 <code>public</code>，在外部类的作用域之外，可以这样引用内部类：<code>OuterClass.InnerClass</code>。</p> <p>内部类中声明的所有静态域都必须是 <code>final</code>。原因很简单，我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 <code>final</code>，它可能就不是唯一的。</p> <p>内部类不能有 <code>static</code> 方法。</p> <h3 id="_4-4-3-内部类是否有用、必要和安全"><a href="#_4-4-3-内部类是否有用、必要和安全" class="header-anchor">#</a> 4.4.3 内部类是否有用、必要和安全</h3> <p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 <code>$（美元符号）</code> 分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p> <h3 id="_4-4-4-局部内部类"><a href="#_4-4-4-局部内部类" class="header-anchor">#</a> 4.4.4 局部内部类</h3> <p>局部类不能用 <code>public</code> 或 <code>private</code> 访问修饰符进行声明，它的作用域被限定在声明这个局部类的块中。</p> <p>局部类有一个优势，即对外部世界可以完全地隐藏起来。即使外部类中的其他代码也不能访问它。</p> <h3 id="_4-4-5-由外部方法访问变量"><a href="#_4-4-5-由外部方法访问变量" class="header-anchor">#</a> 4.4.5 由外部方法访问变量</h3> <p>与其他内部类相比较，局部类还有一个优点，它们不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为 <code>final</code>。</p> <h3 id="_4-4-6-匿名内部类"><a href="#_4-4-6-匿名内部类" class="header-anchor">#</a> 4.4.6 匿名内部类</h3> <p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是，将构造器参数传递给父类构造器。</p> <h3 id="_4-4-7-静态内部类"><a href="#_4-4-7-静态内部类" class="header-anchor">#</a> 4.4.7 静态内部类</h3> <p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外部类对象。为此，可以将内部类声明为 <code>static</code>，以便取消产生的引用。</p> <p>与常规内部类不同，静态内部类可以有静态域和方法。</p> <p>声明在接口中的内部类自动成为 <code>static</code> 和 <code>public</code> 类。</p> <h1 id="_5-异常、断言和日志"><a href="#_5-异常、断言和日志" class="header-anchor">#</a> 5 异常、断言和日志</h1> <hr> <h2 id="_5-1-处理错误"><a href="#_5-1-处理错误" class="header-anchor">#</a> 5.1 处理错误</h2> <p>异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。</p> <p>需要关注的问题：</p> <ol><li><p>用户输入错误</p></li> <li><p>设备错误</p></li> <li><p>物理限制</p></li> <li><p>代码错误</p></li></ol> <p>在 Java 中，如果某个方法不能够采用正常的途径完成它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值，而是抛出一个封装了错误信息的对象。需要注意的是，这个方法将会立刻退出，并不返回任何值。此外，调用这个方法的代码也将无法继续执行，取而代之的是，异常处理机制开始搜索能过够处理这种异常状况的异常处理器。</p> <h3 id="_5-1-1-异常分类"><a href="#_5-1-1-异常分类" class="header-anchor">#</a> 5.1.1 异常分类</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1592313804558-c4f3e4e2-269f-49b9-b34f-b9618dfbe409.png" alt="img"></p> <p>需要注意的是，所有的异常都是由 Throwable 继承而来，但在下一层立即分解为两个分支：Error 和 Exception。</p> <p>Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象，如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。</p> <p>在设计 Java 程序时，需要关注 Exception 层次结构。这个层次结构又分解为两个分支：一个分支派生于 RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于 RuntimeException；而程序本身没有问题，但由于像 I/O 错误这类问题导致的异常属于其他异常。</p> <p>Java 语言规范将派生于 Error 类或 RuntimeException 类的所有异常称为非检查异常，所有其他的异常称为检查异常。编译器将检查是否为所有的检查异常提供了异常处理器。</p> <h3 id="_5-1-2-声明检查异常"><a href="#_5-1-2-声明检查异常" class="header-anchor">#</a> 5.1.2 声明检查异常</h3> <p>方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类检查异常。</p> <div class="language- extra-class"><pre class="language-text"><code>public FileInputStream(String name) throws FileNotFoundException
</code></pre></div><p>这个声明表示这个构造器将根据给定的 String 参数产生一个 <code>FileInputStream</code> 对象，但也有可能抛出一个 <code>FileNotFoundException</code> 异常。如果发生了这种糟糕的情况，构造器将不会初始化一个新的 <code>FileInputStream</code> 对象，而是抛出一个 <code>FileNotFoundException</code> 类对象。如果这个方法真的抛出了这样一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理 <code>FileNotFoundException</code> 对象。</p> <p>一个方法必须声明所有可能抛出的检查异常，而非检查异常要么不可控制，要么就应该避免发生。</p> <p>**注意：**如果在子类中重写了父类的一个方法，子类方法中声明的检查异常不能比父类方法中声明的异常更通用（也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常）。特别需要说明的是，如果父类方法没有抛出任何检查异常，子类也不能抛出任何检查异常。</p> <h3 id="_5-1-3-如何抛出异常"><a href="#_5-1-3-如何抛出异常" class="header-anchor">#</a> 5.1.3 如何抛出异常</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">EOFException</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EOFException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">throw</span> e<span class="token punctuation">;</span>
</code></pre></div><h3 id="_5-1-4-创建异常类"><a href="#_5-1-4-创建异常类" class="header-anchor">#</a> 5.1.4 创建异常类</h3> <p>在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，创建自己的异常类就是一件顺理成章的事情了。我们需要做的只是定义一个派生于 Exception 的类，或者派生于 Exception 子类的类。</p> <h2 id="_5-2-捕获异常"><a href="#_5-2-捕获异常" class="header-anchor">#</a> 5.2 捕获异常</h2> <h3 id="_5-2-1-捕获异常"><a href="#_5-2-1-捕获异常" class="header-anchor">#</a> 5.2.1 捕获异常</h3> <p>如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈信息。</p> <p>要想捕获一个异常，必须设置 try/catch 语句块。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
	code
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExceptionType</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	handler <span class="token keyword">for</span> <span class="token keyword">this</span> type
<span class="token punctuation">}</span>
</code></pre></div><p>如果在 try 语句块中的任何代码抛出了一个在 catch 子句中说明的异常类，那么</p> <ol><li>程序将跳过 try 语句块的其余代码。</li> <li>程序将执行 catch 子句中的处理器代码。</li></ol> <p>如果在 try 语句块中的代码没有抛出任何异常，那么程序将跳过 catch 子句。</p> <p>如果方法中的任何代码抛出了一个在 catch 子句中没有声明的异常类型，那么这个方法就会立刻退出。</p> <h3 id="_5-2-2-捕获多个异常"><a href="#_5-2-2-捕获多个异常" class="header-anchor">#</a> 5.2.2 捕获多个异常</h3> <p>在一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
	code that might <span class="token keyword">throw</span> exceptions
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	emergency action <span class="token keyword">for</span> missing files
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	emergency action <span class="token keyword">for</span> unknown hosts
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	emergency action <span class="token keyword">for</span> all other <span class="token class-name">I</span><span class="token operator">/</span><span class="token class-name">O</span> problems
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-2-3-再次抛出异常与异常链"><a href="#_5-2-3-再次抛出异常与异常链" class="header-anchor">#</a> 5.2.3 再次抛出异常与异常链</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
	access the database
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServletException</span><span class="token punctuation">(</span><span class="token string">&quot;database error: &quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-2-4-finally-子句"><a href="#_5-2-4-finally-子句" class="header-anchor">#</a> 5.2.4 finally 子句</h3> <p>不管是否有异常被捕获，finally 子句中的代码都会被执行。</p> <p>try 语句可以只有 finally 子句，而没有 catch 子句。</p> <p>**注意：**当 finally 子句包含 return 语句时，将会出现一种意想不到的结果。假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。</p> <h3 id="_5-2-5-分析堆栈轨迹元素"><a href="#_5-2-5-分析堆栈轨迹元素" class="header-anchor">#</a> 5.2.5 分析堆栈轨迹元素</h3> <p>堆栈轨迹（stack trace）是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。</p> <h2 id="_5-3-使用异常机制的技巧"><a href="#_5-3-使用异常机制的技巧" class="header-anchor">#</a> 5.3 使用异常机制的技巧</h2> <ol><li><p>异常处理不能代替简单的测试</p></li> <li><p>不要过分的细化异常</p></li> <li><p>利用异常层次结构</p></li> <li><p>不要压制异常</p></li> <li><p>在检测错误时，“苛刻”要比放任更好</p></li> <li><p>不要羞于传递异常</p></li></ol> <h2 id="_5-4-使用断言"><a href="#_5-4-使用断言" class="header-anchor">#</a> 5.4 使用断言</h2> <h3 id="_5-4-1-断言的概念"><a href="#_5-4-1-断言的概念" class="header-anchor">#</a> 5.4.1 断言的概念</h3> <p>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句将会被自动地移走。</p> <p>Java 语言引入了关键字 assert。这个关键字有两种形式：</p> <div class="language- extra-class"><pre class="language-text"><code>assert 条件;
assert 条件:表达式;
</code></pre></div><p>这两种形式都会对条件进行检测，如果结果为 <code>false</code>，则抛出一个 <code>AssertionError</code> 异常。在第二种形式中，表达式将被传入 <code>AssertionError</code> 的构造器，并转换成一个消息字符串。</p> <p><strong>注释：</strong>“表达式”部分的唯一目的是产生一个消息字符串。<code>AssertionError</code> 对象并不存储表达式的值，因此，不可能在以后得到它。正如 JDK 文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。</p> <h3 id="_5-4-2-启用和禁用断言"><a href="#_5-4-2-启用和禁用断言" class="header-anchor">#</a> 5.4.2 启用和禁用断言</h3> <p>在默认情况下，断言被禁用。可以在运行程序时用 <code>-enableassertions</code> 或 <code>-ea</code> 选项启用：</p> <div class="language- extra-class"><pre class="language-text"><code>java -enableassertions MyApp
</code></pre></div><p>需要注意的是，在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序的运行速度。</p> <p>可以用 <code>-disableassertions</code> 或 <code>-da</code> 禁用断言。</p> <p>然而，启用和禁用所有断言的 <code>-ea</code> 和 <code>-da</code> 开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类来说，需要使用 <code>-enablesystemassertions/-esa</code> 开关启用断言。</p> <h2 id="_5-5-记录日志"><a href="#_5-5-记录日志" class="header-anchor">#</a> 5.5 记录日志</h2> <h1 id="_6-泛型程序设计"><a href="#_6-泛型程序设计" class="header-anchor">#</a> 6 泛型程序设计</h1> <hr> <h2 id="_6-1-为什么要使用泛型程序设计"><a href="#_6-1-为什么要使用泛型程序设计" class="header-anchor">#</a> 6.1 为什么要使用泛型程序设计</h2> <h3 id="_6-1-1-类型参数的好处"><a href="#_6-1-1-类型参数的好处" class="header-anchor">#</a> 6.1.1 类型参数的好处</h3> <p>在 Java 中增加泛型类之前，泛型程序设计是用继承实现的。ArrayList 类只维护一个 Object 引用的数组：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种方法有两个问题。</p> <ol><li>当获取一个值时必须进行强制类型转换。</li> <li>没有错误检查，可以向数组列表中添加任何类的对象。</li></ol> <p>泛型提供了一个更好的解决方案：类型参数。</p> <div class="language- extra-class"><pre class="language-text"><code>ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;();
</code></pre></div><p>这使得代码具有更好的可读性和安全性。</p> <h3 id="_6-1-2-谁想成为泛型程序员"><a href="#_6-1-2-谁想成为泛型程序员" class="header-anchor">#</a> 6.1.2 谁想成为泛型程序员</h3> <h2 id="_6-2-定义简单泛型类"><a href="#_6-2-定义简单泛型类" class="header-anchor">#</a> 6.2 定义简单泛型类</h2> <p>一个泛型类就是具有一个或多个类型变量的类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">T</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">T</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>first <span class="token operator">=</span> newValue<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">T</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>second <span class="token operator">=</span> newValue<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>**注释：**类型变量使用大写形式，且比较短，这是很常见的。在 Java 库中，使用变量 E 表示集合的元素类型，K 和 V 分别表示关键字与值的类型，T （需要时还可以用邻近的字母 U 和 S）表示“任意类型”。</p> <h2 id="_6-3-泛型方法"><a href="#_6-3-泛型方法" class="header-anchor">#</a> 6.3 泛型方法</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ArrayAlg</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> a<span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">String</span> middle <span class="token operator">=</span> <span class="token class-name">ArrayAlg</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token function">getMiddle</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Q.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Public&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>类型变量放在修饰符的后面，返回类型的前面。</p> <p>泛型方法可以定义在普通类中，也可以定义在泛型类中。</p> <h2 id="_6-4-类型变量的限定"><a href="#_6-4-类型变量的限定" class="header-anchor">#</a> 6.4 类型变量的限定</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>在此为什么使用关键字 extends 而不是 implements？毕竟，Comparable 时一个接口。下面的记法 <code>&lt;T extends BoundingType&gt;</code> 表示 T 应该是绑定类型的子类型。T 和绑定类型可以是类，也可以是接口。</p> <p>一个类型变量或通配符可以有多个限定，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>T extends Comparable &amp; Serializable
</code></pre></div><p>限定类型用“&amp;”分隔，而逗号用来分隔类型变量。</p> <p>在 Java 的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。</p> <h2 id="_6-5-泛型代码和虚拟机"><a href="#_6-5-泛型代码和虚拟机" class="header-anchor">#</a> 6.5 泛型代码和虚拟机</h2> <h3 id="_6-5-1-类型擦除"><a href="#_6-5-1-类型擦除" class="header-anchor">#</a> 6.5.1 类型擦除</h3> <p>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（无限定的变量用 Object ）。</p> <p>例如，Pair<T> 的原始类型如下所示：</T></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Object</span> first<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> second<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> second <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">Object</span> first<span class="token punctuation">,</span> <span class="token class-name">Object</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> first<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirst</span><span class="token punctuation">(</span><span class="token class-name">Object</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>first <span class="token operator">=</span> newValue<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSecond</span><span class="token punctuation">(</span><span class="token class-name">Object</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>second <span class="token operator">=</span> newValue<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为 T 是一个无限定的变量，所以直接用 Object 替换。</p> <h3 id="_6-5-2-翻译泛型表达式"><a href="#_6-5-2-翻译泛型表达式" class="header-anchor">#</a> 6.5.2 翻译泛型表达式</h3> <h3 id="_6-5-3-翻译泛型方法"><a href="#_6-5-3-翻译泛型方法" class="header-anchor">#</a> 6.5.3 翻译泛型方法</h3> <h3 id="_6-5-4-调用遗留代码"><a href="#_6-5-4-调用遗留代码" class="header-anchor">#</a> 6.5.4 调用遗留代码</h3> <h2 id="_6-6-约束与局限性"><a href="#_6-6-约束与局限性" class="header-anchor">#</a> 6.6 约束与局限性</h2> <ol><li><p>不能用基本类型实例化类型参数</p></li> <li><p>运行时类型查询只适用于原始类型</p></li> <li><p>不能创建参数化类型的数组</p></li> <li><p>Varargs 警告</p></li> <li><p>不能实例化类型变量</p></li> <li><p>不能构造泛型数组</p></li> <li><p>泛型类的静态上下文中类型变量无效</p></li> <li><p>不能抛出或捕获泛型类的实例</p></li> <li><p>可以消除对检查异常的检查</p></li> <li><p>注意擦除后的冲突</p></li></ol> <h2 id="_6-7-泛型类型的继承规则"><a href="#_6-7-泛型类型的继承规则" class="header-anchor">#</a> 6.7 泛型类型的继承规则</h2> <h2 id="_6-8-通配符类型"><a href="#_6-8-通配符类型" class="header-anchor">#</a> 6.8 通配符类型</h2> <h3 id="_6-8-1-通配符概念"><a href="#_6-8-1-通配符概念" class="header-anchor">#</a> 6.8.1 通配符概念</h3> <p>通配符类型中，允许类型参数变化。例如，通配符类型 <code>Pair&lt;? extends Employee&gt;</code>。表示任何泛型 Pair 类型，它的类型参数是 Employee 的子类，如 <code>Pair&lt;Manager&gt;</code>，但不是 <code>Pair&lt;String&gt;</code>。</p> <h3 id="_6-8-2-通配符的超类型限定"><a href="#_6-8-2-通配符的超类型限定" class="header-anchor">#</a> 6.8.2 通配符的超类型限定</h3> <p>通配符限定于类型变量限定十分相似，但是，还有一个附加的能力，即可以指定一个超类型限定，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>? super Manager
</code></pre></div><p>这个通配符限制为 Manager 的所有超类型。</p> <h3 id="_6-8-3-无限定通配符"><a href="#_6-8-3-无限定通配符" class="header-anchor">#</a> 6.8.3 无限定通配符</h3> <h3 id="_6-8-4-通配符捕获"><a href="#_6-8-4-通配符捕获" class="header-anchor">#</a> 6.8.4 通配符捕获</h3> <h2 id="_6-9-反射和泛型"><a href="#_6-9-反射和泛型" class="header-anchor">#</a> 6.9 反射和泛型</h2> <h3 id="_6-9-1-泛型-class-类"><a href="#_6-9-1-泛型-class-类" class="header-anchor">#</a> 6.9.1 泛型 Class 类</h3> <h3 id="_6-9-2-使用-class-参数进行类型匹配"><a href="#_6-9-2-使用-class-参数进行类型匹配" class="header-anchor">#</a> 6.9.2 使用 Class 参数进行类型匹配</h3> <h3 id="_6-9-3-虚拟机中的泛型类型信息"><a href="#_6-9-3-虚拟机中的泛型类型信息" class="header-anchor">#</a> 6.9.3 虚拟机中的泛型类型信息</h3> <h1 id="_7-集合"><a href="#_7-集合" class="header-anchor">#</a> 7 集合</h1> <hr> <p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存在着很大差异。</p> <h2 id="_7-1-java-集合框架"><a href="#_7-1-java-集合框架" class="header-anchor">#</a> 7.1 Java 集合框架</h2> <h3 id="_7-1-1-将集合的接口与实现分离"><a href="#_7-1-1-将集合的接口与实现分离" class="header-anchor">#</a> 7.1.1 将集合的接口与实现分离</h3> <p>与现代的数据结构类库的常见情况一样，Java 集合类库也将接口与实现分离。</p> <p>队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象，并按照“先进先出”的规则检索对象时就应该使用队列。</p> <p>队列通常有两种实现方式：一种是使用循环数组；另一种是使用链表。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1592829098501-130a784f-6887-4bfc-92a4-debb7492b586.png" alt="img"></p> <h3 id="_7-1-2-collection-接口"><a href="#_7-1-2-collection-接口" class="header-anchor">#</a> 7.1.2 Collection 接口</h3> <p>在 Java 类库中，集合类的基本接口是 Collection 接口。这个接口有两个基本方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用于向集合中添加元素</span>
    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用于返回一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_7-1-3-迭代器"><a href="#_7-1-3-迭代器" class="header-anchor">#</a> 7.1.3 迭代器</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
	<span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过反复调用 next 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的尾部，next 方法将抛出一个 <code>NoSuchElementException</code>。因此，需要在调用 next 之前调用 hasNext 方法。如果迭代器对象还有多个供访问的元素，这个方法就返回 <code>true</code>。如果想要查看集合中的所有元素，就请求一个迭代器，并在 hasNext 返回 <code>true</code> 时反复地调用 next 方法。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iter <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token class-name">String</span> element <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> something <span class="token keyword">with</span> <span class="token namespace">element</span>
<span class="token punctuation">}</span>
</code></pre></div><p>用“for each”循环可以更加简练地表示同样的循环操作：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> element <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">do</span> something <span class="token keyword">with</span> <span class="token namespace">element</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器简单地将“for each”循环翻译为带有迭代器的循环。</p> <p>Collection 接口扩展了 Iterable 接口。因此，对于标准类库中的任何集合都可以使用“for each”循环。</p> <p>Java 集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。迭代器查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用 next，而在执行查找操作的同时，迭代器的位置随之向前移动。</p> <p>因此，应该将 Java 迭代器认为是位于两个元素之间。当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1592830682139-a6f623ba-8936-454f-a20c-f3e44ebfd4ed.png" alt="img"></p> <h3 id="_7-1-4-泛型实用方法"><a href="#_7-1-4-泛型实用方法" class="header-anchor">#</a> 7.1.4 泛型实用方法</h3> <h3 id="_7-1-5-集合框架中的接口"><a href="#_7-1-5-集合框架中的接口" class="header-anchor">#</a> 7.1.5 集合框架中的接口</h3> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593179348865-2e8e33a9-edd4-4dd2-95b0-0a8c36c5fcf5.png" alt="img"></p> <p>集合有两个基本接口：Collection 和 Map。</p> <p>List 是一个有序集合，元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问，因为这样可以按任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。</p> <p>Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集（Set）的 add 方法不允许增加重复的元素。要适当地定义集的 equals 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode 方法的定义要保证包含相同元素的两个集会得到相同的散列码。</p> <h2 id="_7-2-具体的集合"><a href="#_7-2-具体的集合" class="header-anchor">#</a> 7.2 具体的集合</h2> <table><thead><tr><th>集合类型</th> <th>描述</th></tr></thead> <tbody><tr><td>ArrayList</td> <td>一种可以动态增长和缩减的索引序列</td></tr> <tr><td>LinkedList</td> <td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td></tr> <tr><td>ArrayDeque</td> <td>一种用循环数组实现的双端队列</td></tr> <tr><td>HashSet</td> <td>一种没有重复元素的无序集合</td></tr> <tr><td>TreeSet</td> <td>一种有序集</td></tr> <tr><td>EnumSet</td> <td>一种包含枚举类型值的集</td></tr> <tr><td>LinkedHashSet</td> <td>一种可以记住元素插入次序的集</td></tr> <tr><td>PriorityQueue</td> <td>一种允许高效删除最小元素的集合</td></tr> <tr><td>HashMap</td> <td>一种存储键/值关联的数据结构</td></tr> <tr><td>TreeMap</td> <td>一种键值有序排列的映射表</td></tr> <tr><td>EnumMap</td> <td>一种键值属于枚举类型的映射表</td></tr> <tr><td>LinkedHashMap</td> <td>一种可以记住键/值项添加次序的映射表</td></tr> <tr><td>WeakHashMap</td> <td>一种其值无用武之地后可以被垃圾回收器回收的映射表</td></tr> <tr><td>IdentityHashMap</td> <td>一种用 == 而不是用 equals 比较键值的映射表</td></tr></tbody></table> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593183741549-d5c63aec-63d6-4f77-b614-afd59993081f.png" alt="img"></p> <h3 id="_7-2-1-链表"><a href="#_7-2-1-链表" class="header-anchor">#</a> 7.2.1 链表</h3> <p>数组和数组列表有一个重大的缺陷，这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。在数组中间的位置上插入一个元素也是如此。</p> <p>链表解决了这个问题。尽管数组在连续的存储位置上存放对象引用，但链表却将每个对象存放在独立的节点中。每个节点还存放着序列中下一个节点的引用。在 Java 程序设计语言中，所有链表实际上都是双向链接的——即每个节点还存放着指向前驱节点的作用。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593226873980-2c94cb4d-0b1e-4c57-bb6d-f30dba2ce7d8.png" alt="img"></p> <p>从链表中间删除一个元素是一个很轻松的操作，即需要更新被删除元素附近的链接。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593227035729-aca9352c-4d2b-453a-821a-14dc6b222254.png" alt="img"></p> <p>链表是一个有序集合，每个对象的位置十分重要。<code>LinkedList.add</code> 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的 <code>add</code> 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。</p> <p>链表不支持快速地随机访问，如果要查看链表中第 n 个元素，就必须从头开始，越过 n-1 个元素，没有捷径可走。</p> <h3 id="_7-2-2-数组列表"><a href="#_7-2-2-数组列表" class="header-anchor">#</a> 7.2.2 数组列表</h3> <h3 id="_7-2-3-散列集"><a href="#_7-2-3-散列集" class="header-anchor">#</a> 7.2.3 散列集</h3> <p>链表和数组可以按照人们的意愿排列元素的次序。但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中包含的元素很多，将会消耗很多时间。</p> <p>有一种众所周知的数据结构，可以快速地查找所需要的对象，这就是散列表（hash table）。散列表为每个对象计算一个整数，称为散列码（hash code）。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。</p> <p>如果自定义类，就要负责实现这个类的 hashCode 方法。注意，自己实现的 hashCode 方法应该与 equals 方法兼容，即如果 <code>a.equals(b)</code> 为 <code>true</code>，a 与 b 必须具有相同的散列码。</p> <p>在 Java 中，散列表用链表数组实现。每个列表被称为桶（bucket）。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。例如，如果某个对象的散列码为 76268，并且有 128 个桶，对象应该保存在第 108 号桶中（76268 除以 128 余 108）。或许会很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到桶被占满的情况，这种现象称为散列冲突（hash collision）。这时，需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593605516351-076c7da6-f97a-4d28-97a6-23a67ff7e6ee.png" alt="img"></p> <p>**注释：**在 Java 8 中，桶满时会从链表变为平衡二叉树。</p> <p>如果想更多地控制散列表的运行性能，就要指定一个初始的桶数。</p> <p>如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的 75%~150%。有些研究人员认为：尽管还没有确凿的证据，但最好将桶数设置为一个素数，以防键的聚集。标准类库使用的桶数是 2 的幂，默认值为 16.</p> <p>当然，并不是总能够知道需要存储多少个元素的，也有可能最初的估计过低。如果散列表太满，就需要再散列。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子决定何时对散列表进行再散列。例如，如果装填因子为 0.75 （默认值），而表中超过 75% 的位置已经填入元素，这个表就会用双倍的桶数自动地进行再散列。</p> <p>散列表可以用于实现几个重要的数据结构。其中最简单的是 Set 类型。Set 是没有重复元素的元素集合。Set 的 add 方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去。</p> <h3 id="_7-2-4-树集"><a href="#_7-2-4-树集" class="header-anchor">#</a> 7.2.4 树集</h3> <p>TreeSet 类与散列集十分类似，不过，它比散列集有所改进，树集是一个有序集合。可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。</p> <p>将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比还是快很多。</p> <p>**注释：**要使用树集，必须能够比较元素。这些元素必须实现 Comparable 接口，或者构造集时必须提供一个 Comparator。</p> <h3 id="_7-2-5-队列与双端队列"><a href="#_7-2-5-队列与双端队列" class="header-anchor">#</a> 7.2.5 队列与双端队列</h3> <p>队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。有两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。</p> <h3 id="_7-2-6-优先级队列"><a href="#_7-2-6-优先级队列" class="header-anchor">#</a> 7.2.6 优先级队列</h3> <p>优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用 remove 方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。优先级队列使用了一个优雅且高效的数据结构，称为堆（heap）。堆是一个可以自我调整的二叉树，对树执行添加（add）和删除（remove）操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p> <p>使用优先级队列的典型示例是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中，每当启动一个新的任务时，都将优先级最高的任务从队列中删除（由于习惯上将 1 设为&quot;最高&quot;优先级，所以会将最小的元素删除）。</p> <h2 id="_7-3-映射"><a href="#_7-3-映射" class="header-anchor">#</a> 7.3 映射</h2> <p>集是一个集合，它可以快速地查找现有的元素。但是，要查看一个元素，需要有要查找元素的精确副本。这不是一种非常通用的查找方式。通常，我们知道某些键的信息，并想要查找与之对应的元素。映射（map）数据结构就是为此设计的，映射用来存放键/值对，如果提供了键，就能够查找到值。</p> <h3 id="_7-3-1-基本映射操作"><a href="#_7-3-1-基本映射操作" class="header-anchor">#</a> 7.3.1 基本映射操作</h3> <p>Java 类库为映射提供了两个通用的实现：HashMap 和 TreeMap。这两个类都实现了 Map 接口。</p> <p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。</p> <p>键必须是唯一的，不能对同一个键存放两个值。如果对同一个键两次调用 put 方法，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</p> <h3 id="_7-3-2-更新映射项"><a href="#_7-3-2-更新映射项" class="header-anchor">#</a> 7.3.2 更新映射项</h3> <h3 id="_7-3-3-映射视图"><a href="#_7-3-3-映射视图" class="header-anchor">#</a> 7.3.3 映射视图</h3> <p>集合框架不认为映射本身是一个集合。不过，可以得到映射的视图（view）——这是实现了 Collection 接口或某个子接口的对象。</p> <p>有 3 种视图：键集、值集合以及键/值对集。下面的方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>会分别返回这 3 个视图。</p> <h3 id="_7-3-4-弱散列映射"><a href="#_7-3-4-弱散列映射" class="header-anchor">#</a> 7.3.4 弱散列映射</h3> <h3 id="_7-3-5-链接散列集与映射"><a href="#_7-3-5-链接散列集与映射" class="header-anchor">#</a> 7.3.5 链接散列集与映射</h3> <p>LinkedHashSet 和 LinkedHashMap 类用来记住插入元素项的顺序，这样就可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593661029937-14af553f-df61-48c4-970b-93b85244facc.png" alt="img"></p> <p>链接散列映射将用访问顺序，而不是插入顺序，对映射条目进行迭代。每次调用 get 或 put，受到影响的条目将从当前的位置删除，并放到条目链表的尾部。</p> <h3 id="_7-3-6-枚举集与映射"><a href="#_7-3-6-枚举集与映射" class="header-anchor">#</a> 7.3.6 枚举集与映射</h3> <h3 id="_7-3-7-标识散列映射"><a href="#_7-3-7-标识散列映射" class="header-anchor">#</a> 7.3.7 标识散列映射</h3> <h2 id="_7-4-视图与包装器"><a href="#_7-4-视图与包装器" class="header-anchor">#</a> 7.4 视图与包装器</h2> <p>通过使用视图可以获得其他的实现了 Collection 接口和 Map 接口的对象。映射类的 keySet 方法就是一个这样的示例。初看起来，好像这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet 方法返回一个实现 Set 接口的类对象，这个类的方法对原映射进行操作，这种集合称为视图。</p> <h3 id="_7-4-1-轻量级集合包装器"><a href="#_7-4-1-轻量级集合包装器" class="header-anchor">#</a> 7.4.1 轻量级集合包装器</h3> <p>Arrays 类的静态方法 asList 将返回一个包装了普通 Java 数组的 List 包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Card</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cardDeck <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Card</span><span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Card</span><span class="token punctuation">&gt;</span></span> cardList <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>cardDeck<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>返回的对象不是 ArrayList。它是一个视图对象，带有访问底层数组的 get 和 set 方法。</p> <h3 id="_7-4-2-子范围"><a href="#_7-4-2-子范围" class="header-anchor">#</a> 7.4.2 子范围</h3> <p>可以为很多集合建立子范围视图。例如，假设有一个列表 staff，想从中取出第 10 个~第 19 个元素。可以使用 subList方法来获得一个列表的子范围视图。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span> group2 <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第一个索引包含在内，第二个索引则不包含在内。这与 String 类的 substring 操作中的参数情况相同。</p> <h3 id="_7-4-3-不可修改的视图"><a href="#_7-4-3-不可修改的视图" class="header-anchor">#</a> 7.4.3 不可修改的视图</h3> <p>Collections 还有几个方法，用于产生集合的不可修改视图。这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改，就抛出一个异常，同时这个集合将保持未修改的状态。</p> <h3 id="_7-4-4-同步视图"><a href="#_7-4-4-同步视图" class="header-anchor">#</a> 7.4.4 同步视图</h3> <h3 id="_7-4-5-受查视图"><a href="#_7-4-5-受查视图" class="header-anchor">#</a> 7.4.5 受查视图</h3> <h2 id="_7-5-算法"><a href="#_7-5-算法" class="header-anchor">#</a> 7.5 算法</h2> <h3 id="_7-5-1-排序与混排"><a href="#_7-5-1-排序与混排" class="header-anchor">#</a> 7.5.1 排序与混排</h3> <p>Collections 类中的 sort 方法可以对实现了 List 接口的集合进行排序。这个方法假定列表元素实现了 Comparable 接口。如果想采用其他方式对列表进行排序，可以使用 List 接口的 sort 方法并传入一个 Comparator 对象。</p> <p>人们可能会对 sort 方法所采用的排序手段感到好奇。通常，在翻阅有关算法书籍中的排序算法时，会发觉介绍的都是有关数组的排序算法，而且使用的是随机访问方式。但是，对列表进行随机访问的效率很低。实际上，可以使用归并排序对列表进行高效的排序。然而，Java 程序设计语言并不是这样实现的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。</p> <h3 id="_7-5-2-二分查找"><a href="#_7-5-2-二分查找" class="header-anchor">#</a> 7.5.2 二分查找</h3> <p>要想在数组中查找一个对象，通常要依次访问数组中的每个元素，直到找到匹配的元素为止。然而，如果数组是有序的，就可以直接查看位于数组中间的元素，看一看是否大于要查找的元素。如果是，用同样的方法在数组的前半部分继续查找；否则，用同样的方法在数组的后半部分继续查找。</p> <p>Collections 类的 binarySearch 方法实现了这个算法。注意，集合必须是排好序的，否则算法将返回错误的答案。</p> <h3 id="_7-5-3-简单算法"><a href="#_7-5-3-简单算法" class="header-anchor">#</a> 7.5.3 简单算法</h3> <h3 id="_7-5-4-批操作"><a href="#_7-5-4-批操作" class="header-anchor">#</a> 7.5.4 批操作</h3> <h3 id="_7-5-5-集合与数组的转换"><a href="#_7-5-5-集合与数组的转换" class="header-anchor">#</a> 7.5.5 集合与数组的转换</h3> <h2 id="_7-6-遗留的集合"><a href="#_7-6-遗留的集合" class="header-anchor">#</a> 7.6 遗留的集合</h2> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542472/1593700115184-7625278c-0e44-4fd7-b6ad-cac630d8ea9a.png" alt="img"></p> <h1 id="_8-部署-java-应用程序"><a href="#_8-部署-java-应用程序" class="header-anchor">#</a> 8 部署 Java 应用程序</h1> <hr> <h2 id="_8-1-jar-文件"><a href="#_8-1-jar-文件" class="header-anchor">#</a> 8.1 JAR 文件</h2> <p>在将应用程序进行打包时，使用者一定希望仅提供给其一个单独的文件，而不是一个含有大量类文件的目录，Java 归档（JAR）文件就是为此目的而设计的。一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音这些其他类型的文件。此外，JAR 文件是压缩的，它使用了大家熟悉的 ZIP 压缩格式。</p> <h3 id="_8-1-1-创建-jar-文件"><a href="#_8-1-1-创建-jar-文件" class="header-anchor">#</a> 8.1.1 创建 JAR 文件</h3> <p>可以使用 jar 工具制作 JAR 文件（在默认的 JDK 安装中，位于 jdk/bin 目录下）。创建一个新的 JAR 文件应该使用的常见命令格式为：</p> <div class="language- extra-class"><pre class="language-text"><code>jar cvf JARFileName File1 File2 ...
</code></pre></div><p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>jar cvf CalculatorClasses.jar *.class icon.gif
</code></pre></div><p>通常，jar 命令的格式如下：</p> <div class="language- extra-class"><pre class="language-text"><code>jar options File1 File2 ...
</code></pre></div><h3 id="_8-1-2-清单文件"><a href="#_8-1-2-清单文件" class="header-anchor">#</a> 8.1.2 清单文件</h3> <p>除了类文件、图像和其他资源外，每个 JAR 文件还包含一个用于描述归档特征的清单文件。清单文件被命名为 MANIFEST.MF，它位于 JAR 文件的一个特殊 META-INF 子目录中。</p> <h3 id="_8-1-3-可执行-jar-文件"><a href="#_8-1-3-可执行-jar-文件" class="header-anchor">#</a> 8.1.3 可执行 JAR 文件</h3> <p>可以使用 jar 命令中的 e 选项指定程序的入口点，即通常需要在调用 java 程序加载器时指定的类：</p> <div class="language- extra-class"><pre class="language-text"><code>jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass ``*files to add*
</code></pre></div><p>或者，可以在清单中指定应用程序的主类，包括以下形式的语句：</p> <div class="language- extra-class"><pre class="language-text"><code>Main-Class: com.mycompany.mypkg.MainAppClass
</code></pre></div><p>不要将扩展名 .class 添加到主类名中。</p> <p>**警告：**清单文件的最后一行必须以换行符结束。否则，清单文件将无法被正确的读取。</p> <p>不论哪一种方法，用户可以简单地通过下面命令来启动应用程序：</p> <div class="language- extra-class"><pre class="language-text"><code>java -jar MyProgram.jar
</code></pre></div><h3 id="_8-1-4-资源"><a href="#_8-1-4-资源" class="header-anchor">#</a> 8.1.4 资源</h3> <p>在应用程序中使用的类通常需要使用一些相关的数据文件。例如：</p> <ul><li><p>图像和声音文件</p></li> <li><p>带有消息字符串和按钮标签的文本文件</p></li> <li><p>二进制数据文件，例如，描述地图布局的文件</p></li></ul> <p>在 Java 中，这些关联的文件被称为资源。</p> <h3 id="_8-1-5-密封"><a href="#_8-1-5-密封" class="header-anchor">#</a> 8.1.5 密封</h3> <h2 id="_8-2-应用首选项的存储"><a href="#_8-2-应用首选项的存储" class="header-anchor">#</a> 8.2 应用首选项的存储</h2> <h3 id="_8-2-1-属性映射"><a href="#_8-2-1-属性映射" class="header-anchor">#</a> 8.2.1 属性映射</h3> <p>属性映射是一种存储键/值对的数据结构。属性映射通常用来存储配置信息，它有 3 个特性：</p> <ul><li><p>键和值是字符串</p></li> <li><p>映射可以很容易的存入文件以及从文件加载</p></li> <li><p>有一个二级表保存默认值</p></li></ul> <p>实现属性映射的 Java 类名为 Properties。</p> <h3 id="_8-2-2-首选项-api"><a href="#_8-2-2-首选项-api" class="header-anchor">#</a> 8.2.2 首选项 API</h3> <h2 id="_8-3-服务加载器"><a href="#_8-3-服务加载器" class="header-anchor">#</a> 8.3 服务加载器</h2> <p>若有收获，就点个赞吧</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./coding-base/java基础语法/《Java核心技术 卷I》阅读笔记.html" class="prev">
        《Java核心技术 卷I》阅读笔记
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.9ce0d262.js" defer></script><script src="./assets/js/2.fa5f1a4a.js" defer></script><script src="./assets/js/71.c8bafdac.js" defer></script>
  </body>
</html>
